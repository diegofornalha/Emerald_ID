import { config as config$1 } from '@onflow/config';
export { config } from '@onflow/config';
import { invariant } from '@onflow/util-invariant';
import * as sdk from '@onflow/sdk';
import { arg, send as send$1, getTransactionStatus, decode, encodeMessageFromSignable, config as config$2, resolve, pipe, interaction, createSignableVoucher, block, getEventsAtBlockHeightRange } from '@onflow/sdk';
export { TestUtils, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, createSignableVoucher, decode, getAccount, getBlock, getBlockHeader, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getTransaction, getTransactionStatus, invariant, isBad, isOk, limit, param, params, payer, ping, pipe, proposer, ref, script, send, transaction, validator, voucherIntercept, voucherToTxId, why } from '@onflow/sdk';
import * as t$1 from '@onflow/types';
import { spawn as spawn$1, send, SUBSCRIBE as SUBSCRIBE$1, UNSUBSCRIBE as UNSUBSCRIBE$1, INIT as INIT$1, subscriber as subscriber$1, snapshoter, UPDATED as UPDATED$4, SNAPSHOT as SNAPSHOT$2 } from '@onflow/util-actor';
import { withPrefix, sansPrefix } from '@onflow/util-address';
export { display, sansPrefix, withPrefix } from '@onflow/util-address';
import * as rlp from '@onflow/rlp';
import { Buffer, encode } from '@onflow/rlp';
import { uid } from '@onflow/util-uid';
export { template as cadence, template as cdc } from '@onflow/util-template';

const VERSION = "1.0.1" ;

const isServerSide = () => typeof window === "undefined";

const SESSION_STORAGE = {
  can: !isServerSide(),
  get: async key => JSON.parse(sessionStorage.getItem(key)),
  put: async (key, value) => sessionStorage.setItem(key, JSON.stringify(value))
};
const STORAGE_DEFAULT = SESSION_STORAGE;
const DISCOVERY_METHOD = "IFRAME/RPC";
async function configLens(regex) {
  return Object.fromEntries(Object.entries(await config$1().where(regex)).map(([key, value]) => [key.replace(regex, ""), value]));
}
async function getDiscoveryService() {
  const discoveryWallet = await config$1.first(["discovery.wallet", "challenge.handshake"]);
  const discoveryAuthnInclude = await config$1.get("discovery.authn.include", []);
  const discoveryWalletMethod = await config$1.first(["discovery.wallet.method", "discovery.wallet.method.default"]);
  return {
    type: "authn",
    endpoint: discoveryWallet,
    method: discoveryWalletMethod,
    discoveryAuthnInclude
  };
}

config$1({
  "discovery.wallet.method.default": DISCOVERY_METHOD,
  "fcl.storage.default": STORAGE_DEFAULT
});

const is = type => d => typeof d === type;

const isRequired = d => d != null;
const isObject = is("object");
const isString = is("string");
const isFunc = is("function");
const isNumber = is("number");

function normalizeArgs(ax) {
  if (isFunc(ax)) return ax(sdk.arg, t$1);
  return [];
}

/** Query the Flow Blockchain
 *
 *  @arg {Object} opts         - Query Options and configuration
 *  @arg {string} opts.cadence - Cadence Script used to query Flow
 *  @arg {ArgsFn} opts.args    - Arguments passed to cadence script
 *  @arg {number} opts.limit   - Compute Limit for Query
 *  @returns {Promise<Response>}
 *
 *  Where:
 *    @callback ArgsFn
 *    @arg {ArgFn}  arg - Argument function to define a single argument
 *    @arg {Object} t   - Cadence Types object used to define the type
 *    @returns {args[]}
 *
 *    @callback ArgFn
 *    @arg {Any}  value - the value of the argument
 *    @arg {Type} type  - the cadence type of the value
 *    @returns {arg}
 *
 *  Example:
 *    const cadence = `
 *      cadence: `
 *        pub fun main(a: Int, b: Int, c: Address): Int {
 *          log(c)
 *          return a + b
 *        }
 *    `.trim()
 *
 *    const args = (arg, t) => [
 *      arg(5, t.Int),
 *      arg(7, t.Int),
 *      arg("0xb2db43ad6bc345fec9", t.Address),
 *    ]
 *
 *    await query({ cadence, args })
 */

async function query(opts = {}) {
  await preQuery(opts); // prettier-ignore

  return sdk.send([sdk.script(opts.cadence), sdk.args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === "number" && sdk.limit(opts.limit)]).then(sdk.decode);
}

async function preQuery(opts) {
  invariant(isRequired(opts.cadence), "query({ cadence }) -- cadence is required");
  invariant(isString(opts.cadence), "query({ cadence }) -- cadence must be a string");
  invariant(await sdk.config.get("accessNode.api"), `Required value for "accessNode.api" not defined in config. See: ${"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration"}`);
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

async function fetchServices(servicesURL, code) {
  if (servicesURL == null || code == null) return [];
  const url = new URL(servicesURL);
  url.searchParams.append("code", code);
  const resp = await fetch(url, {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  }).then(d => d.json());
  if (Array.isArray(resp)) return resp; // Backwards compatibility for First-Gen Wallet Providers

  const services = []; // Convert authorizations into authz services

  if (Array.isArray(resp.authorizations)) {
    for (let service of resp.authorizations) {
      services.push(_extends$2({
        type: "authz",
        keyId: resp.keyId
      }, service));
    }
  } // Convert Provider info into an authn service


  if (resp.provider != null) {
    services.push(_extends$2({
      type: "authn",
      id: "wallet-provider#authn"
    }, resp.provider));
  }

  return services;
}

function mergeServices(sx1 = [], sx2 = []) {
  // TODO: Make this smarter
  return [...sx1, ...sx2];
}

const SERVICE_PRAGMA = {
  f_type: "Service",
  f_vsn: "1.0.0"
};
const IDENTITY_PRAGMA = {
  f_type: "Identity",
  f_vsn: "1.0.0"
};
const USER_PRAGMA = {
  f_type: "USER",
  f_vsn: "1.0.0"
};
const POLLING_RESPONSE_PRAGMA = {
  f_type: "PollingResponse",
  f_vsn: "1.0.0"
};
const COMPOSITE_SIGNATURE_PRAGMA = {
  f_type: "CompositeSignature",
  f_vsn: "1.0.0"
};

//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "authn",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "identity": {
//     "address": "0x____"
//   },
//   "provider": {
//     "address": "0x____",
//     "name": "Best Wallet",
//     "description": "The Best Wallet"
//     "icon": "https://",
//   }
// }

function normalizeAuthn(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: service.type,
        uid: service.id,
        endpoint: service.authn,
        id: service.pid,
        provider: {
          address: withPrefix(service.addr),
          name: service.name,
          icon: service.icon
        }
      });
  }
}

//   "f_type": "service",
//   "f_vsn": "1.0.0",
//   "type": "authz",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "identity": {
//      "address": "0x______",
//      "keyId": 0,
//   },
//   "data": {}, // included in body of authz request
//   "params": {}, // included as query params on endpoint url
// }

function normalizeAuthz(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: service.type,
        uid: service.id,
        endpoint: service.endpoint,
        method: service.method,
        identity: _extends$2({}, IDENTITY_PRAGMA, {
          address: withPrefix(service.addr),
          keyId: service.keyId
        }),
        params: service.params,
        data: service.data
      });
  }
}

//   "f_type": "service",
//   "f_vsn": "1.0.0",
//   "type": "pre-authz",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "identity": {
//      "address": "0x______",
//      "keyId": 0,
//   },
//   "data": {}, // included in body of pre-authz request
//   "params": {}, // included as query params on endpoint url
// }

function normalizePreAuthz(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: service.type,
        uid: service.id,
        endpoint: service.endpoint,
        method: service.method,
        identity: _extends$2({}, IDENTITY_PRAGMA, {
          address: withPrefix(service.addr),
          keyId: service.keyId
        }),
        params: service.params,
        data: service.data
      });
  }
}

//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    "type": "frame",
//    "endpoint": "https://rawr",
//    "data": {},   // Sent to frame when ready
//    "params": {}, // include in query params on frame
// }

function normalizeFrame(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({
        old: service
      }, SERVICE_PRAGMA, {
        type: "frame",
        endpoint: service.endpoint,
        params: service.params || {},
        data: service.data || {}
      });
  }
}

//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    "type": "back-channel-rpc",
//    "endpoint": "https://rawr",
//    "method": "HTTP/GET", // HTTP/GET | HTTP/POST
//    "data": {},           // included in body of rpc
//    "params": {},         // included as query params on endpoint url
// }

function normalizeBackChannelRpc(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: "back-channel-rpc",
        endpoint: service.endpoint,
        method: service.method,
        params: service.params || {},
        data: service.data || {}
      });
  }
}

//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "open-id",
//   "uid": "uniqueDedupeKey",
//   "method: "data",
//   "data": {
//      "profile": {
//        "name": "Bob",
//        "family_name": "Builder",
//        "given_name": "Robert",
//        "middle_name": "the",
//        "nickname": "Bob the Builder",
//        "perferred_username": "bob",
//        "profile": "https://www.bobthebuilder.com/",
//        "picture": "https://avatars.onflow.org/avatar/bob",
//        "gender": "...",
//        "birthday": "2001-01-18",
//        "zoneinfo": "America/Vancouver",
//        "locale": "en-us",
//        "updated_at": "1614970797388"
//      },
//      "email": {
//        "email": "bob@bob.bob",
//        "email_verified": true
//      },
//      "address": {
//        "address": "One Apple Park Way, Cupertino, CA 95014, USA"
//      },
//      "phone": {
//        "phone_number": "+1 (xxx) yyy-zzzz",
//        "phone_number_verified": true
//      },
//      "social": {
//        "twitter": "@_qvvg",
//        "twitter_verified": true
//      },
//   }
// }

function normalizeOpenId(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return null;
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "user-signature",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "IFRAME/RPC", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "data": {}, // included in body of user-signature request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeUserSignature(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      throw new Error("Invalid user-signature service");
  }
}

//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    type: "local-view",
//    method: "VIEW/IFRAME",
//    endpoint: "https://woot.org/authz/local",
//    data: {},
//    params: {},
// }

function normalizeLocalView(resp) {
  if (resp == null) return null;

  if (resp.method == null) {
    resp = _extends$2({}, resp, {
      type: "local-view",
      method: "VIEW/IFRAME"
    });
  }

  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: resp.type || "local-view",
        method: resp.method,
        endpoint: resp.endpoint,
        data: resp.data || {},
        params: resp.params || {}
      });
  }
}

// {
//   "f_type": "Service",                    // Its a service!
//   "f_vsn": "1.0.0",                       // Follows the v1.0.0 spec for the service
//   "type": "account-proof",                // the type of service it is
//   "method": "DATA",                       // Its data!
//   "uid": "awesome-wallet#account-proof",  // A unique identifier for the service
//   "data": {
//     "f_type": "account-proof",
//     "f_vsn": "1.0.0",
//     "nonce": "0A1BC2FF",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)
//     "address": "0xUSER",                  // The user's address (8 bytes, i.e 16 hex characters)
//     "signature": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)
// }
function normalizeAccountProof(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      throw new Error(`FCL Normalizer Error: Invalid account-proof service`);
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "authn-refresh",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST",  // "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "data": {}, // included in body of request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeAuthnRefresh(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      throw new Error("Invalid authn-refresh service");
  }
}

const serviceNormalizers = {
  "back-channel-rpc": normalizeBackChannelRpc,
  "pre-authz": normalizePreAuthz,
  authz: normalizeAuthz,
  authn: normalizeAuthn,
  frame: normalizeFrame,
  "open-id": normalizeOpenId,
  "user-signature": normalizeUserSignature,
  "local-view": normalizeLocalView,
  "account-proof": normalizeAccountProof,
  "authn-refresh": normalizeAuthnRefresh
};
function normalizeService(service, data) {
  try {
    var normalized = serviceNormalizers[service.type](service, data);
    return normalized;
  } catch (error) {
    console.error(`Unrecognized FCL Service Type [${service.type}]`, service, error);
    return service;
  }
}

function deriveCompositeId(authn) {
  return rlp.encode([authn.provider.address || authn.provider.name || "UNSPECIFIED", authn.id]).toString("hex");
}

function normalizeData(data) {
  data.addr = data.addr ? withPrefix(data.addr) : null;
  data.paddr = data.paddr ? withPrefix(data.paddr) : null;
  return data;
}

function findService(type, services) {
  return services.find(d => d.type === type);
}

async function buildUser(data) {
  data = normalizeData(data);
  var services = mergeServices(data.services || [], await fetchServices(data.hks, data.code)).map(service => normalizeService(service, data));
  const authn = findService("authn", services);
  return _extends$2({}, USER_PRAGMA, {
    addr: withPrefix(data.addr),
    cid: deriveCompositeId(authn),
    loggedIn: true,
    services: services,
    expiresAt: data.expires
  });
}

function serviceOfType(services = [], type) {
  return services.find(service => service.type === type);
}

function serviceEndpoint(service) {
  const url = new URL(service.endpoint);
  url.searchParams.append("l6n", window.location.origin);

  if (service.params != null) {
    for (let [key, value] of Object.entries(service.params || {})) {
      url.searchParams.append(key, value);
    }
  }

  return url;
}

function fetchService(service, opts = {}) {
  const method = opts.method || "POST";
  const body = method === "GET" ? undefined : JSON.stringify(opts.data || service.data || {});
  return fetch(serviceEndpoint(service), {
    method: method,
    headers: _extends$2({}, service.headers || {}, opts.headers || {}, {
      "Content-Type": "application/json"
    }),
    body: body
  }).then(d => d.json());
}

//    "f_type": "PollingResponse",
//    "f_vsn": "1.0.0",
//    "status": "PENDING", // PENDING | APPROVED | DECLINED | REDIRECT
//    "reason": null,      // Reason for Declining Transaction
//    "data": null,        // Return value for APPROVED
//    "updates": BackChannelRpc,
//    "local": Frame,
// }

function normalizePollingResponse(resp) {
  var _resp$status, _resp$reason;

  if (resp == null) return null;

  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;

    default:
      return _extends$2({}, POLLING_RESPONSE_PRAGMA, {
        status: (_resp$status = resp.status) != null ? _resp$status : "APPROVED",
        reason: (_resp$reason = resp.reason) != null ? _resp$reason : null,
        data: resp.compositeSignature || resp.data || _extends$2({}, resp) || {},
        updates: normalizeBackChannelRpc(resp.authorizationUpdates),
        local: normalizeFrame((resp.local || [])[0])
      });
  }
}

const OPTIONS = {
  "HTTP/GET": "GET",
  "HTTP/POST": "POST"
};

const serviceMethod = service => {
  invariant(OPTIONS[service.method], "Invalid Service Method for type back-channel-rpc", {
    service
  });
  return OPTIONS[service.method];
};

async function poll(service, canContinue = () => true) {
  invariant(service, "Missing Polling Service", {
    service
  });
  if (!canContinue()) throw new Error("Externally Halted");
  const resp = await fetchService(service, {
    method: serviceMethod(service)
  }).then(normalizePollingResponse);

  switch (resp.status) {
    case "APPROVED":
      return resp.data;

    case "DECLINED":
      throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);

    default:
      await new Promise(r => setTimeout(r, 500));
      return poll(resp.updates, canContinue);
  }
}

const FRAME = "FCL_IFRAME";
const FRAME_STYLES = `
  position:fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  height: 100%;
  width: 100vw;
  display:block;
  background:rgba(0,0,0,0.25);
  z-index: 2147483647;
  box-sizing: border-box;
`;
function renderFrame(src) {
  invariant(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
    src
  });
  const $frame = document.createElement("iframe");
  $frame.src = src;
  $frame.id = FRAME;
  $frame.allow = "usb *; hid *";
  $frame.frameBorder = "0";
  $frame.style.cssText = FRAME_STYLES;
  document.body.append($frame);

  const unmount = () => {
    if (document.getElementById(FRAME)) {
      document.getElementById(FRAME).remove();
    }
  };

  return [$frame.contentWindow, unmount];
}

const POP = "FCL_POP";
let popup = null;
let previousUrl$1 = null;

function popupWindow(url, windowName, win, w, h) {
  const y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
  const x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
  return win.open(url, windowName, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${w}, height=${h}, top=${y}, left=${x}`);
}

function renderPop(src) {
  var _popup;

  if (popup == null || (_popup = popup) != null && _popup.closed) {
    popup = popupWindow(src, POP, window, 640, 770);
  } else if (previousUrl$1 !== src) {
    popup.location.replace(src);
    popup.focus();
  } else {
    popup.focus();
  }

  previousUrl$1 = src;

  const unmount = () => {
    if (popup && !popup.closed) {
      popup.close();
    }

    popup = null;
  };

  return [popup, unmount];
}

let tab$1 = null;
let previousUrl = null;
function renderTab(src) {
  var _tab;

  if (tab$1 == null || (_tab = tab$1) != null && _tab.closed) {
    tab$1 = window.open(src, "_blank");
  } else if (previousUrl !== src) {
    tab$1.location.replace(src);
    tab$1.focus();
  } else {
    tab$1.focus();
  }

  previousUrl = src;

  const unmount = () => {
    if (tab$1 && !tab$1.closed) {
      tab$1.close();
    }

    tab$1 = null;
  };

  return [tab$1, unmount];
}

const VIEWS = {
  "VIEW/IFRAME": renderFrame,
  "VIEW/POP": renderPop,
  "VIEW/TAB": renderTab
};
async function execLocal(service, opts = {}) {
  try {
    return VIEWS[service.method](serviceEndpoint(service), opts);
  } catch (error) {
    console.error("execLocal({service, opts = {}})", error, {
      service,
      opts
    });
    throw error;
  }
}

async function execHttpPost(service, signable, opts, config) {
  const resp = await fetchService(service, {
    data: _extends$2({
      fclVersion: VERSION,
      service: {
        params: service.params,
        data: service.data,
        type: service.type
      },
      config
    }, signable)
  }).then(normalizePollingResponse);

  if (resp.status === "APPROVED") {
    return resp.data;
  } else if (resp.status === "DECLINED") {
    throw new Error(`Declined: ${resp.reason || "No reason supplied."}`);
  } else if (resp.status === "REDIRECT") {
    return resp;
  } else if (resp.status === "PENDING") {
    var canContinue = true;
    const [_, unmount] = await execLocal(normalizeLocalView(resp.local));

    const close = () => {
      try {
        unmount();
        canContinue = false;
      } catch (error) {
        console.error("Frame Close Error", error);
      }
    };

    return poll(resp.updates, () => canContinue).then(serviceResponse => {
      close();
      return serviceResponse;
    }).catch(error => {
      console.error(error);
      close();
      throw error;
    });
  } else {
    console.error(`Auto Decline: Invalid Response`, {
      service,
      resp
    });
    throw new Error(`Auto Decline: Invalid Response`);
  }
}

const CLOSE_EVENT = "FCL:VIEW:CLOSE";
const READY_EVENT = "FCL:VIEW:READY";
const RESPONSE_EVENT = "FCL:VIEW:RESPONSE";

const _ = e => typeof e === "string" && e.toLowerCase();

const IGNORE = new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]);

const deprecate$1 = (was, want) => console.warn("DEPRECATION NOTICE", `Received ${was}, please use ${want} for this and future versions of FCL`);

const buildMessageHandler = ({
  close,
  send,
  onReady,
  onResponse,
  onMessage
}) => e => {
  try {
    if (typeof e.data !== "object") return;
    if (IGNORE.has(e.data.type)) return;
    if (_(e.data.type) === _(CLOSE_EVENT)) close();
    if (_(e.data.type) === _(READY_EVENT)) onReady(e, {
      send,
      close
    });
    if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {
      send,
      close
    });
    onMessage(e, {
      send,
      close
    }); // Backwards Compatible

    if (_(e.data.type) === _("FCL:FRAME:READY")) {
      deprecate$1(e.data.type, READY_EVENT);
      onReady(e, {
        send,
        close
      });
    }

    if (_(e.data.type) === _("FCL:FRAME:RESPONSE")) {
      deprecate$1(e.data.type, RESPONSE_EVENT);
      onResponse(e, {
        send,
        close
      });
    }

    if (_(e.data.type) === _("FCL:FRAME:CLOSE")) {
      deprecate$1(e.data.type, CLOSE_EVENT);
      close();
    } //


    if (_(e.data.type) === _("FCL::CHALLENGE::RESPONSE")) {
      deprecate$1(e.data.type, RESPONSE_EVENT);
      onResponse(e, {
        send,
        close
      });
    }

    if (_(e.data.type) === _("FCL::AUTHZ_READY")) {
      deprecate$1(e.data.type, READY_EVENT);
      onReady(e, {
        send,
        close
      });
    }

    if (_(e.data.type) === _("FCL::CHALLENGE::CANCEL")) {
      deprecate$1(e.data.type, CLOSE_EVENT);
      close();
    }

    if (_(e.data.type) === _("FCL::CANCEL")) {
      deprecate$1(e.data.type, CLOSE_EVENT);
      close();
    }
  } catch (error) {
    console.error("Frame Callback Error", error);
    close();
  }
};

const noop$4 = () => {};

function frame(service, opts = {}) {
  if (service == null) return {
    send: noop$4,
    close: noop$4
  };
  const onClose = opts.onClose || noop$4;
  const onMessage = opts.onMessage || noop$4;
  const onReady = opts.onReady || noop$4;
  const onResponse = opts.onResponse || noop$4;
  window.addEventListener("message", buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  }));
  const [$frame, unmount] = renderFrame(serviceEndpoint(service));
  return {
    send,
    close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      unmount();
      onClose();
    } catch (error) {
      console.error("Frame Close Error", error);
    }
  }

  function send(msg) {
    try {
      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Frame Send Error", msg, error);
    }
  }
}

function execIframeRPC(service, body, opts, config) {
  return new Promise((resolve, reject) => {
    const id = uid();
    const includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    frame(service, {
      async onReady(_, {
        send
      }) {
        try {
          send({
            type: "FCL:VIEW:READY:RESPONSE",
            fclVersion: VERSION,
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });

          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params],
              deprecated: {
                message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });
          }
        } catch (error) {
          throw error;
        }
      },

      onResponse(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onResponse error", error);
          throw error;
        }
      },

      onMessage(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onMessage error", error);
          throw error;
        }
      },

      onClose() {
        reject(`Declined: Externally Halted`);
      }

    });
  });
}

const noop$3 = () => {};

function pop(service, opts = {}) {
  if (service == null) return {
    send: noop$3,
    close: noop$3
  };
  const onClose = opts.onClose || noop$3;
  const onMessage = opts.onMessage || noop$3;
  const onReady = opts.onReady || noop$3;
  const onResponse = opts.onResponse || noop$3;
  window.addEventListener("message", buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  }));
  const [$pop, unmount] = renderPop(serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($pop && $pop.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Popup Close Error", error);
    }
  }

  function send(msg) {
    try {
      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Popup Send Error", msg, error);
    }
  }
}

function execPopRPC(service, body, opts, config) {
  return new Promise((resolve, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    pop(service, {
      async onReady(_, {
        send
      }) {
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });

          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
        } catch (error) {
          throw error;
        }
      },

      onResponse(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },

      onMessage(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },

      onClose() {
        reject(`Declined: Externally Halted`);
      }

    });
  });
}

const noop$2 = () => {};

function tab(service, opts = {}) {
  if (service == null) return {
    send: noop$2,
    close: noop$2
  };
  const onClose = opts.onClose || noop$2;
  const onMessage = opts.onMessage || noop$2;
  const onReady = opts.onReady || noop$2;
  const onResponse = opts.onResponse || noop$2;
  window.addEventListener("message", buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  }));
  const [$tab, unmount] = renderTab(serviceEndpoint(service));
  const timer = setInterval(function () {
    if ($tab && $tab.closed) {
      close();
    }
  }, 500);
  return {
    send,
    close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Tab Close Error", error);
    }
  }

  function send(msg) {
    try {
      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Tab Send Error", msg, error);
    }
  }
}

function execTabRPC(service, body, opts, config) {
  return new Promise((resolve, reject) => {
    const id = uid();
    const {
      redir,
      includeOlderJsonRpcCall
    } = opts;
    tab(service, {
      async onReady(_, {
        send
      }) {
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
          send({
            fclVersion: VERSION,
            type: "FCL:FRAME:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config,
            deprecated: {
              message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
            }
          });

          if (includeOlderJsonRpcCall) {
            send({
              jsonrpc: "2.0",
              id: id,
              method: "fcl:sign",
              params: [body, service.params]
            });
          }
        } catch (error) {
          throw error;
        }
      },

      onResponse(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },

      onMessage(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          const resp = normalizePollingResponse(e.data.result);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },

      onClose() {
        reject(`Declined: Externally Halted`);
      }

    });
  });
}

const noop$1 = () => {};

function extension(service, opts = {}) {
  if (service == null) return {
    send: noop$1,
    close: noop$1
  };
  const onClose = opts.onClose || noop$1;
  const onMessage = opts.onMessage || noop$1;
  const onReady = opts.onReady || noop$1;
  const onResponse = opts.onResponse || noop$1;
  window.addEventListener("message", buildMessageHandler({
    close,
    send,
    onReady,
    onResponse,
    onMessage
  }));
  send({
    service
  });
  return {
    send,
    close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      onClose();
    } catch (error) {
      console.error("Ext Close Error", error);
    }
  }

  function send(msg) {
    try {
      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Ext Send Error", msg, error);
    }
  }
}

function execExtRPC(service, body, opts, config) {
  return new Promise((resolve, reject) => {
    extension(service, {
      async onReady(_, {
        send
      }) {
        try {
          send({
            fclVersion: VERSION,
            type: "FCL:VIEW:READY:RESPONSE",
            body,
            service: {
              params: service.params,
              data: service.data,
              type: service.type
            },
            config
          });
        } catch (error) {
          throw error;
        }
      },

      onResponse(e, {
        close
      }) {
        try {
          if (typeof e.data !== "object") return;
          const resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;

            case "DECLINED":
              reject(`Declined: ${resp.reason || "No reason supplied"}`);
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject(`Declined: No reason supplied`);
              close();
              break;
          }
        } catch (error) {
          console.error("execExtRPC onResponse error", error);
          throw error;
        }
      },

      onClose() {
        reject(`Declined: Externally Halted`);
      }

    });
  });
}

const STRATEGIES = {
  "HTTP/RPC": execHttpPost,
  "HTTP/POST": execHttpPost,
  "IFRAME/RPC": execIframeRPC,
  "POP/RPC": execPopRPC,
  "TAB/RPC": execTabRPC,
  "EXT/RPC": execExtRPC
};
async function execService({
  service,
  msg = {},
  opts = {},
  config = {}
}) {
  var _window$location$host, _window, _window$location, _window2;

  msg.data = service.data;

  const fullConfig = _extends$2({}, config, {
    services: await configLens(/^service\./),
    app: await configLens(/^app\.detail\./),
    client: {
      fclVersion: VERSION,
      fclLibrary: "https://github.com/onflow/fcl-js",
      hostname: (_window$location$host = (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.hostname) != null ? _window$location$host : null,
      extensions: ((_window2 = window) == null ? void 0 : _window2.fcl_extensions) || []
    }
  });

  try {
    const res = await STRATEGIES[service.method](service, msg, opts, fullConfig);

    if (res.status === "REDIRECT") {
      invariant(service.type === res.data.type, "Cannot shift recursive service type in execService");
      return await execService({
        service: res.data,
        msg,
        opts,
        config: fullConfig
      });
    } else {
      return res;
    }
  } catch (error) {
    console.error("execService({service, msg = {}, opts = {}, config = {}})", error, {
      service,
      msg,
      opts,
      config
    });
    throw error;
  }
}

//    "f_type": "CompositeSignature",
//    "f_vsn": "1.0.0",
//    "addr": "_____",         // sans-prefix
//    "signature": "adfe1234", // hex
//    "keyId": 3,
// }

function normalizeCompositeSignature(resp) {
  if (resp == null) return null;

  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;

    default:
      return _extends$2({}, COMPOSITE_SIGNATURE_PRAGMA, {
        addr: sansPrefix(resp.addr || resp.address),
        signature: resp.signature || resp.sig,
        keyId: resp.keyId
      });
  }
}

const NAME$2 = "CURRENT_USER";
const UPDATED$3 = "CURRENT_USER/UPDATED";
const SNAPSHOT$1 = "SNAPSHOT";
const SET_CURRENT_USER = "SET_CURRENT_USER";
const DEL_CURRENT_USER = "DEL_CURRENT_USER";
const DATA = `{
  "f_type": "User",
  "f_vsn": "1.0.0",
  "addr":null,
  "cid":null,
  "loggedIn":null,
  "expiresAt":null,
  "services":[]
}`;

const getStoredUser = async storage => {
  const fallback = JSON.parse(DATA);
  const stored = await storage.get(NAME$2);

  if (stored != null && fallback["f_vsn"] !== stored["f_vsn"]) {
    storage.removeItem(NAME$2);
    return fallback;
  }

  return stored || fallback;
};

const HANDLERS$4 = {
  [INIT$1]: async ctx => {
    if (typeof window === "undefined") {
      console.warn(`
        %cFCL Warning
        ============================
        "currentUser" is only available in the browser.
        For more info, please see the docs: https://docs.onflow.org/fcl/
        ============================
        `, "font-weight:bold;font-family:monospace;");
    }

    ctx.merge(JSON.parse(DATA));
    const storage = await config$1.first(["fcl.storage", "fcl.storage.default"]);

    if (storage.can) {
      const user = await getStoredUser(storage);
      if (notExpired(user)) ctx.merge(user);
    }
  },
  [SUBSCRIBE$1]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED$3, _extends$2({}, ctx.all()));
  },
  [UNSUBSCRIBE$1]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
  },
  [SNAPSHOT$1]: async (ctx, letter) => {
    letter.reply(_extends$2({}, ctx.all()));
  },
  [SET_CURRENT_USER]: async (ctx, letter, data) => {
    ctx.merge(data);
    const storage = await config$1.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) storage.put(NAME$2, ctx.all());
    ctx.broadcast(UPDATED$3, _extends$2({}, ctx.all()));
  },
  [DEL_CURRENT_USER]: async (ctx, letter) => {
    ctx.merge(JSON.parse(DATA));
    const storage = await config$1.first(["fcl.storage", "fcl.storage.default"]);
    if (storage.can) storage.put(NAME$2, ctx.all());
    ctx.broadcast(UPDATED$3, _extends$2({}, ctx.all()));
  }
};

const spawnCurrentUser = () => spawn$1(HANDLERS$4, NAME$2);

function notExpired(user) {
  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();
}

async function getAccountProofData() {
  const accountProofDataResolver = await config$1.get("fcl.accountProof.resolver");
  const accountProofData = accountProofDataResolver != null ? accountProofDataResolver : await accountProofDataResolver();
  if (accountProofData == null) return;
  invariant(typeof accountProofData.appIdentifier === "string", "appIdentifier must be a string");
  invariant(/^[0-9a-f]+$/i.test(accountProofData.nonce), "Nonce must be a hex string");
  return accountProofData;
}

async function authenticate$1({
  service,
  redir = false
} = {}) {
  return new Promise(async (resolve, reject) => {
    spawnCurrentUser();
    const opts = {
      redir
    };
    const user = await snapshot();
    const discoveryService = await getDiscoveryService();
    const refreshService = serviceOfType(user.services, "authn-refresh");
    let accountProofData;

    try {
      accountProofData = await getAccountProofData();
    } catch (error) {
      console.error(`Error During Authentication: Could not resolve account proof data.
        ${error}`);
      return reject(error);
    }

    invariant(service || discoveryService.endpoint, `
        If no service passed to "authenticate," then "discovery.wallet" must be defined in config.
        See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"
      `);

    if (user.loggedIn) {
      if (refreshService) {
        try {
          const response = await execService({
            service: refreshService,
            msg: accountProofData,
            opts
          });
          send(NAME$2, SET_CURRENT_USER, await buildUser(response));
        } catch (e) {
          console.error("Error: Could not refresh authentication.", e);
        } finally {
          return resolve(await snapshot());
        }
      } else {
        return resolve(user);
      }
    }

    try {
      const response = await execService({
        service: _extends$2({}, service || discoveryService, {
          method: (discoveryService == null ? void 0 : discoveryService.method) || service.method || "IFRAME/RPC"
        }),
        msg: accountProofData,
        opts,
        config: {
          discoveryAuthnInclude: discoveryService.discoveryAuthnInclude
        }
      });
      send(NAME$2, SET_CURRENT_USER, await buildUser(response));
    } catch (e) {
      console.error("Error while authenticating", e);
    } finally {
      resolve(await snapshot());
    }
  });
}

function unauthenticate$1() {
  spawnCurrentUser();
  send(NAME$2, DEL_CURRENT_USER);
}

const normalizePreAuthzResponse = authz => ({
  f_type: "PreAuthzResponse",
  f_vsn: "1.0.0",
  proposer: (authz || {}).proposer,
  payer: (authz || {}).payer || [],
  authorization: (authz || {}).authorization || []
});

function resolvePreAuthz(authz) {
  const resp = normalizePreAuthzResponse(authz);
  const axs = [];
  if (resp.proposer != null) axs.push(["PROPOSER", resp.proposer]);

  for (let az of resp.payer || []) axs.push(["PAYER", az]);

  for (let az of resp.authorization || []) axs.push(["AUTHORIZER", az]);

  var result = axs.map(([role, az]) => ({
    tempId: [az.identity.address, az.identity.keyId].join("|"),
    addr: az.identity.address,
    keyId: az.identity.keyId,

    signingFunction(signable) {
      return execService({
        service: az,
        msg: signable
      });
    },

    role: {
      proposer: role === "PROPOSER",
      payer: role === "PAYER",
      authorizer: role === "AUTHORIZER"
    }
  }));
  return result;
}

async function authorization(account) {
  spawnCurrentUser();
  return _extends$2({}, account, {
    tempId: "CURRENT_USER",

    async resolve(account, preSignable) {
      const user = await authenticate$1({
        redir: true
      });
      const authz = serviceOfType(user.services, "authz");
      const preAuthz = serviceOfType(user.services, "pre-authz");
      if (preAuthz) return resolvePreAuthz(await execService({
        service: preAuthz,
        msg: preSignable
      }));
      if (authz) return _extends$2({}, account, {
        tempId: "CURRENT_USER",
        resolve: null,
        addr: sansPrefix(authz.identity.address),
        keyId: authz.identity.keyId,
        sequenceNum: null,
        signature: null,

        async signingFunction(signable) {
          return normalizeCompositeSignature(await execService({
            service: authz,
            msg: signable,
            opts: {
              includeOlderJsonRpcCall: true
            }
          }));
        }

      });
      throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER");
    }

  });
}

function subscribe$1(callback) {
  spawnCurrentUser();
  const EXIT = "@EXIT";
  const self = spawn$1(async ctx => {
    ctx.send(NAME$2, SUBSCRIBE$1);

    while (1) {
      const letter = await ctx.receive();

      if (letter.tag === EXIT) {
        ctx.send(NAME$2, UNSUBSCRIBE$1);
        return;
      }

      callback(letter.data);
    }
  });
  return () => send(self, EXIT);
}

function snapshot() {
  spawnCurrentUser();
  return send(NAME$2, SNAPSHOT$1, null, {
    expectReply: true,
    timeout: 0
  });
}

async function resolveArgument() {
  const {
    addr
  } = await authenticate$1();
  return arg(withPrefix(addr), t$1.Address);
}

const makeSignable = msg => {
  invariant(/^[0-9a-f]+$/i.test(msg), "Message must be a hex string");
  return {
    message: msg
  };
};

async function signUserMessage(msg) {
  spawnCurrentUser();
  const user = await authenticate$1({
    redir: true
  });
  const signingService = serviceOfType(user.services, "user-signature");
  invariant(signingService, "Current user must have authorized a signing service.");

  try {
    const response = await execService({
      service: signingService,
      msg: makeSignable(msg)
    });

    if (Array.isArray(response)) {
      return response.map(compSigs => normalizeCompositeSignature(compSigs));
    } else {
      return [normalizeCompositeSignature(response)];
    }
  } catch (error) {
    return error;
  }
}

let currentUser = () => {
  return {
    authenticate: authenticate$1,
    unauthenticate: unauthenticate$1,
    authorization,
    signUserMessage,
    subscribe: subscribe$1,
    snapshot,
    resolveArgument
  };
};

currentUser.authenticate = authenticate$1;
currentUser.unauthenticate = unauthenticate$1;
currentUser.authorization = authorization;
currentUser.signUserMessage = signUserMessage;
currentUser.subscribe = subscribe$1;
currentUser.snapshot = snapshot;
currentUser.resolveArgument = resolveArgument;

const RATE$1 = 2500;
const POLL = "POLL";

const fetchTxStatus = async transactionId => {
  return send$1([getTransactionStatus(transactionId)]).then(decode);
};

const isExpired = tx => tx.status === 5;

const isSealed = tx => tx.status >= 4;

const isExecuted = tx => tx.status >= 3;

const isFinalized = tx => tx.status >= 2;

const isPending = tx => tx.status >= 1;

const isUnknown = tx => tx.status >= 0;

const isDiff = (cur, next) => {
  return JSON.stringify(cur) !== JSON.stringify(next);
};

const HANDLERS$3 = {
  [INIT$1]: async ctx => {
    const tx = await fetchTxStatus(ctx.self());
    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE$1);
    ctx.merge(tx);
  },
  [SUBSCRIBE$1]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED$4, ctx.all());
  },
  [UNSUBSCRIBE$1]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);
  },
  [SNAPSHOT$2]: async (ctx, letter) => {
    letter.reply(ctx.all());
  },
  [POLL]: async ctx => {
    let tx;

    try {
      tx = await fetchTxStatus(ctx.self());
    } catch (e) {
      console.error(e);
      setTimeout(() => ctx.sendSelf(POLL), RATE$1);
      return;
    }

    if (!isSealed(tx)) setTimeout(() => ctx.sendSelf(POLL), RATE$1);
    if (isDiff(ctx.all(), tx)) ctx.broadcast(UPDATED$4, tx);
    ctx.merge(tx);
  }
};

const scoped = transactionId => {
  if (typeof transactionId === "object") transactionId = transactionId.transactionId;
  if (transactionId == null) throw new Error("transactionId required");
  return transactionId;
};

const spawnTransaction = transactionId => {
  return spawn$1(HANDLERS$3, scoped(transactionId));
};

function transaction(transactionId) {
  function snapshot() {
    return snapshoter(transactionId, spawnTransaction);
  }

  function subscribe(callback) {
    return subscriber$1(scoped(transactionId), spawnTransaction, callback);
  }

  function once(predicate) {
    return function innerOnce(opts = {}) {
      const suppress = opts.suppress || false;
      return new Promise((resolve, reject) => {
        const unsub = subscribe(txStatus => {
          if (txStatus.statusCode && !suppress) {
            reject(txStatus.errorMessage);
            unsub();
          } else if (predicate(txStatus)) {
            resolve(txStatus);
            unsub();
          }
        });
      });
    };
  }

  return {
    snapshot,
    subscribe,
    onceFinalized: once(isFinalized),
    onceExecuted: once(isExecuted),
    onceSealed: once(isSealed)
  };
}
transaction.isUnknown = isUnknown;
transaction.isPending = isPending;
transaction.isFinalized = isFinalized;
transaction.isExecuted = isExecuted;
transaction.isSealed = isSealed;
transaction.isExpired = isExpired;

async function mutate(opts = {}) {
  var txid;

  try {
    await prepMutation(opts); // Allow for a config to overwrite the authorization function.
    // prettier-ignore

    const authz = await sdk.config().get("fcl.authz", currentUser().authorization); // prettier-ignore

    txid = sdk.send([sdk.transaction(opts.cadence), sdk.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && sdk.limit(opts.limit), // opts.proposer > opts.authz > authz
    sdk.proposer(opts.proposer || opts.authz || authz), // opts.payer > opts.authz > authz
    sdk.payer(opts.payer || opts.authz || authz), // opts.authorizations > [opts.authz > authz]
    sdk.authorizations(opts.authorizations || [opts.authz || authz])]).then(sdk.decode);
    return txid;
  } catch (error) {
    throw error;
  }
}

async function prepMutation(opts) {
  // prettier-ignore
  invariant(isRequired(opts), "mutate(opts) -- opts is required"); // prettier-ignore

  invariant(isObject(opts), "mutate(opts) -- opts must be an object"); // prettier-ignore

  invariant(isRequired(opts.cadence), "mutate({ cadence }) -- cadence is required"); // prettier-ignore

  invariant(isString(opts.cadence), "mutate({ cadence }) -- cadence must be a string"); // prettier-ignore

  invariant(await sdk.config.get("accessNode.api"), `Required value for "accessNode.api" not defined in config. See: ${"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration"}`);
}

const onMessageFromFCL = (messageType, cb = () => {}) => {
  const buildData = data => {
    var _data$body;

    if (data.deprecated) console.warn("DEPRECATION NOTICE", data.deprecated.message);
    data == null ? true : (_data$body = data.body) == null ? true : delete _data$body.interaction;
    return data;
  };

  const internal = e => {
    const {
      data
    } = e;
    if (typeof data !== "object") return;
    if (typeof data == null) return;
    if (data.type !== messageType) return;
    cb(buildData(data));
  };

  window.addEventListener("message", internal);
  return () => window.removeEventListener("message", internal);
};

const sendMsgToFCL = (type, msg = {}) => {
  if (window.location !== window.parent.location) {
    window.parent.postMessage(_extends$2({}, msg, {
      type
    }), "*");
  } else {
    window.opener.postMessage(_extends$2({}, msg, {
      type
    }), "*");
  }
};
const ready = (cb, msg = {}) => {
  onMessageFromFCL("FCL:VIEW:READY:RESPONSE", cb);
  sendMsgToFCL("FCL:VIEW:READY");
};
const close = () => {
  sendMsgToFCL("FCL:VIEW:CLOSE");
};
const approve = data => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "APPROVED",
    reason: null,
    data: data
  });
};
const decline = reason => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "DECLINED",
    reason: reason,
    data: null
  });
};
const redirect = data => {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "REDIRECT",
    reason: null,
    data: data
  });
};

function CompositeSignature(addr, keyId, signature) {
  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;
  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;
  this.addr = withPrefix(addr);
  this.keyId = Number(keyId);
  this.signature = signature;
}

const rightPaddedHexBuffer = (value, pad) => Buffer.from(value.padEnd(pad * 2, "0"), "hex");

const leftPaddedHexBuffer = (value, pad) => Buffer.from(value.padStart(pad * 2, "0"), "hex");

const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);

const nonceBuffer = nonce => Buffer.from(nonce, "hex");

const encodeAccountProof = ({
  address,
  nonce,
  appIdentifier
}, includeDomainTag = true) => {
  invariant(address, "Encode Message For Provable Authn Error: address must be defined");
  invariant(nonce, "Encode Message For Provable Authn Error: nonce must be defined");
  invariant(appIdentifier, "Encode Message For Provable Authn Error: appIdentifier must be defined");
  invariant(nonce.length >= 64, "Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");
  const ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"), 32);

  if (includeDomainTag) {
    return Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, encode([appIdentifier, addressBuffer(sansPrefix(address)), nonceBuffer(nonce)])]).toString("hex");
  }

  return encode([appIdentifier, addressBuffer(sansPrefix(address)), nonceBuffer(nonce)]).toString("hex");
};

function injectExtService(service) {
  if (service.type === "authn" && service.endpoint != null) {
    if (!Array.isArray(window.fcl_extensions)) {
      window.fcl_extensions = [];
    }

    window.fcl_extensions.push(service);
  } else {
    console.warn("Authn service is required");
  }
}

var index$1 = {
  __proto__: null,
  sendMsgToFCL: sendMsgToFCL,
  ready: ready,
  close: close,
  approve: approve,
  decline: decline,
  redirect: redirect,
  onMessageFromFCL: onMessageFromFCL,
  encodeMessageFromSignable: encodeMessageFromSignable,
  CompositeSignature: CompositeSignature,
  encodeAccountProof: encodeAccountProof,
  injectExtService: injectExtService
};

const ACCOUNT_PROOF = "ACCOUNT_PROOF";
const USER_SIGNATURE = "USER_SIGNATURE";
const validateArgs = args => {
  if (args.appIdentifier) {
    const {
      appIdentifier,
      address,
      nonce,
      signatures
    } = args;
    invariant(isString(appIdentifier), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string");
    invariant(isString(address) && sansPrefix(address).length === 16, "verifyAccountProof({ address }) -- address must be a valid address");
    invariant(/^[0-9a-f]+$/i.test(nonce), "nonce must be a hex string");
    invariant(Array.isArray(signatures) && signatures.every((sig, i, arr) => sig.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    invariant(signatures.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  } else {
    const {
      message,
      compSigs
    } = args;
    invariant(/^[0-9a-f]+$/i.test(message), "Signed message must be a hex string");
    invariant(Array.isArray(compSigs) && compSigs.every((sig, i, arr) => sig.f_type === "CompositeSignature"), "Must include an Array of CompositeSignatures to verify");
    invariant(compSigs.map(cs => cs.addr).every((addr, i, arr) => addr === arr[0]), "User signatures to be verified must be from a single account address");
    return true;
  }
};

const getVerifySignaturesScript = async (sig, opts) => {
  const verifyFunction = sig === "ACCOUNT_PROOF" ? "verifyAccountProofSignatures" : "verifyUserSignatures";
  const network = await config$1.first(["env", "flow.network"]);
  let fclCryptoContract;
  invariant(opts.fclCryptoContract || network === "testnet" || network === "mainnet", "${verifyFunction}({ fclCryptoContract }) -- config.flow.network must be specified (testnet || mainnet) or contract address provided via opts.fclCryptoContract");

  if (opts.fclCryptoContract) {
    fclCryptoContract = opts.fclCryptoContract;
  } else {
    fclCryptoContract = network === "testnet" ? "0x74daa6f9c7ef24b1" : "0xb4b82a1c9d21d284";
  }

  return `
      import FCLCrypto from ${fclCryptoContract}

      pub fun main(
          address: Address, 
          message: String, 
          keyIndices: [Int], 
          signatures: [String]
      ): Bool {
        return FCLCrypto.${verifyFunction}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)
      }
    `;
};
/**
 * Verify a valid account proof signature or signatures for an account on Flow.
 *
 * @param {string} appIdentifier - A message string in hexadecimal format
 * @param {Object} accountProofData - An object consisting of address, nonce, and signatures
 * @param {string} accountProofData.address - A Flow account address
 * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)
 * @param {Object[]} accountProofData.signatures - An array of composite signatures to verify
 * @param {Object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed
 * @return {bool}
 *
 * @example
 *
 *  const accountProofData = {
 *   address: "0x123",
 *   nonce: "F0123"
 *   signatures: [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *  }
 *
 *  const isValid = await fcl.AppUtils.verifyAccountProof(
 *    "AwesomeAppId",
 *    accountProofData,
 *    {fclCryptoContract}
 *  )
 */


async function verifyAccountProof(appIdentifier, {
  address,
  nonce,
  signatures
}, opts = {}) {
  validateArgs({
    appIdentifier,
    address,
    nonce,
    signatures
  });
  const message = encodeAccountProof({
    address,
    nonce,
    appIdentifier
  }, false);
  let signaturesArr = [];
  let keyIndices = [];

  for (const el of signatures) {
    signaturesArr.push(el.signature);
    keyIndices.push(el.keyId);
  }

  return query({
    cadence: await getVerifySignaturesScript(ACCOUNT_PROOF, opts),
    args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array([t.Int])), arg(signaturesArr, t.Array([t.String]))]
  });
}
/**
 * Verify a valid signature/s for an account on Flow.
 *
 * @param {string} msg - A message string in hexadecimal format
 * @param {Array} compSigs - An array of Composite Signatures
 * @param {string} compSigs[].addr - The account address
 * @param {number} compSigs[].keyId - The account keyId
 * @param {string} compSigs[].signature - The signature to verify
 * @param {Object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed
 * @return {bool}
 *
 * @example
 *
 *  const isValid = await fcl.AppUtils.verifyUserSignatures(
 *    Buffer.from('FOO').toString("hex"),
 *    [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *    {fclCryptoContract}
 *  )
 */

async function verifyUserSignatures$1(message, compSigs, opts = {}) {
  validateArgs({
    message,
    compSigs
  });
  const address = compSigs[0].addr;
  let signaturesArr = [];
  let keyIndices = [];

  for (const el of compSigs) {
    signaturesArr.push(el.signature);
    keyIndices.push(el.keyId);
  }

  return query({
    cadence: await getVerifySignaturesScript(USER_SIGNATURE, opts),
    args: (arg, t) => [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array([t.Int])), arg(signaturesArr, t.Array([t.String]))]
  });
}

var index = {
  __proto__: null,
  verifyAccountProof: verifyAccountProof,
  verifyUserSignatures: verifyUserSignatures$1
};

var promise;
var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask : function (cb) {
  return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
    return setTimeout(function () {
      throw err;
    }, 0);
  });
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var mailbox = function mailbox() {
  var queue = [];
  var next;
  return {
    deliver: function deliver(msg) {
      try {
        queue.push(msg);

        if (next) {
          next(queue.shift());
          next = undefined;
        }

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    },
    receive: function receive() {
      return new Promise(function innerReceive(resolve) {
        var msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }

  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }

  return finalizer(false, result);
}

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}

function _for(test, update, body) {
  var stage;

  for (;;) {
    var shouldContinue = test();

    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }

    if (!shouldContinue) {
      return result;
    }

    if (shouldContinue.then) {
      stage = 0;
      break;
    }

    var result = body();

    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }

    if (update) {
      var updateValue = update();

      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }

  var pact = new _Pact();

  var reject = _settle.bind(null, pact, 2);

  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;

  function _resumeAfterBody(value) {
    result = value;

    do {
      if (update) {
        updateValue = update();

        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }

      shouldContinue = test();

      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);

        return;
      }

      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }

      result = body();

      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);

    result.then(_resumeAfterBody).then(void 0, reject);
  }

  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();

      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }

  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}

var INIT = "INIT";
var SUBSCRIBE = "SUBSCRIBE";
var UNSUBSCRIBE = "UNSUBSCRIBE";
var EXIT = "EXIT";
var TERMINATE = "TERMINATE";
var root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window;
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var pid = 0;
var DEFAULT_TIMEOUT = 5000;

var _send = function send(addr, tag, data, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return new Promise(function (reply, reject) {
    var expectReply = opts.expectReply || false;
    var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

    if (expectReply && timeout) {
      setTimeout(function () {
        return reject(new Error("Timeout: " + timeout + "ms passed without a response."));
      }, timeout);
    }

    var payload = {
      to: addr,
      from: opts.from,
      tag: tag,
      data: data,
      timeout: timeout,
      reply: reply,
      reject: reject
    };

    try {
      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
      if (!expectReply) reply(true);
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
    }
  });
};

var kill = function kill(addr) {
  delete root.FCL_REGISTRY[addr];
};

var fromHandlers = function fromHandlers(handlers) {
  if (handlers === void 0) {
    handlers = {};
  }

  return function (ctx) {
    try {
      var _temp12 = function _temp12() {
        var _loopInterrupt;

        var _temp6 = _for(function () {
          return !_loopInterrupt && 1;
        }, void 0, function () {
          return Promise.resolve(ctx.receive()).then(function (letter) {
            var _temp5 = _finallyRethrows(function () {
              return _catch(function () {
                function _temp4() {
                  return Promise.resolve(handlers[letter.tag](ctx, letter, letter.data || {})).then(function () {});
                }

                var _temp3 = function () {
                  if (letter.tag === EXIT) {
                    var _temp10 = function _temp10() {
                      _loopInterrupt = 1;
                    };

                    var _temp11 = function () {
                      if (typeof handlers[TERMINATE] === "function") {
                        return Promise.resolve(handlers[TERMINATE](ctx, letter, letter.data || {})).then(function () {});
                      }
                    }();

                    return _temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11);
                  }
                }();

                return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
              }, function (error) {
                console.error(ctx.self() + " Error", letter, error);
              });
            }, function (_wasThrown, _result) {
              return;
              if (_wasThrown) throw _result;
              return _result;
            });

            if (_temp5 && _temp5.then) return _temp5.then(function () {});
          });
        });

        var _temp7 = function () {
          if (_temp6 && _temp6.then) return _temp6.then(function () {});
        }();

        if (_temp7 && _temp7.then) return _temp7.then(function () {});
      };

      var _temp13 = function () {
        if (typeof handlers[INIT] === "function") return Promise.resolve(handlers[INIT](ctx)).then(function () {});
      }();

      return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp12) : _temp12(_temp13));
    } catch (e) {
      return Promise.reject(e);
    }
  };
};

var spawn = function spawn(fn, addr) {
  if (addr === void 0) {
    addr = null;
  }

  if (addr == null) addr = ++pid;
  if (root.FCL_REGISTRY[addr] != null) return addr;
  root.FCL_REGISTRY[addr] = {
    addr: addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {}
  };
  var ctx = {
    self: function self() {
      return addr;
    },
    receive: function receive() {
      return root.FCL_REGISTRY[addr].mailbox.receive();
    },
    send: function send(to, tag, data, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.from = addr;
      return _send(to, tag, data, opts);
    },
    sendSelf: function sendSelf(tag, data, opts) {
      if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
    },
    broadcast: function broadcast(tag, data, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.from = addr;

      for (var _iterator = _createForOfIteratorHelperLoose(root.FCL_REGISTRY[addr].subs), _step; !(_step = _iterator()).done;) {
        var to = _step.value;

        _send(to, tag, data, opts);
      }
    },
    subscribe: function subscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
    },
    unsubscribe: function unsubscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
    },
    subscriberCount: function subscriberCount() {
      return root.FCL_REGISTRY[addr].subs.size;
    },
    hasSubs: function hasSubs() {
      return !!root.FCL_REGISTRY[addr].subs.size;
    },
    put: function put(key, value) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: function get(key, fallback) {
      var value = root.FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    "delete": function _delete(key) {
      delete root.FCL_REGISTRY[addr].kvs[key];
    },
    update: function update(key, fn) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
    },
    keys: function keys() {
      return Object.keys(root.FCL_REGISTRY[addr].kvs);
    },
    all: function all() {
      return root.FCL_REGISTRY[addr].kvs;
    },
    where: function where(pattern) {
      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
        var _extends2;

        return pattern.test(key) ? _extends({}, acc, (_extends2 = {}, _extends2[key] = root.FCL_REGISTRY[addr].kvs[key], _extends2)) : acc;
      }, {});
    },
    merge: function merge(data) {
      if (data === void 0) {
        data = {};
      }

      Object.keys(data).forEach(function (key) {
        return root.FCL_REGISTRY[addr].kvs[key] = data[key];
      });
    }
  };
  if (typeof fn === "object") fn = fromHandlers(fn);
  queueMicrotask_1(function () {
    try {
      return Promise.resolve(fn(ctx)).then(function () {
        kill(addr);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return addr;
};

function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  var EXIT = "@EXIT";
  var self = spawn(function (ctx) {
    try {
      var _exit2;

      ctx.send(address, SUBSCRIBE);
      return Promise.resolve(_for(function () {
        return !_exit2 && 1;
      }, void 0, function () {
        return Promise.resolve(ctx.receive()).then(function (letter) {
          if (letter.tag === EXIT) {
            ctx.send(address, UNSUBSCRIBE);
            _exit2 = 1;
            return;
          }

          callback(letter.data);
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return function () {
    return _send(self, EXIT);
  };
}

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var _HANDLERS;

var first = function first(wants, fallback) {
  if (wants === void 0) {
    wants = [];
  }

  try {
    if (!wants.length) return Promise.resolve(fallback);

    var _wants = wants,
        head = _wants[0],
        rest = _wants.slice(1);

    return Promise.resolve(get(head)).then(function (ret) {
      return ret == null ? first(rest, fallback) : ret;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var NAME$1 = "config";
var PUT = "PUT_CONFIG";
var GET = "GET_CONFIG";
var GET_ALL = "GET_ALL_CONFIG";
var UPDATE = "UPDATE_CONFIG";
var DELETE = "DELETE_CONFIG";
var CLEAR = "CLEAR_CONFIG";
var WHERE = "WHERE_CONFIG";
var UPDATED$2 = "CONFIG/UPDATED";

var identity = function identity(v) {
  return v;
};

var HANDLERS$2 = (_HANDLERS = {}, _HANDLERS[PUT] = function (ctx, _letter, _ref) {
  var key = _ref.key,
      value = _ref.value;
  if (key == null) throw new Error("Missing 'key' for config/put.");
  ctx.put(key, value);
  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS[GET] = function (ctx, letter, _ref2) {
  var key = _ref2.key,
      fallback = _ref2.fallback;
  if (key == null) throw new Error("Missing 'key' for config/get");
  letter.reply(ctx.get(key, fallback));
}, _HANDLERS[GET_ALL] = function (ctx, letter) {
  letter.reply(_extends$1({}, ctx.all()));
}, _HANDLERS[UPDATE] = function (ctx, letter, _ref3) {
  var key = _ref3.key,
      fn = _ref3.fn;
  if (key == null) throw new Error("Missing 'key' for config/update");
  ctx.update(key, fn || identity);
  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS[DELETE] = function (ctx, letter, _ref4) {
  var key = _ref4.key;
  if (key == null) throw new Error("Missing 'key' for config/delete");
  ctx["delete"](key);
  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS[CLEAR] = function (ctx, letter) {
  var keys = Object.keys(ctx.all());

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    ctx["delete"](key);
  }

  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS[WHERE] = function (ctx, letter, _ref5) {
  var pattern = _ref5.pattern;
  if (pattern == null) throw new Error("Missing 'pattern' for config/where");
  letter.reply(ctx.where(pattern));
}, _HANDLERS[SUBSCRIBE] = function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS[UNSUBSCRIBE] = function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}, _HANDLERS);
spawn(HANDLERS$2, NAME$1);

function put(key, value) {
  _send(NAME$1, PUT, {
    key: key,
    value: value
  });

  return config();
}

function get(key, fallback) {
  return _send(NAME$1, GET, {
    key: key,
    fallback: fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}

function all() {
  return _send(NAME$1, GET_ALL, null, {
    expectReply: true,
    timeout: 10
  });
}

function update(key, fn) {
  if (fn === void 0) {
    fn = identity;
  }

  _send(NAME$1, UPDATE, {
    key: key,
    fn: fn
  });

  return config();
}

function _delete(key) {
  _send(NAME$1, DELETE, {
    key: key
  });

  return config();
}

function where(pattern) {
  return _send(NAME$1, WHERE, {
    pattern: pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}

function subscribe(callback) {
  return subscriber(NAME$1, function () {
    return spawn(HANDLERS$2, NAME$1);
  }, callback);
}

function clearConfig() {
  return _send(NAME$1, CLEAR);
}

function config(values) {
  if (values != null && typeof values === "object") {
    Object.keys(values).map(function (d) {
      return put(d, values[d]);
    });
  }

  return {
    put: put,
    get: get,
    all: all,
    first: first,
    update: update,
    "delete": _delete,
    where: where,
    subscribe: subscribe,
    overload: overload
  };
}

config.put = put;
config.get = get;
config.all = all;
config.first = first;
config.update = update;
config["delete"] = _delete;
config.where = where;
config.subscribe = subscribe;
config.overload = overload;

var noop = function noop(v) {
  return v;
};

function overload(opts, callback) {
  if (opts === void 0) {
    opts = {};
  }

  if (callback === void 0) {
    callback = noop;
  }

  return new Promise(function (resolve, reject) {
    try {
      return Promise.resolve(all()).then(function (oldConfig) {
        var _temp = _catch$1(function () {
          config(opts);
          var _callback = callback;
          return Promise.resolve(all()).then(function (_all) {
            return Promise.resolve(_callback(_all)).then(function (result) {
              return Promise.resolve(clearConfig()).then(function () {
                return Promise.resolve(config(oldConfig)).then(function () {
                  resolve(result);
                });
              });
            });
          });
        }, function (error) {
          return Promise.resolve(clearConfig()).then(function () {
            return Promise.resolve(config(oldConfig)).then(function () {
              reject(error);
            });
          });
        });

        if (_temp && _temp.then) return _temp.then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  });
}

var LEVELS = Object.freeze({
  "debug": 5,
  "info": 4,
  "log": 3,
  "warn": 2,
  "error": 1
});

var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
  var title = _ref.title,
      message = _ref.message;
  return ["\n    %c" + title + "\n    ============================\n    " + message + "\n    ============================\n    ", "font-weight:bold;font-family:monospace;"];
};

var log = function log(_ref2) {
  var title = _ref2.title,
      message = _ref2.message,
      level = _ref2.level,
      _ref2$always = _ref2.always,
      always = _ref2$always === void 0 ? false : _ref2$always;

  try {
    return Promise.resolve(config.get("logger.level", 0)).then(function (configLoggerLevel) {
      var _console, _console2, _console3, _console4, _console5;

      if (!always && configLoggerLevel < level) return;
      var loggerMessageArgs = buildLoggerMessageArgs({
        title: title,
        message: message
      });

      switch (level) {
        case LEVELS.debug:
          (_console = console).debug.apply(_console, loggerMessageArgs);

          break;

        case LEVELS.info:
          (_console2 = console).info.apply(_console2, loggerMessageArgs);

          break;

        case LEVELS.warn:
          (_console3 = console).warn.apply(_console3, loggerMessageArgs);

          break;

        case LEVELS.error:
          (_console4 = console).error.apply(_console4, loggerMessageArgs);

          break;

        default:
          (_console5 = console).log.apply(_console5, loggerMessageArgs);

      }
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

const deprecate = async ({
  title,
  message,
  level,
  always
}) => {
  await log({
    title,
    message,
    level,
    always
  });
};

/**
 * Verify a valid signature/s for an account on Flow.
 *
 * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead
 *
 */

async function verifyUserSignatures(message, compSigs) {
  deprecate({
    title: "FCL Deprecation Notice",
    message: `
    fcl.verifyUserSignatures() is deprecated and will be removed in a future release
    Please use fcl.AppUtils.verifyUserSignatures()`,
    level: 2,
    always: true
  });
  return verifyUserSignatures$1(message, compSigs);
}

const serialize = async (args = [], opts = {}) => {
  const resolveFunction = await config$2.first(["sdk.resolve"], opts.resolve || resolve);
  if (Array.isArray(args)) args = await pipe(interaction(), args);
  return JSON.stringify(createSignableVoucher(await resolveFunction(args)), null, 2);
};

const RATE = 10000;
const UPDATED$1 = "UPDATED";
const TICK = "TICK";
const HIGH_WATER_MARK = "hwm";

const scheduleTick = async ctx => {
  return setTimeout(() => ctx.sendSelf(TICK), await config$2().get("fcl.eventPollRate", RATE));
};

const HANDLERS$1 = {
  [TICK]: async ctx => {
    if (!ctx.hasSubs()) return;
    let hwm = ctx.get(HIGH_WATER_MARK);

    if (hwm == null) {
      ctx.put(HIGH_WATER_MARK, await block());
      ctx.put(TICK, await scheduleTick(ctx));
    } else {
      let next = await block();
      ctx.put(HIGH_WATER_MARK, next);
      const data = await send$1([getEventsAtBlockHeightRange(ctx.self(), hwm.height, next.height - 1)]).then(decode);

      for (let d of data) ctx.broadcast(UPDATED$1, d.data);

      ctx.put(TICK, await scheduleTick(ctx));
    }
  },
  [SUBSCRIBE$1]: async (ctx, letter) => {
    if (!ctx.hasSubs()) {
      ctx.put(TICK, await scheduleTick(ctx));
    }

    ctx.subscribe(letter.from);
  },
  [UNSUBSCRIBE$1]: (ctx, letter) => {
    ctx.unsubscribe(letter.from);

    if (!ctx.hasSubs()) {
      clearTimeout(ctx.get(TICK));
      ctx.delete(TICK);
      ctx.delete(HIGH_WATER_MARK);
    }
  }
};

const spawnEvents = key => spawn$1(HANDLERS$1, key);

function events(key) {
  return {
    subscribe: callback => subscriber$1(key, spawnEvents, callback)
  };
}

const asyncPipe = (...fns) => input => fns.reduce((chain, fn) => chain.then(fn), Promise.resolve(input));

async function addServices(services = []) {
  const endpoint = await config$1.get("discovery.authn.endpoint");
  invariant(Boolean(endpoint), `"discovery.authn.endpoint" in config must be defined.`);
  const include = await config$1.get("discovery.authn.include", []);
  const url = new URL(endpoint);
  return fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      fclVersion: VERSION,
      include
    })
  }).then(d => d.json()).then(json => [...services, ...json]);
}

function addExtensions(services = []) {
  const extensions = window.fcl_extensions || [];
  return [...extensions, ...services];
}

function filterServicesByType(services = [], type) {
  return services.filter(service => service.type === type);
}

const getServices = ({
  type
}) => asyncPipe(addServices, addExtensions, s => filterServicesByType(s, type))([]);

const NAME = "authn";
const RESULTS = "results";
const SNAPSHOT = "SNAPSHOT";
const UPDATED = "UPDATED";

const warn = (fact, msg) => {
  if (fact) {
    console.warn(`
      %cFCL Warning
      ============================
      ${msg}
      For more info, please see the docs: https://docs.onflow.org/fcl/
      ============================
      `, "font-weight:bold;font-family:monospace;");
  }
};

const HANDLERS = {
  [INIT$1]: async ctx => {
    warn(typeof window === "undefined", '"fcl.discovery" is only available in the browser.');
    const services = await getServices({
      type: NAME
    });
    ctx.put(RESULTS, services);
  },
  [SUBSCRIBE$1]: (ctx, letter) => {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED, _extends$2({}, ctx.all()));
  },
  [UNSUBSCRIBE$1]: (ctx, letter) => ctx.unsubscribe(letter.from),
  [SNAPSHOT]: async (ctx, letter) => letter.reply(_extends$2({}, ctx.all()))
};

const spawnProviders = () => spawn$1(HANDLERS, NAME);

const authn = {
  subscribe: cb => subscriber$1(NAME, spawnProviders, cb),
  snapshot: () => snapshoter(NAME, spawnProviders)
};

const discovery = {
  authn
};

const authenticate = (opts = {}) => currentUser().authenticate(opts);
const unauthenticate = () => currentUser().unauthenticate();
const reauthenticate = (opts = {}) => {
  currentUser().unauthenticate();
  return currentUser().authenticate(opts);
};
const signUp = (opts = {}) => currentUser().authenticate(opts);
const logIn = (opts = {}) => currentUser().authenticate(opts);
const authz = currentUser().authorization;
const t = t$1;

export { index as AppUtils, VERSION, index$1 as WalletUtils, authenticate, authz, currentUser, discovery, events, logIn, mutate, query, reauthenticate, serialize, signUp, t, transaction as tx, unauthenticate, verifyUserSignatures };
//# sourceMappingURL=fcl.modern.js.map
