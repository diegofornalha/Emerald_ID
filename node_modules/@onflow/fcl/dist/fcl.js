var config$1 = require('@onflow/config');
var utilInvariant = require('@onflow/util-invariant');
var sdk = require('@onflow/sdk');
var t$1 = require('@onflow/types');
var utilActor = require('@onflow/util-actor');
var utilAddress = require('@onflow/util-address');
var rlp = require('@onflow/rlp');
var utilUid = require('@onflow/util-uid');
var utilTemplate = require('@onflow/util-template');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return n;
}

var sdk__namespace = /*#__PURE__*/_interopNamespace(sdk);
var t__namespace = /*#__PURE__*/_interopNamespace(t$1);
var rlp__namespace = /*#__PURE__*/_interopNamespace(rlp);

var VERSION = "1.0.1" ;

var getDiscoveryService = function getDiscoveryService() {
  try {
    return Promise.resolve(config$1.config.first(["discovery.wallet", "challenge.handshake"])).then(function (discoveryWallet) {
      return Promise.resolve(config$1.config.get("discovery.authn.include", [])).then(function (discoveryAuthnInclude) {
        return Promise.resolve(config$1.config.first(["discovery.wallet.method", "discovery.wallet.method.default"])).then(function (discoveryWalletMethod) {
          return {
            type: "authn",
            endpoint: discoveryWallet,
            method: discoveryWalletMethod,
            discoveryAuthnInclude: discoveryAuthnInclude
          };
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var configLens = function configLens(regex) {
  try {
    return Promise.resolve(config$1.config().where(regex)).then(function (_config$where) {
      return Object.fromEntries(Object.entries(_config$where).map(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return [key.replace(regex, ""), value];
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var isServerSide = function isServerSide() {
  return typeof window === "undefined";
};

var SESSION_STORAGE = {
  can: !isServerSide(),
  get: function (key) {
    try {
      return Promise.resolve(JSON.parse(sessionStorage.getItem(key)));
    } catch (e) {
      return Promise.reject(e);
    }
  },
  put: function (key, value) {
    try {
      return Promise.resolve(sessionStorage.setItem(key, JSON.stringify(value)));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
var STORAGE_DEFAULT = SESSION_STORAGE;
var DISCOVERY_METHOD = "IFRAME/RPC";

config$1.config({
  "discovery.wallet.method.default": DISCOVERY_METHOD,
  "fcl.storage.default": STORAGE_DEFAULT
});

var is = function is(type) {
  return function (d) {
    return typeof d === type;
  };
};

var isRequired = function isRequired(d) {
  return d != null;
};
var isObject = is("object");
var isString = is("string");
var isFunc = is("function");
var isNumber = is("number");

function normalizeArgs(ax) {
  if (isFunc(ax)) return ax(sdk__namespace.arg, t__namespace);
  return [];
}

/** Query the Flow Blockchain
 *
 *  @arg {Object} opts         - Query Options and configuration
 *  @arg {string} opts.cadence - Cadence Script used to query Flow
 *  @arg {ArgsFn} opts.args    - Arguments passed to cadence script
 *  @arg {number} opts.limit   - Compute Limit for Query
 *  @returns {Promise<Response>}
 *
 *  Where:
 *    @callback ArgsFn
 *    @arg {ArgFn}  arg - Argument function to define a single argument
 *    @arg {Object} t   - Cadence Types object used to define the type
 *    @returns {args[]}
 *
 *    @callback ArgFn
 *    @arg {Any}  value - the value of the argument
 *    @arg {Type} type  - the cadence type of the value
 *    @returns {arg}
 *
 *  Example:
 *    const cadence = `
 *      cadence: `
 *        pub fun main(a: Int, b: Int, c: Address): Int {
 *          log(c)
 *          return a + b
 *        }
 *    `.trim()
 *
 *    const args = (arg, t) => [
 *      arg(5, t.Int),
 *      arg(7, t.Int),
 *      arg("0xb2db43ad6bc345fec9", t.Address),
 *    ]
 *
 *    await query({ cadence, args })
 */

var preQuery = function preQuery(opts) {
  try {
    utilInvariant.invariant(isRequired(opts.cadence), "query({ cadence }) -- cadence is required");
    utilInvariant.invariant(isString(opts.cadence), "query({ cadence }) -- cadence must be a string");
    return Promise.resolve(sdk__namespace.config.get("accessNode.api")).then(function (_sdk$config$get) {
      utilInvariant.invariant(_sdk$config$get, "Required value for \"accessNode.api\" not defined in config. See: " + "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration");
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var query = function query(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return Promise.resolve(preQuery(opts)).then(function () {
    // prettier-ignore
    return sdk__namespace.send([sdk__namespace.script(opts.cadence), sdk__namespace.args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === "number" && sdk__namespace.limit(opts.limit)]).then(sdk__namespace.decode);
  });
};

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}

function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var fetchServices = function fetchServices(servicesURL, code) {
  try {
    if (servicesURL == null || code == null) return Promise.resolve([]);
    var url = new URL(servicesURL);
    url.searchParams.append("code", code);
    return Promise.resolve(fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    }).then(function (d) {
      return d.json();
    })).then(function (resp) {
      if (Array.isArray(resp)) return resp; // Backwards compatibility for First-Gen Wallet Providers

      var services = []; // Convert authorizations into authz services

      if (Array.isArray(resp.authorizations)) {
        for (var _iterator = _createForOfIteratorHelperLoose$1(resp.authorizations), _step; !(_step = _iterator()).done;) {
          var service = _step.value;
          services.push(_extends$2({
            type: "authz",
            keyId: resp.keyId
          }, service));
        }
      } // Convert Provider info into an authn service


      if (resp.provider != null) {
        services.push(_extends$2({
          type: "authn",
          id: "wallet-provider#authn"
        }, resp.provider));
      }

      return services;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function mergeServices(sx1, sx2) {
  if (sx1 === void 0) {
    sx1 = [];
  }

  if (sx2 === void 0) {
    sx2 = [];
  }

  // TODO: Make this smarter
  return [].concat(sx1, sx2);
}

var SERVICE_PRAGMA = {
  f_type: "Service",
  f_vsn: "1.0.0"
};
var IDENTITY_PRAGMA = {
  f_type: "Identity",
  f_vsn: "1.0.0"
};
var USER_PRAGMA = {
  f_type: "USER",
  f_vsn: "1.0.0"
};
var POLLING_RESPONSE_PRAGMA = {
  f_type: "PollingResponse",
  f_vsn: "1.0.0"
};
var COMPOSITE_SIGNATURE_PRAGMA = {
  f_type: "CompositeSignature",
  f_vsn: "1.0.0"
};

//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "authn",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "identity": {
//     "address": "0x____"
//   },
//   "provider": {
//     "address": "0x____",
//     "name": "Best Wallet",
//     "description": "The Best Wallet"
//     "icon": "https://",
//   }
// }

function normalizeAuthn(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: service.type,
        uid: service.id,
        endpoint: service.authn,
        id: service.pid,
        provider: {
          address: utilAddress.withPrefix(service.addr),
          name: service.name,
          icon: service.icon
        }
      });
  }
}

//   "f_type": "service",
//   "f_vsn": "1.0.0",
//   "type": "authz",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "identity": {
//      "address": "0x______",
//      "keyId": 0,
//   },
//   "data": {}, // included in body of authz request
//   "params": {}, // included as query params on endpoint url
// }

function normalizeAuthz(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: service.type,
        uid: service.id,
        endpoint: service.endpoint,
        method: service.method,
        identity: _extends$2({}, IDENTITY_PRAGMA, {
          address: utilAddress.withPrefix(service.addr),
          keyId: service.keyId
        }),
        params: service.params,
        data: service.data
      });
  }
}

//   "f_type": "service",
//   "f_vsn": "1.0.0",
//   "type": "pre-authz",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "identity": {
//      "address": "0x______",
//      "keyId": 0,
//   },
//   "data": {}, // included in body of pre-authz request
//   "params": {}, // included as query params on endpoint url
// }

function normalizePreAuthz(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: service.type,
        uid: service.id,
        endpoint: service.endpoint,
        method: service.method,
        identity: _extends$2({}, IDENTITY_PRAGMA, {
          address: utilAddress.withPrefix(service.addr),
          keyId: service.keyId
        }),
        params: service.params,
        data: service.data
      });
  }
}

//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    "type": "frame",
//    "endpoint": "https://rawr",
//    "data": {},   // Sent to frame when ready
//    "params": {}, // include in query params on frame
// }

function normalizeFrame(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({
        old: service
      }, SERVICE_PRAGMA, {
        type: "frame",
        endpoint: service.endpoint,
        params: service.params || {},
        data: service.data || {}
      });
  }
}

//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    "type": "back-channel-rpc",
//    "endpoint": "https://rawr",
//    "method": "HTTP/GET", // HTTP/GET | HTTP/POST
//    "data": {},           // included in body of rpc
//    "params": {},         // included as query params on endpoint url
// }

function normalizeBackChannelRpc(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: "back-channel-rpc",
        endpoint: service.endpoint,
        method: service.method,
        params: service.params || {},
        data: service.data || {}
      });
  }
}

//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "open-id",
//   "uid": "uniqueDedupeKey",
//   "method: "data",
//   "data": {
//      "profile": {
//        "name": "Bob",
//        "family_name": "Builder",
//        "given_name": "Robert",
//        "middle_name": "the",
//        "nickname": "Bob the Builder",
//        "perferred_username": "bob",
//        "profile": "https://www.bobthebuilder.com/",
//        "picture": "https://avatars.onflow.org/avatar/bob",
//        "gender": "...",
//        "birthday": "2001-01-18",
//        "zoneinfo": "America/Vancouver",
//        "locale": "en-us",
//        "updated_at": "1614970797388"
//      },
//      "email": {
//        "email": "bob@bob.bob",
//        "email_verified": true
//      },
//      "address": {
//        "address": "One Apple Park Way, Cupertino, CA 95014, USA"
//      },
//      "phone": {
//        "phone_number": "+1 (xxx) yyy-zzzz",
//        "phone_number_verified": true
//      },
//      "social": {
//        "twitter": "@_qvvg",
//        "twitter_verified": true
//      },
//   }
// }

function normalizeOpenId(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      return null;
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "user-signature",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "IFRAME/RPC", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "data": {}, // included in body of user-signature request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeUserSignature(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      throw new Error("Invalid user-signature service");
  }
}

//    "f_type": "Service",
//    "f_vsn": "1.0.0",
//    type: "local-view",
//    method: "VIEW/IFRAME",
//    endpoint: "https://woot.org/authz/local",
//    data: {},
//    params: {},
// }

function normalizeLocalView(resp) {
  if (resp == null) return null;

  if (resp.method == null) {
    resp = _extends$2({}, resp, {
      type: "local-view",
      method: "VIEW/IFRAME"
    });
  }

  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;

    default:
      return _extends$2({}, SERVICE_PRAGMA, {
        type: resp.type || "local-view",
        method: resp.method,
        endpoint: resp.endpoint,
        data: resp.data || {},
        params: resp.params || {}
      });
  }
}

// {
//   "f_type": "Service",                    // Its a service!
//   "f_vsn": "1.0.0",                       // Follows the v1.0.0 spec for the service
//   "type": "account-proof",                // the type of service it is
//   "method": "DATA",                       // Its data!
//   "uid": "awesome-wallet#account-proof",  // A unique identifier for the service
//   "data": {
//     "f_type": "account-proof",
//     "f_vsn": "1.0.0",
//     "nonce": "0A1BC2FF",                  // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)
//     "address": "0xUSER",                  // The user's address (8 bytes, i.e 16 hex characters)
//     "signature": CompositeSignature,      // address (sans-prefix), keyId, signature (hex)
// }
function normalizeAccountProof(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      throw new Error("FCL Normalizer Error: Invalid account-proof service");
  }
}

// {
//   "f_type": "Service",
//   "f_vsn": "1.0.0",
//   "type": "authn-refresh",
//   "uid": "uniqueDedupeKey",
//   "endpoint": "https://rawr",
//   "method": "HTTP/POST",  // "HTTP/POST", // HTTP/POST | IFRAME/RPC | HTTP/RPC
//   "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", // wallets internal id for the user
//   "data": {}, // included in body of request
//   "params": {}, // included as query params on endpoint url
// }
function normalizeAuthnRefresh(service) {
  if (service == null) return null;

  switch (service["f_vsn"]) {
    case "1.0.0":
      return service;

    default:
      throw new Error("Invalid authn-refresh service");
  }
}

var serviceNormalizers = {
  "back-channel-rpc": normalizeBackChannelRpc,
  "pre-authz": normalizePreAuthz,
  authz: normalizeAuthz,
  authn: normalizeAuthn,
  frame: normalizeFrame,
  "open-id": normalizeOpenId,
  "user-signature": normalizeUserSignature,
  "local-view": normalizeLocalView,
  "account-proof": normalizeAccountProof,
  "authn-refresh": normalizeAuthnRefresh
};
function normalizeService(service, data) {
  try {
    var normalized = serviceNormalizers[service.type](service, data);
    return normalized;
  } catch (error) {
    console.error("Unrecognized FCL Service Type [" + service.type + "]", service, error);
    return service;
  }
}

function deriveCompositeId(authn) {
  return rlp__namespace.encode([authn.provider.address || authn.provider.name || "UNSPECIFIED", authn.id]).toString("hex");
}

function normalizeData(data) {
  data.addr = data.addr ? utilAddress.withPrefix(data.addr) : null;
  data.paddr = data.paddr ? utilAddress.withPrefix(data.paddr) : null;
  return data;
}

function findService(type, services) {
  return services.find(function (d) {
    return d.type === type;
  });
}

var buildUser = function buildUser(data) {
  try {
    data = normalizeData(data);

    var _temp2 = data.services || [];

    return Promise.resolve(fetchServices(data.hks, data.code)).then(function (_fetchServices) {
      var services = mergeServices(_temp2, _fetchServices).map(function (service) {
        return normalizeService(service, data);
      });
      var authn = findService("authn", services);
      return _extends$2({}, USER_PRAGMA, {
        addr: utilAddress.withPrefix(data.addr),
        cid: deriveCompositeId(authn),
        loggedIn: true,
        services: services,
        expiresAt: data.expires
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function serviceOfType(services, type) {
  if (services === void 0) {
    services = [];
  }

  return services.find(function (service) {
    return service.type === type;
  });
}

function serviceEndpoint(service) {
  var url = new URL(service.endpoint);
  url.searchParams.append("l6n", window.location.origin);

  if (service.params != null) {
    for (var _i = 0, _Object$entries = Object.entries(service.params || {}); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
      url.searchParams.append(key, value);
    }
  }

  return url;
}

function fetchService(service, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var method = opts.method || "POST";
  var body = method === "GET" ? undefined : JSON.stringify(opts.data || service.data || {});
  return fetch(serviceEndpoint(service), {
    method: method,
    headers: _extends$2({}, service.headers || {}, opts.headers || {}, {
      "Content-Type": "application/json"
    }),
    body: body
  }).then(function (d) {
    return d.json();
  });
}

//    "f_type": "PollingResponse",
//    "f_vsn": "1.0.0",
//    "status": "PENDING", // PENDING | APPROVED | DECLINED | REDIRECT
//    "reason": null,      // Reason for Declining Transaction
//    "data": null,        // Return value for APPROVED
//    "updates": BackChannelRpc,
//    "local": Frame,
// }

function normalizePollingResponse(resp) {
  var _resp$status, _resp$reason;

  if (resp == null) return null;

  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;

    default:
      return _extends$2({}, POLLING_RESPONSE_PRAGMA, {
        status: (_resp$status = resp.status) != null ? _resp$status : "APPROVED",
        reason: (_resp$reason = resp.reason) != null ? _resp$reason : null,
        data: resp.compositeSignature || resp.data || _extends$2({}, resp) || {},
        updates: normalizeBackChannelRpc(resp.authorizationUpdates),
        local: normalizeFrame((resp.local || [])[0])
      });
  }
}

var poll = function poll(service, canContinue) {
  if (canContinue === void 0) {
    canContinue = function canContinue() {
      return true;
    };
  }

  try {
    utilInvariant.invariant(service, "Missing Polling Service", {
      service: service
    });
    if (!canContinue()) throw new Error("Externally Halted");
    return Promise.resolve(fetchService(service, {
      method: serviceMethod(service)
    }).then(normalizePollingResponse)).then(function (resp) {
      switch (resp.status) {
        case "APPROVED":
          return resp.data;

        case "DECLINED":
          throw new Error("Declined: " + (resp.reason || "No reason supplied."));

        default:
          return Promise.resolve(new Promise(function (r) {
            return setTimeout(r, 500);
          })).then(function () {
            return poll(resp.updates, canContinue);
          });
      }
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var OPTIONS = {
  "HTTP/GET": "GET",
  "HTTP/POST": "POST"
};

var serviceMethod = function serviceMethod(service) {
  utilInvariant.invariant(OPTIONS[service.method], "Invalid Service Method for type back-channel-rpc", {
    service: service
  });
  return OPTIONS[service.method];
};

var FRAME = "FCL_IFRAME";
var FRAME_STYLES = "\n  position:fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  height: 100%;\n  width: 100vw;\n  display:block;\n  background:rgba(0,0,0,0.25);\n  z-index: 2147483647;\n  box-sizing: border-box;\n";
function renderFrame(src) {
  utilInvariant.invariant(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
    src: src
  });
  var $frame = document.createElement("iframe");
  $frame.src = src;
  $frame.id = FRAME;
  $frame.allow = "usb *; hid *";
  $frame.frameBorder = "0";
  $frame.style.cssText = FRAME_STYLES;
  document.body.append($frame);

  var unmount = function unmount() {
    if (document.getElementById(FRAME)) {
      document.getElementById(FRAME).remove();
    }
  };

  return [$frame.contentWindow, unmount];
}

var POP = "FCL_POP";
var popup = null;
var previousUrl$1 = null;

function popupWindow(url, windowName, win, w, h) {
  var y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
  var x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
  return win.open(url, windowName, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + y + ", left=" + x);
}

function renderPop(src) {
  var _popup;

  if (popup == null || (_popup = popup) != null && _popup.closed) {
    popup = popupWindow(src, POP, window, 640, 770);
  } else if (previousUrl$1 !== src) {
    popup.location.replace(src);
    popup.focus();
  } else {
    popup.focus();
  }

  previousUrl$1 = src;

  var unmount = function unmount() {
    if (popup && !popup.closed) {
      popup.close();
    }

    popup = null;
  };

  return [popup, unmount];
}

var tab$1 = null;
var previousUrl = null;
function renderTab(src) {
  var _tab;

  if (tab$1 == null || (_tab = tab$1) != null && _tab.closed) {
    tab$1 = window.open(src, "_blank");
  } else if (previousUrl !== src) {
    tab$1.location.replace(src);
    tab$1.focus();
  } else {
    tab$1.focus();
  }

  previousUrl = src;

  var unmount = function unmount() {
    if (tab$1 && !tab$1.closed) {
      tab$1.close();
    }

    tab$1 = null;
  };

  return [tab$1, unmount];
}

var execLocal = function execLocal(service, opts) {
  if (opts === void 0) {
    opts = {};
  }

  try {
    try {
      return Promise.resolve(VIEWS[service.method](serviceEndpoint(service), opts));
    } catch (error) {
      console.error("execLocal({service, opts = {}})", error, {
        service: service,
        opts: opts
      });
      throw error;
    }
  } catch (e) {
    return Promise.reject(e);
  }
};
var VIEWS = {
  "VIEW/IFRAME": renderFrame,
  "VIEW/POP": renderPop,
  "VIEW/TAB": renderTab
};

var execHttpPost = function execHttpPost(service, signable, opts, config) {
  try {
    return Promise.resolve(fetchService(service, {
      data: _extends$2({
        fclVersion: VERSION,
        service: {
          params: service.params,
          data: service.data,
          type: service.type
        },
        config: config
      }, signable)
    }).then(normalizePollingResponse)).then(function (resp) {
      if (resp.status === "APPROVED") {
        return resp.data;
      } else if (resp.status === "DECLINED") {
        throw new Error("Declined: " + (resp.reason || "No reason supplied."));
      } else if (resp.status === "REDIRECT") {
        return resp;
      } else if (resp.status === "PENDING") {
        var canContinue = true;
        return Promise.resolve(execLocal(normalizeLocalView(resp.local))).then(function (_ref) {
          var _ = _ref[0],
              unmount = _ref[1];

          var close = function close() {
            try {
              unmount();
              canContinue = false;
            } catch (error) {
              console.error("Frame Close Error", error);
            }
          };

          return poll(resp.updates, function () {
            return canContinue;
          }).then(function (serviceResponse) {
            close();
            return serviceResponse;
          })["catch"](function (error) {
            console.error(error);
            close();
            throw error;
          });
        });
      } else {
        console.error("Auto Decline: Invalid Response", {
          service: service,
          resp: resp
        });
        throw new Error("Auto Decline: Invalid Response");
      }
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var CLOSE_EVENT = "FCL:VIEW:CLOSE";
var READY_EVENT = "FCL:VIEW:READY";
var RESPONSE_EVENT = "FCL:VIEW:RESPONSE";

var _ = function _(e) {
  return typeof e === "string" && e.toLowerCase();
};

var IGNORE = new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]);

var deprecate$1 = function deprecate(was, want) {
  return console.warn("DEPRECATION NOTICE", "Received " + was + ", please use " + want + " for this and future versions of FCL");
};

var buildMessageHandler = function buildMessageHandler(_ref) {
  var close = _ref.close,
      send = _ref.send,
      onReady = _ref.onReady,
      onResponse = _ref.onResponse,
      onMessage = _ref.onMessage;
  return function (e) {
    try {
      if (typeof e.data !== "object") return;
      if (IGNORE.has(e.data.type)) return;
      if (_(e.data.type) === _(CLOSE_EVENT)) close();
      if (_(e.data.type) === _(READY_EVENT)) onReady(e, {
        send: send,
        close: close
      });
      if (_(e.data.type) === _(RESPONSE_EVENT)) onResponse(e, {
        send: send,
        close: close
      });
      onMessage(e, {
        send: send,
        close: close
      }); // Backwards Compatible

      if (_(e.data.type) === _("FCL:FRAME:READY")) {
        deprecate$1(e.data.type, READY_EVENT);
        onReady(e, {
          send: send,
          close: close
        });
      }

      if (_(e.data.type) === _("FCL:FRAME:RESPONSE")) {
        deprecate$1(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send: send,
          close: close
        });
      }

      if (_(e.data.type) === _("FCL:FRAME:CLOSE")) {
        deprecate$1(e.data.type, CLOSE_EVENT);
        close();
      } //


      if (_(e.data.type) === _("FCL::CHALLENGE::RESPONSE")) {
        deprecate$1(e.data.type, RESPONSE_EVENT);
        onResponse(e, {
          send: send,
          close: close
        });
      }

      if (_(e.data.type) === _("FCL::AUTHZ_READY")) {
        deprecate$1(e.data.type, READY_EVENT);
        onReady(e, {
          send: send,
          close: close
        });
      }

      if (_(e.data.type) === _("FCL::CHALLENGE::CANCEL")) {
        deprecate$1(e.data.type, CLOSE_EVENT);
        close();
      }

      if (_(e.data.type) === _("FCL::CANCEL")) {
        deprecate$1(e.data.type, CLOSE_EVENT);
        close();
      }
    } catch (error) {
      console.error("Frame Callback Error", error);
      close();
    }
  };
};

var noop$4 = function noop() {};

function frame(service, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (service == null) return {
    send: noop$4,
    close: noop$4
  };
  var onClose = opts.onClose || noop$4;
  var onMessage = opts.onMessage || noop$4;
  var onReady = opts.onReady || noop$4;
  var onResponse = opts.onResponse || noop$4;
  window.addEventListener("message", buildMessageHandler({
    close: close,
    send: send,
    onReady: onReady,
    onResponse: onResponse,
    onMessage: onMessage
  }));

  var _renderFrame = renderFrame(serviceEndpoint(service)),
      $frame = _renderFrame[0],
      unmount = _renderFrame[1];

  return {
    send: send,
    close: close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      unmount();
      onClose();
    } catch (error) {
      console.error("Frame Close Error", error);
    }
  }

  function send(msg) {
    try {
      $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Frame Send Error", msg, error);
    }
  }
}

function execIframeRPC(service, body, opts, config) {
  return new Promise(function (resolve, reject) {
    var id = utilUid.uid();
    var includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    frame(service, {
      onReady: function onReady(_, _ref) {
        var send = _ref.send;

        try {
          try {
            send({
              type: "FCL:VIEW:READY:RESPONSE",
              fclVersion: VERSION,
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config
            });
            send({
              fclVersion: VERSION,
              type: "FCL:FRAME:READY:RESPONSE",
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config,
              deprecated: {
                message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });

            if (includeOlderJsonRpcCall) {
              send({
                jsonrpc: "2.0",
                id: id,
                method: "fcl:sign",
                params: [body, service.params],
                deprecated: {
                  message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                }
              });
            }
          } catch (error) {
            throw error;
          }

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      },
      onResponse: function onResponse(e, _ref2) {
        var close = _ref2.close;

        try {
          if (typeof e.data !== "object") return;
          var resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onResponse error", error);
          throw error;
        }
      },
      onMessage: function onMessage(e, _ref3) {
        var close = _ref3.close;

        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          var resp = normalizePollingResponse(e.data.result);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execIframeRPC onMessage error", error);
          throw error;
        }
      },
      onClose: function onClose() {
        reject("Declined: Externally Halted");
      }
    });
  });
}

var noop$3 = function noop() {};

function pop(service, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (service == null) return {
    send: noop$3,
    close: noop$3
  };
  var onClose = opts.onClose || noop$3;
  var onMessage = opts.onMessage || noop$3;
  var onReady = opts.onReady || noop$3;
  var onResponse = opts.onResponse || noop$3;
  window.addEventListener("message", buildMessageHandler({
    close: close,
    send: send,
    onReady: onReady,
    onResponse: onResponse,
    onMessage: onMessage
  }));

  var _renderPop = renderPop(serviceEndpoint(service)),
      $pop = _renderPop[0],
      unmount = _renderPop[1];

  var timer = setInterval(function () {
    if ($pop && $pop.closed) {
      close();
    }
  }, 500);
  return {
    send: send,
    close: close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Popup Close Error", error);
    }
  }

  function send(msg) {
    try {
      $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Popup Send Error", msg, error);
    }
  }
}

function execPopRPC(service, body, opts, config) {
  return new Promise(function (resolve, reject) {
    var id = utilUid.uid();
    var redir = opts.redir,
        includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    pop(service, {
      onReady: function onReady(_, _ref) {
        var send = _ref.send;

        try {
          try {
            send({
              fclVersion: VERSION,
              type: "FCL:VIEW:READY:RESPONSE",
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config
            });
            send({
              fclVersion: VERSION,
              type: "FCL:FRAME:READY:RESPONSE",
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config,
              deprecated: {
                message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });

            if (includeOlderJsonRpcCall) {
              send({
                jsonrpc: "2.0",
                id: id,
                method: "fcl:sign",
                params: [body, service.params]
              });
            }
          } catch (error) {
            throw error;
          }

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      },
      onResponse: function onResponse(e, _ref2) {
        var close = _ref2.close;

        try {
          if (typeof e.data !== "object") return;
          var resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage: function onMessage(e, _ref3) {
        var close = _ref3.close;

        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          var resp = normalizePollingResponse(e.data.result);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose: function onClose() {
        reject("Declined: Externally Halted");
      }
    });
  });
}

var noop$2 = function noop() {};

function tab(service, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (service == null) return {
    send: noop$2,
    close: noop$2
  };
  var onClose = opts.onClose || noop$2;
  var onMessage = opts.onMessage || noop$2;
  var onReady = opts.onReady || noop$2;
  var onResponse = opts.onResponse || noop$2;
  window.addEventListener("message", buildMessageHandler({
    close: close,
    send: send,
    onReady: onReady,
    onResponse: onResponse,
    onMessage: onMessage
  }));

  var _renderTab = renderTab(serviceEndpoint(service)),
      $tab = _renderTab[0],
      unmount = _renderTab[1];

  var timer = setInterval(function () {
    if ($tab && $tab.closed) {
      close();
    }
  }, 500);
  return {
    send: send,
    close: close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      clearInterval(timer);
      unmount();
      onClose();
    } catch (error) {
      console.error("Tab Close Error", error);
    }
  }

  function send(msg) {
    try {
      $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Tab Send Error", msg, error);
    }
  }
}

function execTabRPC(service, body, opts, config) {
  return new Promise(function (resolve, reject) {
    var id = utilUid.uid();
    var redir = opts.redir,
        includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
    tab(service, {
      onReady: function onReady(_, _ref) {
        var send = _ref.send;

        try {
          try {
            send({
              fclVersion: VERSION,
              type: "FCL:VIEW:READY:RESPONSE",
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config
            });
            send({
              fclVersion: VERSION,
              type: "FCL:FRAME:READY:RESPONSE",
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config,
              deprecated: {
                message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
              }
            });

            if (includeOlderJsonRpcCall) {
              send({
                jsonrpc: "2.0",
                id: id,
                method: "fcl:sign",
                params: [body, service.params]
              });
            }
          } catch (error) {
            throw error;
          }

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      },
      onResponse: function onResponse(e, _ref2) {
        var close = _ref2.close;

        try {
          if (typeof e.data !== "object") return;
          var resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onResponse error", error);
          throw error;
        }
      },
      onMessage: function onMessage(e, _ref3) {
        var close = _ref3.close;

        try {
          if (typeof e.data !== "object") return;
          if (e.data.jsonrpc !== "2.0") return;
          if (e.data.id !== id) return;
          var resp = normalizePollingResponse(e.data.result);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              !redir && close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execPopRPC onMessage error", error);
          throw error;
        }
      },
      onClose: function onClose() {
        reject("Declined: Externally Halted");
      }
    });
  });
}

var noop$1 = function noop() {};

function extension(service, opts) {
  if (opts === void 0) {
    opts = {};
  }

  if (service == null) return {
    send: noop$1,
    close: noop$1
  };
  var onClose = opts.onClose || noop$1;
  var onMessage = opts.onMessage || noop$1;
  var onReady = opts.onReady || noop$1;
  var onResponse = opts.onResponse || noop$1;
  window.addEventListener("message", buildMessageHandler({
    close: close,
    send: send,
    onReady: onReady,
    onResponse: onResponse,
    onMessage: onMessage
  }));
  send({
    service: service
  });
  return {
    send: send,
    close: close
  };

  function close() {
    try {
      window.removeEventListener("message", buildMessageHandler);
      onClose();
    } catch (error) {
      console.error("Ext Close Error", error);
    }
  }

  function send(msg) {
    try {
      window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
    } catch (error) {
      console.error("Ext Send Error", msg, error);
    }
  }
}

function execExtRPC(service, body, opts, config) {
  return new Promise(function (resolve, reject) {
    extension(service, {
      onReady: function onReady(_, _ref) {
        var send = _ref.send;

        try {
          try {
            send({
              fclVersion: VERSION,
              type: "FCL:VIEW:READY:RESPONSE",
              body: body,
              service: {
                params: service.params,
                data: service.data,
                type: service.type
              },
              config: config
            });
          } catch (error) {
            throw error;
          }

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      },
      onResponse: function onResponse(e, _ref2) {
        var close = _ref2.close;

        try {
          if (typeof e.data !== "object") return;
          var resp = normalizePollingResponse(e.data);

          switch (resp.status) {
            case "APPROVED":
              resolve(resp.data);
              close();
              break;

            case "DECLINED":
              reject("Declined: " + (resp.reason || "No reason supplied"));
              close();
              break;

            case "REDIRECT":
              resolve(resp);
              close();
              break;

            default:
              reject("Declined: No reason supplied");
              close();
              break;
          }
        } catch (error) {
          console.error("execExtRPC onResponse error", error);
          throw error;
        }
      },
      onClose: function onClose() {
        reject("Declined: Externally Halted");
      }
    });
  });
}

function _catch$5(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var execService = function execService(_ref) {
  var service = _ref.service,
      _ref$msg = _ref.msg,
      msg = _ref$msg === void 0 ? {} : _ref$msg,
      _ref$opts = _ref.opts,
      opts = _ref$opts === void 0 ? {} : _ref$opts,
      _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config;

  try {
    msg.data = service.data;
    return Promise.resolve(configLens(/^service\./)).then(function (_configLens) {
      return Promise.resolve(configLens(/^app\.detail\./)).then(function (_configLens2) {
        var _window$location$host, _window, _window$location, _window2;

        var fullConfig = _extends$2({}, config, {
          services: _configLens,
          app: _configLens2,
          client: {
            fclVersion: VERSION,
            fclLibrary: "https://github.com/onflow/fcl-js",
            hostname: (_window$location$host = (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.hostname) != null ? _window$location$host : null,
            extensions: ((_window2 = window) == null ? void 0 : _window2.fcl_extensions) || []
          }
        });

        return _catch$5(function () {
          return Promise.resolve(STRATEGIES[service.method](service, msg, opts, fullConfig)).then(function (res) {
            if (res.status === "REDIRECT") {
              utilInvariant.invariant(service.type === res.data.type, "Cannot shift recursive service type in execService");
              return Promise.resolve(execService({
                service: res.data,
                msg: msg,
                opts: opts,
                config: fullConfig
              }));
            } else {
              return res;
            }
          });
        }, function (error) {
          console.error("execService({service, msg = {}, opts = {}, config = {}})", error, {
            service: service,
            msg: msg,
            opts: opts,
            config: config
          });
          throw error;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var STRATEGIES = {
  "HTTP/RPC": execHttpPost,
  "HTTP/POST": execHttpPost,
  "IFRAME/RPC": execIframeRPC,
  "POP/RPC": execPopRPC,
  "TAB/RPC": execTabRPC,
  "EXT/RPC": execExtRPC
};

//    "f_type": "CompositeSignature",
//    "f_vsn": "1.0.0",
//    "addr": "_____",         // sans-prefix
//    "signature": "adfe1234", // hex
//    "keyId": 3,
// }

function normalizeCompositeSignature(resp) {
  if (resp == null) return null;

  switch (resp["f_vsn"]) {
    case "1.0.0":
      return resp;

    default:
      return _extends$2({}, COMPOSITE_SIGNATURE_PRAGMA, {
        addr: utilAddress.sansPrefix(resp.addr || resp.address),
        signature: resp.signature || resp.sig,
        keyId: resp.keyId
      });
  }
}

var _HANDLERS$4;

function _settle$1(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact$1) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle$1.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle$1.bind(null, pact, state), _settle$1.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var signUserMessage = function signUserMessage(msg) {
  try {
    spawnCurrentUser();
    return Promise.resolve(authenticate$1({
      redir: true
    })).then(function (user) {
      var signingService = serviceOfType(user.services, "user-signature");
      utilInvariant.invariant(signingService, "Current user must have authorized a signing service.");
      return _catch$4(function () {
        return Promise.resolve(execService({
          service: signingService,
          msg: makeSignable(msg)
        })).then(function (response) {
          if (Array.isArray(response)) {
            return response.map(function (compSigs) {
              return normalizeCompositeSignature(compSigs);
            });
          } else {
            return [normalizeCompositeSignature(response)];
          }
        });
      }, function (error) {
        return error;
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var _Pact$1 = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle$1(result, 1, callback(this.v));
        } catch (e) {
          _settle$1(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle$1(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle$1(result, 1, onRejected(value));
        } else {
          _settle$1(result, 2, value);
        }
      } catch (e) {
        _settle$1(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact$1(thenable) {
  return thenable instanceof _Pact$1 && thenable.s & 1;
}

function _for$1(test, update, body) {
  var stage;

  for (;;) {
    var shouldContinue = test();

    if (_isSettledPact$1(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }

    if (!shouldContinue) {
      return result;
    }

    if (shouldContinue.then) {
      stage = 0;
      break;
    }

    var result = body();

    if (result && result.then) {
      if (_isSettledPact$1(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }

    if (update) {
      var updateValue = update();

      if (updateValue && updateValue.then && !_isSettledPact$1(updateValue)) {
        stage = 2;
        break;
      }
    }
  }

  var pact = new _Pact$1();

  var reject = _settle$1.bind(null, pact, 2);

  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;

  function _resumeAfterBody(value) {
    result = value;

    do {
      if (update) {
        updateValue = update();

        if (updateValue && updateValue.then && !_isSettledPact$1(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }

      shouldContinue = test();

      if (!shouldContinue || _isSettledPact$1(shouldContinue) && !shouldContinue.v) {
        _settle$1(pact, 1, result);

        return;
      }

      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }

      result = body();

      if (_isSettledPact$1(result)) {
        result = result.v;
      }
    } while (!result || !result.then);

    result.then(_resumeAfterBody).then(void 0, reject);
  }

  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();

      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle$1(pact, 1, result);
    }
  }

  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle$1(pact, 1, result);
    }
  }
}

var resolveArgument = function resolveArgument() {
  return Promise.resolve(authenticate$1()).then(function (_ref4) {
    var addr = _ref4.addr;
    return sdk.arg(utilAddress.withPrefix(addr), t__namespace.Address);
  });
};

function _catch$4(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _finally(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer();
  }

  if (result && result.then) {
    return result.then(finalizer, finalizer);
  }

  return finalizer();
}

var authorization = function authorization(account) {
  try {
    spawnCurrentUser();
    return Promise.resolve(_extends$2({}, account, {
      tempId: "CURRENT_USER",
      resolve: function resolve(account, preSignable) {
        try {
          return Promise.resolve(authenticate$1({
            redir: true
          })).then(function (user) {
            var _exit5;

            function _temp9(_result5) {
              if (_exit5) return _result5;
              if (authz) return _extends$2({}, account, {
                tempId: "CURRENT_USER",
                resolve: null,
                addr: utilAddress.sansPrefix(authz.identity.address),
                keyId: authz.identity.keyId,
                sequenceNum: null,
                signature: null,
                signingFunction: function signingFunction(signable) {
                  try {
                    return Promise.resolve(execService({
                      service: authz,
                      msg: signable,
                      opts: {
                        includeOlderJsonRpcCall: true
                      }
                    })).then(normalizeCompositeSignature);
                  } catch (e) {
                    return Promise.reject(e);
                  }
                }
              });
              throw new Error("No Authz or PreAuthz Service configured for CURRENT_USER");
            }

            var authz = serviceOfType(user.services, "authz");
            var preAuthz = serviceOfType(user.services, "pre-authz");

            var _temp8 = function () {
              if (preAuthz) {
                return Promise.resolve(execService({
                  service: preAuthz,
                  msg: preSignable
                })).then(function (_execService) {
                  var _resolvePreAuthz = resolvePreAuthz(_execService);

                  _exit5 = 1;
                  return _resolvePreAuthz;
                });
              }
            }();

            return _temp8 && _temp8.then ? _temp8.then(_temp9) : _temp9(_temp8);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

function _finallyRethrows$1(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }

  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }

  return finalizer(false, result);
}

var authenticate$1 = function authenticate(_temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2,
      service = _ref2.service,
      _ref2$redir = _ref2.redir,
      redir = _ref2$redir === void 0 ? false : _ref2$redir;

  try {
    return Promise.resolve(new Promise(function (resolve, reject) {
      try {
        spawnCurrentUser();
        var opts = {
          redir: redir
        };
        return Promise.resolve(snapshot()).then(function (user) {
          return Promise.resolve(getDiscoveryService()).then(function (discoveryService) {
            var _exit3;

            function _temp7(_result2) {
              var _exit4;

              if (_exit3) return _result2;

              function _temp5(_result3) {
                if (_exit4) return _result3;

                var _temp3 = _finallyRethrows$1(function () {
                  return _catch$4(function () {
                    return Promise.resolve(execService({
                      service: _extends$2({}, service || discoveryService, {
                        method: (discoveryService == null ? void 0 : discoveryService.method) || service.method || "IFRAME/RPC"
                      }),
                      msg: accountProofData,
                      opts: opts,
                      config: {
                        discoveryAuthnInclude: discoveryService.discoveryAuthnInclude
                      }
                    })).then(function (response) {
                      return Promise.resolve(buildUser(response)).then(function (_buildUser2) {
                        utilActor.send(NAME$2, SET_CURRENT_USER, _buildUser2);
                      });
                    });
                  }, function (e) {
                    console.error("Error while authenticating", e);
                  });
                }, function (_wasThrown, _result4) {
                  return Promise.resolve(snapshot()).then(function (_snapshot2) {
                    resolve(_snapshot2);
                    if (_wasThrown) throw _result4;
                    return _result4;
                  });
                });

                if (_temp3 && _temp3.then) return _temp3.then(function () {});
              }

              utilInvariant.invariant(service || discoveryService.endpoint, "\n        If no service passed to \"authenticate,\" then \"discovery.wallet\" must be defined in config.\n        See: \"https://docs.onflow.org/fcl/reference/api/#setting-configuration-values\"\n      ");

              var _temp4 = function () {
                if (user.loggedIn) {
                  if (refreshService) {
                    return _finally(function () {
                      return _catch$4(function () {
                        return Promise.resolve(execService({
                          service: refreshService,
                          msg: accountProofData,
                          opts: opts
                        })).then(function (response) {
                          return Promise.resolve(buildUser(response)).then(function (_buildUser) {
                            utilActor.send(NAME$2, SET_CURRENT_USER, _buildUser);
                          });
                        });
                      }, function (e) {
                        console.error("Error: Could not refresh authentication.", e);
                      });
                    }, function () {
                      return Promise.resolve(snapshot()).then(function (_snapshot) {
                        var _resolve = resolve(_snapshot);

                        _exit4 = 1;
                        return _resolve;
                      });
                    });
                  } else {
                    var _resolve3 = resolve(user);

                    _exit4 = 1;
                    return _resolve3;
                  }
                }
              }();

              return _temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4);
            }

            var refreshService = serviceOfType(user.services, "authn-refresh");
            var accountProofData;

            var _temp6 = _catch$4(function () {
              return Promise.resolve(getAccountProofData()).then(function (_getAccountProofData) {
                accountProofData = _getAccountProofData;
              });
            }, function (error) {
              console.error("Error During Authentication: Could not resolve account proof data.\n        " + error);

              var _reject = reject(error);

              _exit3 = 1;
              return _reject;
            });

            return _temp6 && _temp6.then ? _temp6.then(_temp7) : _temp7(_temp6);
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var getAccountProofData = function getAccountProofData() {
  try {
    return Promise.resolve(config$1.config.get("fcl.accountProof.resolver")).then(function (accountProofDataResolver) {
      function _temp10(accountProofData) {
        if (accountProofData == null) return;
        utilInvariant.invariant(typeof accountProofData.appIdentifier === "string", "appIdentifier must be a string");
        utilInvariant.invariant(/^[0-9a-f]+$/i.test(accountProofData.nonce), "Nonce must be a hex string");
        return accountProofData;
      }

      return accountProofDataResolver ? Promise.resolve(accountProofDataResolver()).then(_temp10) : _temp10(accountProofDataResolver);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var NAME$2 = "CURRENT_USER";
var UPDATED$3 = "CURRENT_USER/UPDATED";
var SNAPSHOT$1 = "SNAPSHOT";
var SET_CURRENT_USER = "SET_CURRENT_USER";
var DEL_CURRENT_USER = "DEL_CURRENT_USER";
var DATA = "{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}";

var getStoredUser = function getStoredUser(storage) {
  try {
    var fallback = JSON.parse(DATA);
    return Promise.resolve(storage.get(NAME$2)).then(function (stored) {
      if (stored != null && fallback["f_vsn"] !== stored["f_vsn"]) {
        storage.removeItem(NAME$2);
        return fallback;
      }

      return stored || fallback;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var HANDLERS$4 = (_HANDLERS$4 = {}, _HANDLERS$4[utilActor.INIT] = function (ctx) {
  try {
    if (typeof window === "undefined") {
      console.warn("\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        ", "font-weight:bold;font-family:monospace;");
    }

    ctx.merge(JSON.parse(DATA));
    return Promise.resolve(config$1.config.first(["fcl.storage", "fcl.storage.default"])).then(function (storage) {
      var _temp = function () {
        if (storage.can) {
          return Promise.resolve(getStoredUser(storage)).then(function (user) {
            if (notExpired(user)) ctx.merge(user);
          });
        }
      }();

      if (_temp && _temp.then) return _temp.then(function () {});
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$4[utilActor.SUBSCRIBE] = function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED$3, _extends$2({}, ctx.all()));
}, _HANDLERS$4[utilActor.UNSUBSCRIBE] = function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}, _HANDLERS$4[SNAPSHOT$1] = function (ctx, letter) {
  try {
    letter.reply(_extends$2({}, ctx.all()));
    return Promise.resolve();
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$4[SET_CURRENT_USER] = function (ctx, letter, data) {
  try {
    ctx.merge(data);
    return Promise.resolve(config$1.config.first(["fcl.storage", "fcl.storage.default"])).then(function (storage) {
      if (storage.can) storage.put(NAME$2, ctx.all());
      ctx.broadcast(UPDATED$3, _extends$2({}, ctx.all()));
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$4[DEL_CURRENT_USER] = function (ctx, letter) {
  try {
    ctx.merge(JSON.parse(DATA));
    return Promise.resolve(config$1.config.first(["fcl.storage", "fcl.storage.default"])).then(function (storage) {
      if (storage.can) storage.put(NAME$2, ctx.all());
      ctx.broadcast(UPDATED$3, _extends$2({}, ctx.all()));
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$4);

var spawnCurrentUser = function spawnCurrentUser() {
  return utilActor.spawn(HANDLERS$4, NAME$2);
};

function notExpired(user) {
  return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();
}

function unauthenticate$1() {
  spawnCurrentUser();
  utilActor.send(NAME$2, DEL_CURRENT_USER);
}

var normalizePreAuthzResponse = function normalizePreAuthzResponse(authz) {
  return {
    f_type: "PreAuthzResponse",
    f_vsn: "1.0.0",
    proposer: (authz || {}).proposer,
    payer: (authz || {}).payer || [],
    authorization: (authz || {}).authorization || []
  };
};

function resolvePreAuthz(authz) {
  var resp = normalizePreAuthzResponse(authz);
  var axs = [];
  if (resp.proposer != null) axs.push(["PROPOSER", resp.proposer]);

  for (var _iterator = _createForOfIteratorHelperLoose$1(resp.payer || []), _step; !(_step = _iterator()).done;) {
    var az = _step.value;
    axs.push(["PAYER", az]);
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose$1(resp.authorization || []), _step2; !(_step2 = _iterator2()).done;) {
    var _az = _step2.value;
    axs.push(["AUTHORIZER", _az]);
  }

  var result = axs.map(function (_ref) {
    var role = _ref[0],
        az = _ref[1];
    return {
      tempId: [az.identity.address, az.identity.keyId].join("|"),
      addr: az.identity.address,
      keyId: az.identity.keyId,
      signingFunction: function signingFunction(signable) {
        return execService({
          service: az,
          msg: signable
        });
      },
      role: {
        proposer: role === "PROPOSER",
        payer: role === "PAYER",
        authorizer: role === "AUTHORIZER"
      }
    };
  });
  return result;
}

function subscribe$1(callback) {
  spawnCurrentUser();
  var EXIT = "@EXIT";
  var self = utilActor.spawn(function (ctx) {
    try {
      var _exit2;

      ctx.send(NAME$2, utilActor.SUBSCRIBE);
      return Promise.resolve(_for$1(function () {
        return !_exit2 && 1;
      }, void 0, function () {
        return Promise.resolve(ctx.receive()).then(function (letter) {
          if (letter.tag === EXIT) {
            ctx.send(NAME$2, utilActor.UNSUBSCRIBE);
            _exit2 = 1;
            return;
          }

          callback(letter.data);
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return function () {
    return utilActor.send(self, EXIT);
  };
}

function snapshot() {
  spawnCurrentUser();
  return utilActor.send(NAME$2, SNAPSHOT$1, null, {
    expectReply: true,
    timeout: 0
  });
}

var makeSignable = function makeSignable(msg) {
  utilInvariant.invariant(/^[0-9a-f]+$/i.test(msg), "Message must be a hex string");
  return {
    message: msg
  };
};

var currentUser = function currentUser() {
  return {
    authenticate: authenticate$1,
    unauthenticate: unauthenticate$1,
    authorization: authorization,
    signUserMessage: signUserMessage,
    subscribe: subscribe$1,
    snapshot: snapshot,
    resolveArgument: resolveArgument
  };
};

currentUser.authenticate = authenticate$1;
currentUser.unauthenticate = unauthenticate$1;
currentUser.authorization = authorization;
currentUser.signUserMessage = signUserMessage;
currentUser.subscribe = subscribe$1;
currentUser.snapshot = snapshot;
currentUser.resolveArgument = resolveArgument;

var _HANDLERS$3;

function _catch$3(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}
var RATE$1 = 2500;
var POLL = "POLL";

var fetchTxStatus = function fetchTxStatus(transactionId) {
  try {
    return Promise.resolve(sdk.send([sdk.getTransactionStatus(transactionId)]).then(sdk.decode));
  } catch (e) {
    return Promise.reject(e);
  }
};

var isExpired = function isExpired(tx) {
  return tx.status === 5;
};

var isSealed = function isSealed(tx) {
  return tx.status >= 4;
};

var isExecuted = function isExecuted(tx) {
  return tx.status >= 3;
};

var isFinalized = function isFinalized(tx) {
  return tx.status >= 2;
};

var isPending = function isPending(tx) {
  return tx.status >= 1;
};

var isUnknown = function isUnknown(tx) {
  return tx.status >= 0;
};

var isDiff = function isDiff(cur, next) {
  return JSON.stringify(cur) !== JSON.stringify(next);
};

var HANDLERS$3 = (_HANDLERS$3 = {}, _HANDLERS$3[utilActor.INIT] = function (ctx) {
  try {
    return Promise.resolve(fetchTxStatus(ctx.self())).then(function (tx) {
      if (!isSealed(tx)) setTimeout(function () {
        return ctx.sendSelf(POLL);
      }, RATE$1);
      ctx.merge(tx);
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$3[utilActor.SUBSCRIBE] = function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, utilActor.UPDATED, ctx.all());
}, _HANDLERS$3[utilActor.UNSUBSCRIBE] = function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}, _HANDLERS$3[utilActor.SNAPSHOT] = function (ctx, letter) {
  try {
    letter.reply(ctx.all());
    return Promise.resolve();
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$3[POLL] = function (ctx) {
  try {
    var _temp3 = function _temp3(_result) {
      if (_exit2) return _result;
      if (!isSealed(tx)) setTimeout(function () {
        return ctx.sendSelf(POLL);
      }, RATE$1);
      if (isDiff(ctx.all(), tx)) ctx.broadcast(utilActor.UPDATED, tx);
      ctx.merge(tx);
    };

    var _exit2;

    var tx;

    var _temp4 = _catch$3(function () {
      return Promise.resolve(fetchTxStatus(ctx.self())).then(function (_fetchTxStatus) {
        tx = _fetchTxStatus;
      });
    }, function (e) {
      console.error(e);
      setTimeout(function () {
        return ctx.sendSelf(POLL);
      }, RATE$1);
      _exit2 = 1;
    });

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$3);

var scoped = function scoped(transactionId) {
  if (typeof transactionId === "object") transactionId = transactionId.transactionId;
  if (transactionId == null) throw new Error("transactionId required");
  return transactionId;
};

var spawnTransaction = function spawnTransaction(transactionId) {
  return utilActor.spawn(HANDLERS$3, scoped(transactionId));
};

function transaction(transactionId) {
  function snapshot() {
    return utilActor.snapshoter(transactionId, spawnTransaction);
  }

  function subscribe(callback) {
    return utilActor.subscriber(scoped(transactionId), spawnTransaction, callback);
  }

  function once(predicate) {
    return function innerOnce(opts) {
      if (opts === void 0) {
        opts = {};
      }

      var suppress = opts.suppress || false;
      return new Promise(function (resolve, reject) {
        var unsub = subscribe(function (txStatus) {
          if (txStatus.statusCode && !suppress) {
            reject(txStatus.errorMessage);
            unsub();
          } else if (predicate(txStatus)) {
            resolve(txStatus);
            unsub();
          }
        });
      });
    };
  }

  return {
    snapshot: snapshot,
    subscribe: subscribe,
    onceFinalized: once(isFinalized),
    onceExecuted: once(isExecuted),
    onceSealed: once(isSealed)
  };
}
transaction.isUnknown = isUnknown;
transaction.isPending = isPending;
transaction.isFinalized = isFinalized;
transaction.isExecuted = isExecuted;
transaction.isSealed = isSealed;
transaction.isExpired = isExpired;

/** As the current user Mutate the Flow Blockchain
 *
 *  @arg {Object} opts - Mutation Options and configuration
 *  @arg {string} opts.cadence - Cadence Transaction used to mutate Flow
 *  @arg {ArgsFn} opts.args - Arguments passed to cadence transaction
 *  @arg {number} opts.limit - Compute Limit for transaction
 *  @returns {string} Transaction Id
 *
 *  Where:
 *    @callback ArgsFn
 *    @arg {ArgFn}  arg - Argument function to define a single argument
 *    @arg {Object} t   - Cadence Types object used to define the type
 *    @returns {args[]}
 *
 *    @callback ArgFn
 *    @arg {Any}  value - the value of the argument
 *    @arg {Type} type  - the cadence type of the value
 *    @returns {arg}
 *
 *  Example:
 *    fcl.mutate({
 *      cadence: `
 *        transaction(a: Int, b: Int, c: Address) {
 *          prepare(acct: AuthAccount) {
 *            log(acct)
 *            log(a)
 *            log(b)
 *            log(c)
 *          }
 *        }
 *      `,
 *      args: (arg, t) => [
 *        arg(6, t.Int),
 *        arg(7, t.Int),
 *        arg("0xba1132bc08f82fe2", t.Address),
 *      ],
 *    })
 *
 *
 *  Options:
 *    type Options = {
 *      cadence: String!,
 *      args: (arg, t) => Array<Arg>,
 *      limit: Number,
 *      authz: AuthzFn, // will overload the trinity of signatory roles
 *      proposer: AuthzFn, // will overload the proposer signatory role
 *      payer: AuthzFn, // will overload the payer signatory role
 *      authorizations: [AuthzFn], // an array of authorization functions used as authorizations signatory roles
 *    }
 */

function _catch$2(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var prepMutation = function prepMutation(opts) {
  try {
    // prettier-ignore
    utilInvariant.invariant(isRequired(opts), "mutate(opts) -- opts is required"); // prettier-ignore

    utilInvariant.invariant(isObject(opts), "mutate(opts) -- opts must be an object"); // prettier-ignore

    utilInvariant.invariant(isRequired(opts.cadence), "mutate({ cadence }) -- cadence is required"); // prettier-ignore

    utilInvariant.invariant(isString(opts.cadence), "mutate({ cadence }) -- cadence must be a string"); // prettier-ignore

    return Promise.resolve(sdk__namespace.config.get("accessNode.api")).then(function (_sdk$config$get) {
      utilInvariant.invariant(_sdk$config$get, "Required value for \"accessNode.api\" not defined in config. See: " + "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration");
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var mutate = function mutate(opts) {
  if (opts === void 0) {
    opts = {};
  }

  try {
    var txid;
    return Promise.resolve(_catch$2(function () {
      return Promise.resolve(prepMutation(opts)).then(function () {
        // Allow for a config to overwrite the authorization function.
        // prettier-ignore
        return Promise.resolve(sdk__namespace.config().get("fcl.authz", currentUser().authorization)).then(function (authz) {
          // prettier-ignore
          txid = sdk__namespace.send([sdk__namespace.transaction(opts.cadence), sdk__namespace.args(normalizeArgs(opts.args || [])), opts.limit && isNumber(opts.limit) && sdk__namespace.limit(opts.limit), // opts.proposer > opts.authz > authz
          sdk__namespace.proposer(opts.proposer || opts.authz || authz), // opts.payer > opts.authz > authz
          sdk__namespace.payer(opts.payer || opts.authz || authz), // opts.authorizations > [opts.authz > authz]
          sdk__namespace.authorizations(opts.authorizations || [opts.authz || authz])]).then(sdk__namespace.decode);
          return txid;
        });
      });
    }, function (error) {
      throw error;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var onMessageFromFCL = function onMessageFromFCL(messageType, cb) {
  if (cb === void 0) {
    cb = function cb() {};
  }

  var buildData = function buildData(data) {
    var _data$body;

    if (data.deprecated) console.warn("DEPRECATION NOTICE", data.deprecated.message);
    data == null ? true : (_data$body = data.body) == null ? true : delete _data$body.interaction;
    return data;
  };

  var internal = function internal(e) {
    var data = e.data;
    if (typeof data !== "object") return;
    if (typeof data == null) return;
    if (data.type !== messageType) return;
    cb(buildData(data));
  };

  window.addEventListener("message", internal);
  return function () {
    return window.removeEventListener("message", internal);
  };
};

var sendMsgToFCL = function sendMsgToFCL(type, msg) {
  if (msg === void 0) {
    msg = {};
  }

  if (window.location !== window.parent.location) {
    window.parent.postMessage(_extends$2({}, msg, {
      type: type
    }), "*");
  } else {
    window.opener.postMessage(_extends$2({}, msg, {
      type: type
    }), "*");
  }
};
var ready = function ready(cb, msg) {

  onMessageFromFCL("FCL:VIEW:READY:RESPONSE", cb);
  sendMsgToFCL("FCL:VIEW:READY");
};
var close = function close() {
  sendMsgToFCL("FCL:VIEW:CLOSE");
};
var approve = function approve(data) {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "APPROVED",
    reason: null,
    data: data
  });
};
var decline = function decline(reason) {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "DECLINED",
    reason: reason,
    data: null
  });
};
var redirect = function redirect(data) {
  sendMsgToFCL("FCL:VIEW:RESPONSE", {
    f_type: "PollingResponse",
    f_vsn: "1.0.0",
    status: "REDIRECT",
    reason: null,
    data: data
  });
};

function CompositeSignature(addr, keyId, signature) {
  this.f_type = COMPOSITE_SIGNATURE_PRAGMA.f_type;
  this.f_vsn = COMPOSITE_SIGNATURE_PRAGMA.f_vsn;
  this.addr = utilAddress.withPrefix(addr);
  this.keyId = Number(keyId);
  this.signature = signature;
}

var rightPaddedHexBuffer = function rightPaddedHexBuffer(value, pad) {
  return rlp.Buffer.from(value.padEnd(pad * 2, "0"), "hex");
};

var leftPaddedHexBuffer = function leftPaddedHexBuffer(value, pad) {
  return rlp.Buffer.from(value.padStart(pad * 2, "0"), "hex");
};

var addressBuffer = function addressBuffer(addr) {
  return leftPaddedHexBuffer(addr, 8);
};

var nonceBuffer = function nonceBuffer(nonce) {
  return rlp.Buffer.from(nonce, "hex");
};

var encodeAccountProof = function encodeAccountProof(_ref, includeDomainTag) {
  var address = _ref.address,
      nonce = _ref.nonce,
      appIdentifier = _ref.appIdentifier;

  if (includeDomainTag === void 0) {
    includeDomainTag = true;
  }

  utilInvariant.invariant(address, "Encode Message For Provable Authn Error: address must be defined");
  utilInvariant.invariant(nonce, "Encode Message For Provable Authn Error: nonce must be defined");
  utilInvariant.invariant(appIdentifier, "Encode Message For Provable Authn Error: appIdentifier must be defined");
  utilInvariant.invariant(nonce.length >= 64, "Encode Message For Provable Authn Error: nonce must be minimum of 32 bytes");
  var ACCOUNT_PROOF_DOMAIN_TAG = rightPaddedHexBuffer(rlp.Buffer.from("FCL-ACCOUNT-PROOF-V0.0").toString("hex"), 32);

  if (includeDomainTag) {
    return rlp.Buffer.concat([ACCOUNT_PROOF_DOMAIN_TAG, rlp.encode([appIdentifier, addressBuffer(utilAddress.sansPrefix(address)), nonceBuffer(nonce)])]).toString("hex");
  }

  return rlp.encode([appIdentifier, addressBuffer(utilAddress.sansPrefix(address)), nonceBuffer(nonce)]).toString("hex");
};

function injectExtService(service) {
  if (service.type === "authn" && service.endpoint != null) {
    if (!Array.isArray(window.fcl_extensions)) {
      window.fcl_extensions = [];
    }

    window.fcl_extensions.push(service);
  } else {
    console.warn("Authn service is required");
  }
}

var index$1 = {
  __proto__: null,
  sendMsgToFCL: sendMsgToFCL,
  ready: ready,
  close: close,
  approve: approve,
  decline: decline,
  redirect: redirect,
  onMessageFromFCL: onMessageFromFCL,
  encodeMessageFromSignable: sdk.encodeMessageFromSignable,
  CompositeSignature: CompositeSignature,
  encodeAccountProof: encodeAccountProof,
  injectExtService: injectExtService
};

/**
 * Verify a valid signature/s for an account on Flow.
 *
 * @param {string} msg - A message string in hexadecimal format
 * @param {Array} compSigs - An array of Composite Signatures
 * @param {string} compSigs[].addr - The account address
 * @param {number} compSigs[].keyId - The account keyId
 * @param {string} compSigs[].signature - The signature to verify
 * @param {Object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed
 * @return {bool}
 *
 * @example
 *
 *  const isValid = await fcl.AppUtils.verifyUserSignatures(
 *    Buffer.from('FOO').toString("hex"),
 *    [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *    {fclCryptoContract}
 *  )
 */
var verifyUserSignatures$1 = function verifyUserSignatures(message, compSigs, opts) {
  if (opts === void 0) {
    opts = {};
  }

  try {
    validateArgs({
      message: message,
      compSigs: compSigs
    });
    var address = compSigs[0].addr;
    var signaturesArr = [];
    var keyIndices = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose$1(compSigs), _step2; !(_step2 = _iterator2()).done;) {
      var el = _step2.value;
      signaturesArr.push(el.signature);
      keyIndices.push(el.keyId);
    }

    return Promise.resolve(getVerifySignaturesScript(USER_SIGNATURE, opts)).then(function (_getVerifySignaturesS2) {
      return query({
        cadence: _getVerifySignaturesS2,
        args: function args(arg, t) {
          return [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array([t.Int])), arg(signaturesArr, t.Array([t.String]))];
        }
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

/**
 * Verify a valid account proof signature or signatures for an account on Flow.
 *
 * @param {string} appIdentifier - A message string in hexadecimal format
 * @param {Object} accountProofData - An object consisting of address, nonce, and signatures
 * @param {string} accountProofData.address - A Flow account address
 * @param {string} accountProofData.nonce - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters)
 * @param {Object[]} accountProofData.signatures - An array of composite signatures to verify
 * @param {Object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override Flow account address where the FCLCrypto contract is deployed
 * @return {bool}
 *
 * @example
 *
 *  const accountProofData = {
 *   address: "0x123",
 *   nonce: "F0123"
 *   signatures: [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *  }
 *
 *  const isValid = await fcl.AppUtils.verifyAccountProof(
 *    "AwesomeAppId",
 *    accountProofData,
 *    {fclCryptoContract}
 *  )
 */
var verifyAccountProof = function verifyAccountProof(appIdentifier, _ref, opts) {
  var address = _ref.address,
      nonce = _ref.nonce,
      signatures = _ref.signatures;

  if (opts === void 0) {
    opts = {};
  }

  try {
    validateArgs({
      appIdentifier: appIdentifier,
      address: address,
      nonce: nonce,
      signatures: signatures
    });
    var message = encodeAccountProof({
      address: address,
      nonce: nonce,
      appIdentifier: appIdentifier
    }, false);
    var signaturesArr = [];
    var keyIndices = [];

    for (var _iterator = _createForOfIteratorHelperLoose$1(signatures), _step; !(_step = _iterator()).done;) {
      var el = _step.value;
      signaturesArr.push(el.signature);
      keyIndices.push(el.keyId);
    }

    return Promise.resolve(getVerifySignaturesScript(ACCOUNT_PROOF, opts)).then(function (_getVerifySignaturesS) {
      return query({
        cadence: _getVerifySignaturesS,
        args: function args(arg, t) {
          return [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array([t.Int])), arg(signaturesArr, t.Array([t.String]))];
        }
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var ACCOUNT_PROOF = "ACCOUNT_PROOF";
var USER_SIGNATURE = "USER_SIGNATURE";
var validateArgs = function validateArgs(args) {
  if (args.appIdentifier) {
    var appIdentifier = args.appIdentifier,
        address = args.address,
        nonce = args.nonce,
        signatures = args.signatures;
    utilInvariant.invariant(isString(appIdentifier), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string");
    utilInvariant.invariant(isString(address) && utilAddress.sansPrefix(address).length === 16, "verifyAccountProof({ address }) -- address must be a valid address");
    utilInvariant.invariant(/^[0-9a-f]+$/i.test(nonce), "nonce must be a hex string");
    utilInvariant.invariant(Array.isArray(signatures) && signatures.every(function (sig, i, arr) {
      return sig.f_type === "CompositeSignature";
    }), "Must include an Array of CompositeSignatures to verify");
    utilInvariant.invariant(signatures.map(function (cs) {
      return cs.addr;
    }).every(function (addr, i, arr) {
      return addr === arr[0];
    }), "User signatures to be verified must be from a single account address");
    return true;
  } else {
    var message = args.message,
        compSigs = args.compSigs;
    utilInvariant.invariant(/^[0-9a-f]+$/i.test(message), "Signed message must be a hex string");
    utilInvariant.invariant(Array.isArray(compSigs) && compSigs.every(function (sig, i, arr) {
      return sig.f_type === "CompositeSignature";
    }), "Must include an Array of CompositeSignatures to verify");
    utilInvariant.invariant(compSigs.map(function (cs) {
      return cs.addr;
    }).every(function (addr, i, arr) {
      return addr === arr[0];
    }), "User signatures to be verified must be from a single account address");
    return true;
  }
};

var getVerifySignaturesScript = function getVerifySignaturesScript(sig, opts) {
  try {
    var verifyFunction = sig === "ACCOUNT_PROOF" ? "verifyAccountProofSignatures" : "verifyUserSignatures";
    return Promise.resolve(config$1.config.first(["env", "flow.network"])).then(function (network) {
      var fclCryptoContract;
      utilInvariant.invariant(opts.fclCryptoContract || network === "testnet" || network === "mainnet", "${verifyFunction}({ fclCryptoContract }) -- config.flow.network must be specified (testnet || mainnet) or contract address provided via opts.fclCryptoContract");

      if (opts.fclCryptoContract) {
        fclCryptoContract = opts.fclCryptoContract;
      } else {
        fclCryptoContract = network === "testnet" ? "0x74daa6f9c7ef24b1" : "0xb4b82a1c9d21d284";
      }

      return "\n      import FCLCrypto from " + fclCryptoContract + "\n\n      pub fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto." + verifyFunction + "(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    ";
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var index = {
  __proto__: null,
  verifyAccountProof: verifyAccountProof,
  verifyUserSignatures: verifyUserSignatures$1
};

var promise;
var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask : function (cb) {
  return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
    return setTimeout(function () {
      throw err;
    }, 0);
  });
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var mailbox = function mailbox() {
  var queue = [];
  var next;
  return {
    deliver: function deliver(msg) {
      try {
        queue.push(msg);

        if (next) {
          next(queue.shift());
          next = undefined;
        }

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    },
    receive: function receive() {
      return new Promise(function innerReceive(resolve) {
        var msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }

  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }

  return finalizer(false, result);
}

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}

function _for(test, update, body) {
  var stage;

  for (;;) {
    var shouldContinue = test();

    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }

    if (!shouldContinue) {
      return result;
    }

    if (shouldContinue.then) {
      stage = 0;
      break;
    }

    var result = body();

    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }

    if (update) {
      var updateValue = update();

      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }

  var pact = new _Pact();

  var reject = _settle.bind(null, pact, 2);

  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;

  function _resumeAfterBody(value) {
    result = value;

    do {
      if (update) {
        updateValue = update();

        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }

      shouldContinue = test();

      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);

        return;
      }

      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }

      result = body();

      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);

    result.then(_resumeAfterBody).then(void 0, reject);
  }

  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();

      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }

  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}

var INIT = "INIT";
var SUBSCRIBE = "SUBSCRIBE";
var UNSUBSCRIBE = "UNSUBSCRIBE";
var EXIT = "EXIT";
var TERMINATE = "TERMINATE";
var root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window;
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var pid = 0;
var DEFAULT_TIMEOUT = 5000;

var _send = function send(addr, tag, data, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return new Promise(function (reply, reject) {
    var expectReply = opts.expectReply || false;
    var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

    if (expectReply && timeout) {
      setTimeout(function () {
        return reject(new Error("Timeout: " + timeout + "ms passed without a response."));
      }, timeout);
    }

    var payload = {
      to: addr,
      from: opts.from,
      tag: tag,
      data: data,
      timeout: timeout,
      reply: reply,
      reject: reject
    };

    try {
      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
      if (!expectReply) reply(true);
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
    }
  });
};

var kill = function kill(addr) {
  delete root.FCL_REGISTRY[addr];
};

var fromHandlers = function fromHandlers(handlers) {
  if (handlers === void 0) {
    handlers = {};
  }

  return function (ctx) {
    try {
      var _temp12 = function _temp12() {
        var _loopInterrupt;

        var _temp6 = _for(function () {
          return !_loopInterrupt && 1;
        }, void 0, function () {
          return Promise.resolve(ctx.receive()).then(function (letter) {
            var _temp5 = _finallyRethrows(function () {
              return _catch(function () {
                function _temp4() {
                  return Promise.resolve(handlers[letter.tag](ctx, letter, letter.data || {})).then(function () {});
                }

                var _temp3 = function () {
                  if (letter.tag === EXIT) {
                    var _temp10 = function _temp10() {
                      _loopInterrupt = 1;
                    };

                    var _temp11 = function () {
                      if (typeof handlers[TERMINATE] === "function") {
                        return Promise.resolve(handlers[TERMINATE](ctx, letter, letter.data || {})).then(function () {});
                      }
                    }();

                    return _temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11);
                  }
                }();

                return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
              }, function (error) {
                console.error(ctx.self() + " Error", letter, error);
              });
            }, function (_wasThrown, _result) {
              return;
              if (_wasThrown) throw _result;
              return _result;
            });

            if (_temp5 && _temp5.then) return _temp5.then(function () {});
          });
        });

        var _temp7 = function () {
          if (_temp6 && _temp6.then) return _temp6.then(function () {});
        }();

        if (_temp7 && _temp7.then) return _temp7.then(function () {});
      };

      var _temp13 = function () {
        if (typeof handlers[INIT] === "function") return Promise.resolve(handlers[INIT](ctx)).then(function () {});
      }();

      return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp12) : _temp12(_temp13));
    } catch (e) {
      return Promise.reject(e);
    }
  };
};

var spawn = function spawn(fn, addr) {
  if (addr === void 0) {
    addr = null;
  }

  if (addr == null) addr = ++pid;
  if (root.FCL_REGISTRY[addr] != null) return addr;
  root.FCL_REGISTRY[addr] = {
    addr: addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {}
  };
  var ctx = {
    self: function self() {
      return addr;
    },
    receive: function receive() {
      return root.FCL_REGISTRY[addr].mailbox.receive();
    },
    send: function send(to, tag, data, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.from = addr;
      return _send(to, tag, data, opts);
    },
    sendSelf: function sendSelf(tag, data, opts) {
      if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
    },
    broadcast: function broadcast(tag, data, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.from = addr;

      for (var _iterator = _createForOfIteratorHelperLoose(root.FCL_REGISTRY[addr].subs), _step; !(_step = _iterator()).done;) {
        var to = _step.value;

        _send(to, tag, data, opts);
      }
    },
    subscribe: function subscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
    },
    unsubscribe: function unsubscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
    },
    subscriberCount: function subscriberCount() {
      return root.FCL_REGISTRY[addr].subs.size;
    },
    hasSubs: function hasSubs() {
      return !!root.FCL_REGISTRY[addr].subs.size;
    },
    put: function put(key, value) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: function get(key, fallback) {
      var value = root.FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    "delete": function _delete(key) {
      delete root.FCL_REGISTRY[addr].kvs[key];
    },
    update: function update(key, fn) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
    },
    keys: function keys() {
      return Object.keys(root.FCL_REGISTRY[addr].kvs);
    },
    all: function all() {
      return root.FCL_REGISTRY[addr].kvs;
    },
    where: function where(pattern) {
      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
        var _extends2;

        return pattern.test(key) ? _extends({}, acc, (_extends2 = {}, _extends2[key] = root.FCL_REGISTRY[addr].kvs[key], _extends2)) : acc;
      }, {});
    },
    merge: function merge(data) {
      if (data === void 0) {
        data = {};
      }

      Object.keys(data).forEach(function (key) {
        return root.FCL_REGISTRY[addr].kvs[key] = data[key];
      });
    }
  };
  if (typeof fn === "object") fn = fromHandlers(fn);
  queueMicrotask_1(function () {
    try {
      return Promise.resolve(fn(ctx)).then(function () {
        kill(addr);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return addr;
};

function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  var EXIT = "@EXIT";
  var self = spawn(function (ctx) {
    try {
      var _exit2;

      ctx.send(address, SUBSCRIBE);
      return Promise.resolve(_for(function () {
        return !_exit2 && 1;
      }, void 0, function () {
        return Promise.resolve(ctx.receive()).then(function (letter) {
          if (letter.tag === EXIT) {
            ctx.send(address, UNSUBSCRIBE);
            _exit2 = 1;
            return;
          }

          callback(letter.data);
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return function () {
    return _send(self, EXIT);
  };
}

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var _HANDLERS$2;

var first = function first(wants, fallback) {
  if (wants === void 0) {
    wants = [];
  }

  try {
    if (!wants.length) return Promise.resolve(fallback);

    var _wants = wants,
        head = _wants[0],
        rest = _wants.slice(1);

    return Promise.resolve(get(head)).then(function (ret) {
      return ret == null ? first(rest, fallback) : ret;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var NAME$1 = "config";
var PUT = "PUT_CONFIG";
var GET = "GET_CONFIG";
var GET_ALL = "GET_ALL_CONFIG";
var UPDATE = "UPDATE_CONFIG";
var DELETE = "DELETE_CONFIG";
var CLEAR = "CLEAR_CONFIG";
var WHERE = "WHERE_CONFIG";
var UPDATED$2 = "CONFIG/UPDATED";

var identity = function identity(v) {
  return v;
};

var HANDLERS$2 = (_HANDLERS$2 = {}, _HANDLERS$2[PUT] = function (ctx, _letter, _ref) {
  var key = _ref.key,
      value = _ref.value;
  if (key == null) throw new Error("Missing 'key' for config/put.");
  ctx.put(key, value);
  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS$2[GET] = function (ctx, letter, _ref2) {
  var key = _ref2.key,
      fallback = _ref2.fallback;
  if (key == null) throw new Error("Missing 'key' for config/get");
  letter.reply(ctx.get(key, fallback));
}, _HANDLERS$2[GET_ALL] = function (ctx, letter) {
  letter.reply(_extends$1({}, ctx.all()));
}, _HANDLERS$2[UPDATE] = function (ctx, letter, _ref3) {
  var key = _ref3.key,
      fn = _ref3.fn;
  if (key == null) throw new Error("Missing 'key' for config/update");
  ctx.update(key, fn || identity);
  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS$2[DELETE] = function (ctx, letter, _ref4) {
  var key = _ref4.key;
  if (key == null) throw new Error("Missing 'key' for config/delete");
  ctx["delete"](key);
  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS$2[CLEAR] = function (ctx, letter) {
  var keys = Object.keys(ctx.all());

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    ctx["delete"](key);
  }

  ctx.broadcast(UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS$2[WHERE] = function (ctx, letter, _ref5) {
  var pattern = _ref5.pattern;
  if (pattern == null) throw new Error("Missing 'pattern' for config/where");
  letter.reply(ctx.where(pattern));
}, _HANDLERS$2[SUBSCRIBE] = function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED$2, _extends$1({}, ctx.all()));
}, _HANDLERS$2[UNSUBSCRIBE] = function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}, _HANDLERS$2);
spawn(HANDLERS$2, NAME$1);

function put(key, value) {
  _send(NAME$1, PUT, {
    key: key,
    value: value
  });

  return config();
}

function get(key, fallback) {
  return _send(NAME$1, GET, {
    key: key,
    fallback: fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}

function all() {
  return _send(NAME$1, GET_ALL, null, {
    expectReply: true,
    timeout: 10
  });
}

function update(key, fn) {
  if (fn === void 0) {
    fn = identity;
  }

  _send(NAME$1, UPDATE, {
    key: key,
    fn: fn
  });

  return config();
}

function _delete(key) {
  _send(NAME$1, DELETE, {
    key: key
  });

  return config();
}

function where(pattern) {
  return _send(NAME$1, WHERE, {
    pattern: pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}

function subscribe(callback) {
  return subscriber(NAME$1, function () {
    return spawn(HANDLERS$2, NAME$1);
  }, callback);
}

function clearConfig() {
  return _send(NAME$1, CLEAR);
}

function config(values) {
  if (values != null && typeof values === "object") {
    Object.keys(values).map(function (d) {
      return put(d, values[d]);
    });
  }

  return {
    put: put,
    get: get,
    all: all,
    first: first,
    update: update,
    "delete": _delete,
    where: where,
    subscribe: subscribe,
    overload: overload
  };
}

config.put = put;
config.get = get;
config.all = all;
config.first = first;
config.update = update;
config["delete"] = _delete;
config.where = where;
config.subscribe = subscribe;
config.overload = overload;

var noop = function noop(v) {
  return v;
};

function overload(opts, callback) {
  if (opts === void 0) {
    opts = {};
  }

  if (callback === void 0) {
    callback = noop;
  }

  return new Promise(function (resolve, reject) {
    try {
      return Promise.resolve(all()).then(function (oldConfig) {
        var _temp = _catch$1(function () {
          config(opts);
          var _callback = callback;
          return Promise.resolve(all()).then(function (_all) {
            return Promise.resolve(_callback(_all)).then(function (result) {
              return Promise.resolve(clearConfig()).then(function () {
                return Promise.resolve(config(oldConfig)).then(function () {
                  resolve(result);
                });
              });
            });
          });
        }, function (error) {
          return Promise.resolve(clearConfig()).then(function () {
            return Promise.resolve(config(oldConfig)).then(function () {
              reject(error);
            });
          });
        });

        if (_temp && _temp.then) return _temp.then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  });
}

var LEVELS = Object.freeze({
  "debug": 5,
  "info": 4,
  "log": 3,
  "warn": 2,
  "error": 1
});

var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
  var title = _ref.title,
      message = _ref.message;
  return ["\n    %c" + title + "\n    ============================\n    " + message + "\n    ============================\n    ", "font-weight:bold;font-family:monospace;"];
};

var log = function log(_ref2) {
  var title = _ref2.title,
      message = _ref2.message,
      level = _ref2.level,
      _ref2$always = _ref2.always,
      always = _ref2$always === void 0 ? false : _ref2$always;

  try {
    return Promise.resolve(config.get("logger.level", 0)).then(function (configLoggerLevel) {
      var _console, _console2, _console3, _console4, _console5;

      if (!always && configLoggerLevel < level) return;
      var loggerMessageArgs = buildLoggerMessageArgs({
        title: title,
        message: message
      });

      switch (level) {
        case LEVELS.debug:
          (_console = console).debug.apply(_console, loggerMessageArgs);

          break;

        case LEVELS.info:
          (_console2 = console).info.apply(_console2, loggerMessageArgs);

          break;

        case LEVELS.warn:
          (_console3 = console).warn.apply(_console3, loggerMessageArgs);

          break;

        case LEVELS.error:
          (_console4 = console).error.apply(_console4, loggerMessageArgs);

          break;

        default:
          (_console5 = console).log.apply(_console5, loggerMessageArgs);

      }
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var deprecate = function deprecate(_ref) {
  var title = _ref.title,
      message = _ref.message,
      level = _ref.level,
      always = _ref.always;

  try {
    return Promise.resolve(log({
      title: title,
      message: message,
      level: level,
      always: always
    })).then(function () {});
  } catch (e) {
    return Promise.reject(e);
  }
};

/**
 * Verify a valid signature/s for an account on Flow.
 *
 * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead
 *
 */

var verifyUserSignatures = function verifyUserSignatures(message, compSigs) {
  try {
    deprecate({
      title: "FCL Deprecation Notice",
      message: "\n    fcl.verifyUserSignatures() is deprecated and will be removed in a future release\n    Please use fcl.AppUtils.verifyUserSignatures()",
      level: 2,
      always: true
    });
    return Promise.resolve(verifyUserSignatures$1(message, compSigs));
  } catch (e) {
    return Promise.reject(e);
  }
};

var serialize = function serialize(args, opts) {
  if (args === void 0) {
    args = [];
  }

  if (opts === void 0) {
    opts = {};
  }

  try {
    return Promise.resolve(sdk.config.first(["sdk.resolve"], opts.resolve || sdk.resolve)).then(function (resolveFunction) {
      function _temp2() {
        return Promise.resolve(resolveFunction(args)).then(function (_resolveFunction) {
          return JSON.stringify(sdk.createSignableVoucher(_resolveFunction), null, 2);
        });
      }

      var _temp = function () {
        if (Array.isArray(args)) return Promise.resolve(sdk.pipe(sdk.interaction(), args)).then(function (_pipe) {
          args = _pipe;
        });
      }();

      return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var _HANDLERS$1;
var RATE = 10000;
var UPDATED$1 = "UPDATED";
var TICK = "TICK";
var HIGH_WATER_MARK = "hwm";

var scheduleTick = function scheduleTick(ctx) {
  try {
    var _setTimeout2 = setTimeout;
    return Promise.resolve(sdk.config().get("fcl.eventPollRate", RATE)).then(function (_config$get) {
      return _setTimeout2(function () {
        return ctx.sendSelf(TICK);
      }, _config$get);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var HANDLERS$1 = (_HANDLERS$1 = {}, _HANDLERS$1[TICK] = function (ctx) {
  try {
    if (!ctx.hasSubs()) return Promise.resolve();
    var hwm = ctx.get(HIGH_WATER_MARK);

    var _temp2 = function () {
      if (hwm == null) {
        var _put4 = ctx.put;
        return Promise.resolve(sdk.block()).then(function (_block) {
          _put4.call(ctx, HIGH_WATER_MARK, _block);

          var _put2 = ctx.put;
          return Promise.resolve(scheduleTick(ctx)).then(function (_scheduleTick) {
            _put2.call(ctx, TICK, _scheduleTick);
          });
        });
      } else {
        return Promise.resolve(sdk.block()).then(function (next) {
          ctx.put(HIGH_WATER_MARK, next);
          return Promise.resolve(sdk.send([sdk.getEventsAtBlockHeightRange(ctx.self(), hwm.height, next.height - 1)]).then(sdk.decode)).then(function (data) {
            for (var _iterator = _createForOfIteratorHelperLoose$1(data), _step; !(_step = _iterator()).done;) {
              var d = _step.value;
              ctx.broadcast(UPDATED$1, d.data);
            }

            var _put3 = ctx.put;
            return Promise.resolve(scheduleTick(ctx)).then(function (_scheduleTick2) {
              _put3.call(ctx, TICK, _scheduleTick2);
            });
          });
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$1[utilActor.SUBSCRIBE] = function (ctx, letter) {
  try {
    var _temp5 = function _temp5() {
      ctx.subscribe(letter.from);
    };

    var _temp6 = function () {
      if (!ctx.hasSubs()) {
        var _put6 = ctx.put;
        return Promise.resolve(scheduleTick(ctx)).then(function (_scheduleTick3) {
          _put6.call(ctx, TICK, _scheduleTick3);
        });
      }
    }();

    return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS$1[utilActor.UNSUBSCRIBE] = function (ctx, letter) {
  ctx.unsubscribe(letter.from);

  if (!ctx.hasSubs()) {
    clearTimeout(ctx.get(TICK));
    ctx["delete"](TICK);
    ctx["delete"](HIGH_WATER_MARK);
  }
}, _HANDLERS$1);

var spawnEvents = function spawnEvents(key) {
  return utilActor.spawn(HANDLERS$1, key);
};

function events(key) {
  return {
    subscribe: function subscribe(callback) {
      return utilActor.subscriber(key, spawnEvents, callback);
    }
  };
}

var addServices = function addServices(services) {
  if (services === void 0) {
    services = [];
  }

  try {
    return Promise.resolve(config$1.config.get("discovery.authn.endpoint")).then(function (endpoint) {
      utilInvariant.invariant(Boolean(endpoint), "\"discovery.authn.endpoint\" in config must be defined.");
      return Promise.resolve(config$1.config.get("discovery.authn.include", [])).then(function (include) {
        var url = new URL(endpoint);
        return fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            fclVersion: VERSION,
            include: include
          })
        }).then(function (d) {
          return d.json();
        }).then(function (json) {
          return [].concat(services, json);
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var asyncPipe = function asyncPipe() {
  var _arguments = arguments;
  return function (input) {
    return [].slice.call(_arguments).reduce(function (chain, fn) {
      return chain.then(fn);
    }, Promise.resolve(input));
  };
};

function addExtensions(services) {
  if (services === void 0) {
    services = [];
  }

  var extensions = window.fcl_extensions || [];
  return [].concat(extensions, services);
}

function filterServicesByType(services, type) {
  if (services === void 0) {
    services = [];
  }

  return services.filter(function (service) {
    return service.type === type;
  });
}

var getServices = function getServices(_ref) {
  var type = _ref.type;
  return asyncPipe(addServices, addExtensions, function (s) {
    return filterServicesByType(s, type);
  })([]);
};

var _HANDLERS;
var NAME = "authn";
var RESULTS = "results";
var SNAPSHOT = "SNAPSHOT";
var UPDATED = "UPDATED";

var warn = function warn(fact, msg) {
  if (fact) {
    console.warn("\n      %cFCL Warning\n      ============================\n      " + msg + "\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      ", "font-weight:bold;font-family:monospace;");
  }
};

var HANDLERS = (_HANDLERS = {}, _HANDLERS[utilActor.INIT] = function (ctx) {
  try {
    warn(typeof window === "undefined", '"fcl.discovery" is only available in the browser.');
    return Promise.resolve(getServices({
      type: NAME
    })).then(function (services) {
      ctx.put(RESULTS, services);
    });
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS[utilActor.SUBSCRIBE] = function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED, _extends$2({}, ctx.all()));
}, _HANDLERS[utilActor.UNSUBSCRIBE] = function (ctx, letter) {
  return ctx.unsubscribe(letter.from);
}, _HANDLERS[SNAPSHOT] = function (ctx, letter) {
  try {
    return Promise.resolve(letter.reply(_extends$2({}, ctx.all())));
  } catch (e) {
    return Promise.reject(e);
  }
}, _HANDLERS);

var spawnProviders = function spawnProviders() {
  return utilActor.spawn(HANDLERS, NAME);
};

var authn = {
  subscribe: function subscribe(cb) {
    return utilActor.subscriber(NAME, spawnProviders, cb);
  },
  snapshot: function snapshot() {
    return utilActor.snapshoter(NAME, spawnProviders);
  }
};

var discovery = {
  authn: authn
};

var authenticate = function authenticate(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return currentUser().authenticate(opts);
};
var unauthenticate = function unauthenticate() {
  return currentUser().unauthenticate();
};
var reauthenticate = function reauthenticate(opts) {
  if (opts === void 0) {
    opts = {};
  }

  currentUser().unauthenticate();
  return currentUser().authenticate(opts);
};
var signUp = function signUp(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return currentUser().authenticate(opts);
};
var logIn = function logIn(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return currentUser().authenticate(opts);
};
var authz = currentUser().authorization;
var t = t__namespace;

Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function () { return config$1.config; }
});
Object.defineProperty(exports, 'TestUtils', {
  enumerable: true,
  get: function () { return sdk.TestUtils; }
});
Object.defineProperty(exports, 'account', {
  enumerable: true,
  get: function () { return sdk.account; }
});
Object.defineProperty(exports, 'arg', {
  enumerable: true,
  get: function () { return sdk.arg; }
});
Object.defineProperty(exports, 'args', {
  enumerable: true,
  get: function () { return sdk.args; }
});
Object.defineProperty(exports, 'atBlockHeight', {
  enumerable: true,
  get: function () { return sdk.atBlockHeight; }
});
Object.defineProperty(exports, 'atBlockId', {
  enumerable: true,
  get: function () { return sdk.atBlockId; }
});
Object.defineProperty(exports, 'authorization', {
  enumerable: true,
  get: function () { return sdk.authorization; }
});
Object.defineProperty(exports, 'authorizations', {
  enumerable: true,
  get: function () { return sdk.authorizations; }
});
Object.defineProperty(exports, 'block', {
  enumerable: true,
  get: function () { return sdk.block; }
});
Object.defineProperty(exports, 'build', {
  enumerable: true,
  get: function () { return sdk.build; }
});
Object.defineProperty(exports, 'createSignableVoucher', {
  enumerable: true,
  get: function () { return sdk.createSignableVoucher; }
});
Object.defineProperty(exports, 'decode', {
  enumerable: true,
  get: function () { return sdk.decode; }
});
Object.defineProperty(exports, 'getAccount', {
  enumerable: true,
  get: function () { return sdk.getAccount; }
});
Object.defineProperty(exports, 'getBlock', {
  enumerable: true,
  get: function () { return sdk.getBlock; }
});
Object.defineProperty(exports, 'getBlockHeader', {
  enumerable: true,
  get: function () { return sdk.getBlockHeader; }
});
Object.defineProperty(exports, 'getCollection', {
  enumerable: true,
  get: function () { return sdk.getCollection; }
});
Object.defineProperty(exports, 'getEvents', {
  enumerable: true,
  get: function () { return sdk.getEvents; }
});
Object.defineProperty(exports, 'getEventsAtBlockHeightRange', {
  enumerable: true,
  get: function () { return sdk.getEventsAtBlockHeightRange; }
});
Object.defineProperty(exports, 'getEventsAtBlockIds', {
  enumerable: true,
  get: function () { return sdk.getEventsAtBlockIds; }
});
Object.defineProperty(exports, 'getTransaction', {
  enumerable: true,
  get: function () { return sdk.getTransaction; }
});
Object.defineProperty(exports, 'getTransactionStatus', {
  enumerable: true,
  get: function () { return sdk.getTransactionStatus; }
});
Object.defineProperty(exports, 'invariant', {
  enumerable: true,
  get: function () { return sdk.invariant; }
});
Object.defineProperty(exports, 'isBad', {
  enumerable: true,
  get: function () { return sdk.isBad; }
});
Object.defineProperty(exports, 'isOk', {
  enumerable: true,
  get: function () { return sdk.isOk; }
});
Object.defineProperty(exports, 'limit', {
  enumerable: true,
  get: function () { return sdk.limit; }
});
Object.defineProperty(exports, 'param', {
  enumerable: true,
  get: function () { return sdk.param; }
});
Object.defineProperty(exports, 'params', {
  enumerable: true,
  get: function () { return sdk.params; }
});
Object.defineProperty(exports, 'payer', {
  enumerable: true,
  get: function () { return sdk.payer; }
});
Object.defineProperty(exports, 'ping', {
  enumerable: true,
  get: function () { return sdk.ping; }
});
Object.defineProperty(exports, 'pipe', {
  enumerable: true,
  get: function () { return sdk.pipe; }
});
Object.defineProperty(exports, 'proposer', {
  enumerable: true,
  get: function () { return sdk.proposer; }
});
Object.defineProperty(exports, 'ref', {
  enumerable: true,
  get: function () { return sdk.ref; }
});
Object.defineProperty(exports, 'script', {
  enumerable: true,
  get: function () { return sdk.script; }
});
Object.defineProperty(exports, 'send', {
  enumerable: true,
  get: function () { return sdk.send; }
});
Object.defineProperty(exports, 'transaction', {
  enumerable: true,
  get: function () { return sdk.transaction; }
});
Object.defineProperty(exports, 'validator', {
  enumerable: true,
  get: function () { return sdk.validator; }
});
Object.defineProperty(exports, 'voucherIntercept', {
  enumerable: true,
  get: function () { return sdk.voucherIntercept; }
});
Object.defineProperty(exports, 'voucherToTxId', {
  enumerable: true,
  get: function () { return sdk.voucherToTxId; }
});
Object.defineProperty(exports, 'why', {
  enumerable: true,
  get: function () { return sdk.why; }
});
Object.defineProperty(exports, 'display', {
  enumerable: true,
  get: function () { return utilAddress.display; }
});
Object.defineProperty(exports, 'sansPrefix', {
  enumerable: true,
  get: function () { return utilAddress.sansPrefix; }
});
Object.defineProperty(exports, 'withPrefix', {
  enumerable: true,
  get: function () { return utilAddress.withPrefix; }
});
Object.defineProperty(exports, 'cadence', {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
Object.defineProperty(exports, 'cdc', {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
exports.AppUtils = index;
exports.VERSION = VERSION;
exports.WalletUtils = index$1;
exports.authenticate = authenticate;
exports.authz = authz;
exports.currentUser = currentUser;
exports.discovery = discovery;
exports.events = events;
exports.logIn = logIn;
exports.mutate = mutate;
exports.query = query;
exports.reauthenticate = reauthenticate;
exports.serialize = serialize;
exports.signUp = signUp;
exports.t = t;
exports.tx = transaction;
exports.unauthenticate = unauthenticate;
exports.verifyUserSignatures = verifyUserSignatures;
//# sourceMappingURL=fcl.js.map
