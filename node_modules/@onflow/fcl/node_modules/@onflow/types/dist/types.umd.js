(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.types = {}));
}(this, (function (exports) {
  var type = function type(label, asArgument, asInjection) {
    return {
      label: label,
      asArgument: asArgument,
      asInjection: asInjection
    };
  };

  var isArray = function isArray(d) {
    return Array.isArray(d);
  };

  var isObj = function isObj(d) {
    return typeof d === "object";
  };

  var isNull = function isNull(d) {
    return d == null;
  };

  var isBoolean = function isBoolean(d) {
    return typeof d === "boolean";
  };

  var isNumber = function isNumber(d) {
    return typeof d === "number";
  };

  var isInteger = function isInteger(d) {
    return Number.isInteger(d);
  };

  var isString = function isString(d) {
    return typeof d === "string";
  };

  var throwTypeError = function throwTypeError(msg) {
    throw new Error("Type Error: " + msg);
  };

  var numberValuesDeprecationNotice = function numberValuesDeprecationNotice(type) {
    console.error(("\n          %c@onflow/types Deprecation Notice\n          ========================\n\n          Passing in Number as value for " + type + " is deprecated and will cease to work in future releases of @onflow/types.\n          Going forward, use String as value for " + type + ". \n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number\n\n          =======================\n        ").replace(/\n\s+/g, "\n").trim(), "font-weight:bold;font-family:monospace;");
  };

  var Identity = type("Identity", function (v) {
    return v;
  }, function (v) {
    return v;
  });
  var UInt = type("UInt", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt");
      return {
        type: "UInt",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt",
        value: v
      };
    }

    throwTypeError("Expected Positive Integer for type Unsigned Int");
  }, function (v) {
    return v;
  });
  var Int = type("Int", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int");
      return {
        type: "Int",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int",
        value: v
      };
    }

    throwTypeError("Expected Integer for type Int");
  }, function (v) {
    return v;
  });
  var UInt8 = type("UInt8", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt8");
      return {
        type: "UInt8",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt8",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt8");
  }, function (v) {
    return v;
  });
  var Int8 = type("Int8", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int8");
      return {
        type: "Int8",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int8",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int8");
  }, function (v) {
    return v;
  });
  var UInt16 = type("UInt16", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt16");
      return {
        type: "UInt16",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt16",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt16");
  }, function (v) {
    return v;
  });
  var Int16 = type("Int16", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int16");
      return {
        type: "Int16",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int16",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int16");
  }, function (v) {
    return v;
  });
  var UInt32 = type("UInt32", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt32");
      return {
        type: "UInt32",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt32",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt32");
  }, function (v) {
    return v;
  });
  var Int32 = type("Int32", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int32");
      return {
        type: "Int32",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int32",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int32");
  }, function (v) {
    return v;
  });
  var UInt64 = type("UInt64", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt64");
      return {
        type: "UInt64",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt64",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt64");
  }, function (v) {
    return v;
  });
  var Int64 = type("Int64", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int64");
      return {
        type: "Int64",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int64",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int64");
  }, function (v) {
    return v;
  });
  var UInt128 = type("UInt128", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt128");
      return {
        type: "UInt128",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt128",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt128");
  }, function (v) {
    return v;
  });
  var Int128 = type("Int128", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int128");
      return {
        type: "Int128",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int128",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int128");
  }, function (v) {
    return v;
  });
  var UInt256 = type("UInt256", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt256");
      return {
        type: "UInt256",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "UInt256",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt256");
  }, function (v) {
    return v;
  });
  var Int256 = type("Int256", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int256");
      return {
        type: "Int256",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Int256",
        value: v
      };
    }

    throwTypeError("Expected integer for Int256");
  }, function (v) {
    return v;
  });
  var Word8 = type("Word8", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word8");
      return {
        type: "Word8",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Word8",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word8");
  }, function (v) {
    return v;
  });
  var Word16 = type("Word16", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word16");
      return {
        type: "Word16",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Word16",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word16");
  }, function (v) {
    return v;
  });
  var Word32 = type("Word32", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word32");
      return {
        type: "Word32",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Word32",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word32");
  }, function (v) {
    return v;
  });
  var Word64 = type("Word64", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word64");
      return {
        type: "Word64",
        value: v.toString()
      };
    }

    if (isString(v)) {
      return {
        type: "Word64",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word64");
  }, function (v) {
    return v;
  });

  var UFix64AndFix64NumberDeprecationNotice = function UFix64AndFix64NumberDeprecationNotice() {
    console.error("\n          %c@onflow/types Deprecation Notice\n          ========================\n\n          Passing in Numbers as values for Fix64 and UFix64 types is deprecated and will cease to work in future releases of @onflow/types.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number\n\n          =======================\n        ".replace(/\n\s+/g, "\n").trim(), "font-weight:bold;font-family:monospace;");
  };

  var UFix64 = type("UFix64", function (v) {
    if (isString(v)) {
      var vParts = v.split(".");

      if (vParts.length !== 2) {
        throwTypeError("Expected one decimal but found " + vParts.length + " in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers");
      }

      if (vParts[1].length == 0 || vParts[1].length > 8) {
        throwTypeError("Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found " + vParts[1].length + " digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers");
      }

      return {
        type: "UFix64",
        value: v
      };
    } else if (isNumber(v)) {
      UFix64AndFix64NumberDeprecationNotice();
      return {
        type: "UFix64",
        value: v.toString()
      };
    }

    throwTypeError("Expected String for UFix64");
  }, function (v) {
    return v;
  });
  var Fix64 = type("Fix64", function (v) {
    if (isString(v)) {
      var vParts = v.split(".");

      if (vParts.length !== 2) {
        throwTypeError("Expected one decimal but found " + vParts.length + " in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers");
      }

      if (vParts[1].length == 0 || vParts[1].length > 8) {
        throwTypeError("Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found " + vParts[1].length + " digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers");
      }

      return {
        type: "Fix64",
        value: v
      };
    } else if (isNumber(v)) {
      UFix64AndFix64NumberDeprecationNotice();
      return {
        type: "Fix64",
        value: v.toString()
      };
    }

    throwTypeError("Expected String for Fix64");
  }, function (v) {
    return v;
  });
  var String = type("String", function (v) {
    if (isString(v)) return {
      type: "String",
      value: v
    };
    throwTypeError("Expected String for type String");
  }, function (v) {
    return v;
  });
  var Character = type("Character", function (v) {
    if (isString(v)) return {
      type: "Character",
      value: v
    };
    throwTypeError("Expected Character for type Character");
  }, function (v) {
    return v;
  });
  var Bool = type("Bool", function (v) {
    if (isBoolean(v)) return {
      type: "Bool",
      value: v
    };
    throwTypeError("Expected Boolean for type Bool");
  }, function (v) {
    return v;
  });
  var Address = type("Address", function (v) {
    if (isString(v)) return {
      type: "Address",
      value: v
    };
    throwTypeError("Expected Address for type Address");
  }, function (v) {
    return v;
  });
  var Void = type("Void", function (v) {
    if (!v || isNull(v)) return {
      type: "Void"
    };
    throwTypeError("Expected Void for type Void");
  }, function (v) {
    return v;
  });
  var Optional = function Optional(children) {
    return type("Optional", function (v) {
      return {
        type: "Optional",
        value: isNull(v) ? null : children.asArgument(v)
      };
    }, function (v) {
      return v;
    });
  };
  var Reference = type("Reference", function (v) {
    if (isObj(v)) return {
      type: "Reference",
      value: v
    };
    throwTypeError("Expected Object for type Reference");
  }, function (v) {
    return v;
  });
  var _Array = function _Array(children) {
    if (children === void 0) {
      children = [];
    }

    return type("Array", function (v) {
      return {
        type: "Array",
        value: isArray(children) ? children.map(function (c, i) {
          return c.asArgument(v[i]);
        }) : v.map(function (x) {
          return children.asArgument(x);
        })
      };
    }, function (v) {
      return v;
    });
  };
  var Dictionary = function Dictionary(children) {
    if (children === void 0) {
      children = [];
    }

    return type("Dictionary", function (v) {
      if (isObj(v)) return {
        type: "Dictionary",
        value: isArray(children) ? children.map(function (c, i) {
          return {
            key: c.key.asArgument(v[i].key),
            value: c.value.asArgument(v[i].value)
          };
        }) : isArray(v) ? v.map(function (x) {
          return {
            key: children.key.asArgument(x.key),
            value: children.value.asArgument(x.value)
          };
        }) : [{
          key: children.key.asArgument(v.key),
          value: children.value.asArgument(v.value)
        }]
      };
      throwTypeError("Expected Object for type Dictionary");
    }, function (v) {
      return v;
    });
  };
  var Event = function Event(id, fields) {
    if (fields === void 0) {
      fields = [];
    }

    return type("Event", function (v) {
      if (isObj(v)) return {
        type: "Event",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map(function (c, i) {
            return {
              name: v.fields[i].name,
              value: c.value.asArgument(v.fields[i].value)
            };
          }) : v.fields.map(function (x) {
            return {
              name: x.name,
              value: fields.value.asArgument(x.value)
            };
          })
        }
      };
      throwTypeError("Expected Object for type Event");
    }, function (v) {
      return v;
    });
  };
  var Resource = function Resource(id, fields) {
    if (fields === void 0) {
      fields = [];
    }

    return type("Resource", function (v) {
      if (isObj(v)) return {
        type: "Resource",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map(function (c, i) {
            return {
              name: v.fields[i].name,
              value: c.value.asArgument(v.fields[i].value)
            };
          }) : v.fields.map(function (x) {
            return {
              name: x.name,
              value: fields.value.asArgument(x.value)
            };
          })
        }
      };
      throwTypeError("Expected Object for type Resource");
    }, function (v) {
      return v;
    });
  };
  var Struct = function Struct(id, fields) {
    if (fields === void 0) {
      fields = [];
    }

    return type("Struct", function (v) {
      if (isObj(v)) return {
        type: "Struct",
        value: {
          id: id,
          fields: isArray(fields) ? fields.map(function (c, i) {
            return {
              name: v.fields[i].name,
              value: c.value.asArgument(v.fields[i].value)
            };
          }) : v.fields.map(function (x) {
            return {
              name: x.name,
              value: fields.value.asArgument(x.value)
            };
          })
        }
      };
      throwTypeError("Expected Object for type Struct");
    }, function (v) {
      return v;
    });
  };
  var Path = type("Path", function (v) {
    if (isObj(v)) {
      if (!isString(v.domain)) {
        throwTypeError("Expected a string for the Path domain but found " + v.domain + ". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path");
      }

      if (!(v.domain === "storage" || v.domain === "private" || v.domain === "public")) {
        throwTypeError("Expected either \"storage\", \"private\" or \"public\" as the Path domain but found " + v.domain + ". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path");
      }

      if (!isString(v.identifier)) {
        throwTypeError("Expected a string for the Path identifier but found " + v.identifier + ". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path");
      }

      return {
        type: "Path",
        value: {
          domain: v.domain,
          identifier: v.identifier
        }
      };
    }

    throwTypeError("Expected Object for type Path");
  }, function (v) {
    return v;
  });

  exports.Address = Address;
  exports.Array = _Array;
  exports.Bool = Bool;
  exports.Character = Character;
  exports.Dictionary = Dictionary;
  exports.Event = Event;
  exports.Fix64 = Fix64;
  exports.Identity = Identity;
  exports.Int = Int;
  exports.Int128 = Int128;
  exports.Int16 = Int16;
  exports.Int256 = Int256;
  exports.Int32 = Int32;
  exports.Int64 = Int64;
  exports.Int8 = Int8;
  exports.Optional = Optional;
  exports.Path = Path;
  exports.Reference = Reference;
  exports.Resource = Resource;
  exports.String = String;
  exports.Struct = Struct;
  exports.UFix64 = UFix64;
  exports.UInt = UInt;
  exports.UInt128 = UInt128;
  exports.UInt16 = UInt16;
  exports.UInt256 = UInt256;
  exports.UInt32 = UInt32;
  exports.UInt64 = UInt64;
  exports.UInt8 = UInt8;
  exports.Void = Void;
  exports.Word16 = Word16;
  exports.Word32 = Word32;
  exports.Word64 = Word64;
  exports.Word8 = Word8;
  exports._Array = _Array;

})));
//# sourceMappingURL=types.umd.js.map
