import '@onflow/util-logger';
import { invariant as invariant$1 } from '@onflow/util-invariant';
import { config } from '@onflow/config';
export { config } from '@onflow/config';
import { Buffer, encode } from '@onflow/rlp';
import { send as send$1 } from '@onflow/transport-http';
import { sansPrefix, withPrefix } from '@onflow/util-address';
import { SHA3 } from 'sha3';
import { template } from '@onflow/util-template';
export { template as cadence, template as cdc } from '@onflow/util-template';

const buildWarningMessage = ({
  name,
  transitionsPath
}) => {
  console.warn(`
    %cFCL/SDK Deprecation Notice
    ============================
    The ${name} builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.
    You can learn more (including a guide on common transition paths) here: ${transitionsPath}
    ============================
  `, "font-weight:bold;font-family:monospace;");
};

const buildErrorMessage = ({
  name,
  transitionsPath
}) => {
  console.error(`
    %cFCL/SDK Deprecation Notice
    ============================
    The ${name} builder has been removed from the Flow JS-SDK/FCL.
    You can learn more (including a guide on common transition paths) here: ${transitionsPath}
    ============================
  `, "font-weight:bold;font-family:monospace;");
};

const warn = deprecated => buildWarningMessage(deprecated);

const error = deprecated => {
  buildErrorMessage(deprecated);
};

const deprecate = {
  warn,
  error
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const UNKNOWN
/*                       */
= "UNKNOWN";
const SCRIPT
/*                        */
= "SCRIPT";
const TRANSACTION
/*                   */
= "TRANSACTION";
const GET_TRANSACTION_STATUS
/*        */
= "GET_TRANSACTION_STATUS";
const GET_ACCOUNT
/*                   */
= "GET_ACCOUNT";
const GET_EVENTS
/*                    */
= "GET_EVENTS";
const PING
/*                          */
= "PING";
const GET_TRANSACTION
/*               */
= "GET_TRANSACTION";
const GET_BLOCK
/*                     */
= "GET_BLOCK";
const GET_BLOCK_HEADER
/*              */
= "GET_BLOCK_HEADER";
const GET_COLLECTION
/*                */
= "GET_COLLECTION";
const BAD
/* */
= "BAD";
const OK
/*  */
= "OK";
const ACCOUNT
/*  */
= "ACCOUNT";
const PARAM
/*    */
= "PARAM";
const ARGUMENT
/* */
= "ARGUMENT";
const AUTHORIZER
/* */
= "authorizer";
const PAYER
/*      */
= "payer";
const PROPOSER
/*   */
= "proposer";
const ACCT = `{
  "kind":"${ACCOUNT}",
  "tempId":null,
  "addr":null,
  "keyId":null,
  "sequenceNum":null,
  "signature":null,
  "signingFunction":null,
  "resolve":null,
  "role": {
    "proposer":false,
    "authorizer":false,
    "payer":false,
    "param":false
  }
}`;
const ARG = `{
  "kind":"${ARGUMENT}",
  "tempId":null,
  "value":null,
  "asArgument":null,
  "xform":null,
  "resolve": null,
  "resolveArgument": null
}`;
const IX = `{
  "tag":"${UNKNOWN}",
  "assigns":{},
  "status":"${OK}",
  "reason":null,
  "accounts":{},
  "params":{},
  "arguments":{},
  "message": {
    "cadence":null,
    "refBlock":null,
    "computeLimit":null,
    "proposer":null,
    "payer":null,
    "authorizations":[],
    "params":[],
    "arguments":[]
  },
  "proposer":null,
  "authorizations":[],
  "payer":[],
  "events": {
    "eventType":null,
    "start":null,
    "end":null,
    "blockIds":[]
  },
  "transaction": {
    "id":null
  },
  "block": {
    "id":null,
    "height":null,
    "isSealed":null
  },
  "account": {
    "addr":null
  },
  "collection": {
    "id":null
  }
}`;
const KEYS = new Set(Object.keys(JSON.parse(IX)));
const interaction = () => JSON.parse(IX);
const CHARS = "abcdefghijklmnopqrstuvwxyz0123456789".split("");

const randChar = () => CHARS[~~(Math.random() * CHARS.length)];

const uuid = () => Array.from({
  length: 10
}, randChar).join("");
const isNumber$1 = d => typeof d === "number";
const isArray$1 = d => Array.isArray(d);
const isObj = d => d !== null && typeof d === "object";
const isNull = d => d == null;
const isFn$3 = d => typeof d === "function";
const isInteraction = ix => {
  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;

  for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;

  return true;
};
const Ok = ix => {
  ix.status = OK;
  return ix;
};
const Bad = (ix, reason) => {
  ix.status = BAD;
  ix.reason = reason;
  return ix;
};

const makeIx = wat => ix => {
  ix.tag = wat;
  return Ok(ix);
};

const prepAccount = (acct, opts = {}) => ix => {
  invariant$1(typeof acct === "function" || typeof acct === "object", "prepAccount must be passed an authorization function or an account object");
  invariant$1(opts.role != null, "Account must have a role");
  const ACCOUNT = JSON.parse(ACCT);
  const role = opts.role;
  const tempId = uuid();
  if (acct.authorization && isFn$3(acct.authorization)) acct = {
    resolve: acct.authorization
  };
  if (!acct.authorization && isFn$3(acct)) acct = {
    resolve: acct
  };
  ix.accounts[tempId] = _extends({}, ACCOUNT, {
    tempId
  }, acct, {
    role: _extends({}, ACCOUNT.role, typeof acct.role === "object" ? acct.role : {}, {
      [role]: true
    })
  });

  if (role === AUTHORIZER) {
    ix.authorizations.push(tempId);
  } else if (role === PAYER) {
    ix.payer.push(tempId);
  } else {
    ix[role] = tempId;
  }

  return ix;
};
const makeArgument = arg => ix => {
  let tempId = uuid();
  ix.message.arguments.push(tempId);
  ix.arguments[tempId] = JSON.parse(ARG);
  ix.arguments[tempId].tempId = tempId;
  ix.arguments[tempId].value = arg.value;
  ix.arguments[tempId].asArgument = arg.asArgument;
  ix.arguments[tempId].xform = arg.xform;
  ix.arguments[tempId].resolve = arg.resolve;
  ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
  return Ok(ix);
};
const makeUnknown
/*                 */
= makeIx(UNKNOWN);
const makeScript
/*                  */
= makeIx(SCRIPT);
const makeTransaction
/*             */
= makeIx(TRANSACTION);
const makeGetTransactionStatus
/*    */
= makeIx(GET_TRANSACTION_STATUS);
const makeGetTransaction
/*          */
= makeIx(GET_TRANSACTION);
const makeGetAccount
/*              */
= makeIx(GET_ACCOUNT);
const makeGetEvents
/*               */
= makeIx(GET_EVENTS);
const makePing
/*                    */
= makeIx(PING);
const makeGetBlock
/*                */
= makeIx(GET_BLOCK);
const makeGetBlockHeader
/*          */
= makeIx(GET_BLOCK_HEADER);
const makeGetCollection
/*           */
= makeIx(GET_COLLECTION);

const is = wat => ix => ix.tag === wat;

const isUnknown
/*                 */
= is(UNKNOWN);
const isScript
/*                  */
= is(SCRIPT);
const isTransaction
/*             */
= is(TRANSACTION);
const isGetTransactionStatus
/*    */
= is(GET_TRANSACTION_STATUS);
const isGetTransaction
/*          */
= is(GET_TRANSACTION);
const isGetAccount
/*              */
= is(GET_ACCOUNT);
const isGetEvents
/*               */
= is(GET_EVENTS);
const isPing
/*                    */
= is(PING);
const isGetBlock
/*                */
= is(GET_BLOCK);
const isGetBlockHeader
/*          */
= is(GET_BLOCK_HEADER);
const isGetCollection
/*           */
= is(GET_COLLECTION);
const isOk
/*  */
= ix => ix.status === OK;
const isBad
/* */
= ix => ix.status === BAD;
const why
/*   */
= ix => ix.reason;
const isAccount
/*  */
= account => account.kind === ACCOUNT;
const isParam
/*    */
= param => param.kind === PARAM;
const isArgument
/* */
= argument => argument.kind === ARGUMENT;

const hardMode = ix => {
  for (let key of Object.keys(ix)) {
    if (!KEYS.has(key)) throw new Error(`"${key}" is an invalid root level Interaction property.`);
  }

  return ix;
};

const recPipe = async (ix, fns = []) => {
  try {
    ix = hardMode(await ix);
    if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);
    if (!fns.length) return ix;
    const [hd, ...rest] = fns;
    const cur = await hd;
    if (isFn$3(cur)) return recPipe(cur(ix), rest);
    if (isNull(cur) || !cur) return recPipe(ix, rest);
    if (isInteraction(cur)) return recPipe(cur, rest);
    throw new Error("Invalid Interaction Composition");
  } catch (e) {
    throw e;
  }
};

const pipe = (...args) => {
  const [arg1, arg2] = args;
  if (isArray$1(arg1) && arg2 == null) return d => pipe(d, arg1);
  return recPipe(arg1, arg2);
};

const identity$1 = v => v;

const get = (ix, key, fallback) => {
  return ix.assigns[key] == null ? fallback : ix.assigns[key];
};
const put = (key, value) => ix => {
  ix.assigns[key] = value;
  return Ok(ix);
};
const update = (key, fn = identity$1) => ix => {
  ix.assigns[key] = fn(ix.assigns[key], ix);
  return Ok(ix);
};
const destroy = key => ix => {
  delete ix.assigns[key];
  return Ok(ix);
};

var ixModule = {
  __proto__: null,
  UNKNOWN: UNKNOWN,
  SCRIPT: SCRIPT,
  TRANSACTION: TRANSACTION,
  GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,
  GET_ACCOUNT: GET_ACCOUNT,
  GET_EVENTS: GET_EVENTS,
  PING: PING,
  GET_TRANSACTION: GET_TRANSACTION,
  GET_BLOCK: GET_BLOCK,
  GET_BLOCK_HEADER: GET_BLOCK_HEADER,
  GET_COLLECTION: GET_COLLECTION,
  BAD: BAD,
  OK: OK,
  ACCOUNT: ACCOUNT,
  PARAM: PARAM,
  ARGUMENT: ARGUMENT,
  AUTHORIZER: AUTHORIZER,
  PAYER: PAYER,
  PROPOSER: PROPOSER,
  interaction: interaction,
  uuid: uuid,
  isNumber: isNumber$1,
  isArray: isArray$1,
  isObj: isObj,
  isNull: isNull,
  isFn: isFn$3,
  isInteraction: isInteraction,
  Ok: Ok,
  Bad: Bad,
  prepAccount: prepAccount,
  makeArgument: makeArgument,
  makeUnknown: makeUnknown,
  makeScript: makeScript,
  makeTransaction: makeTransaction,
  makeGetTransactionStatus: makeGetTransactionStatus,
  makeGetTransaction: makeGetTransaction,
  makeGetAccount: makeGetAccount,
  makeGetEvents: makeGetEvents,
  makePing: makePing,
  makeGetBlock: makeGetBlock,
  makeGetBlockHeader: makeGetBlockHeader,
  makeGetCollection: makeGetCollection,
  isUnknown: isUnknown,
  isScript: isScript,
  isTransaction: isTransaction,
  isGetTransactionStatus: isGetTransactionStatus,
  isGetTransaction: isGetTransaction,
  isGetAccount: isGetAccount,
  isGetEvents: isGetEvents,
  isPing: isPing,
  isGetBlock: isGetBlock,
  isGetBlockHeader: isGetBlockHeader,
  isGetCollection: isGetCollection,
  isOk: isOk,
  isBad: isBad,
  why: why,
  isAccount: isAccount,
  isParam: isParam,
  isArgument: isArgument,
  pipe: pipe,
  get: get,
  put: put,
  update: update,
  destroy: destroy
};

function build(fns = []) {
  return pipe(interaction(), fns);
}

const DEFAULT_RESPONSE = `{
    "tag":null,
    "transaction":null,
    "transactionStatus":null,
    "transactionId":null,
    "encodedData":null,
    "events":null,
    "account":null,
    "block":null,
    "blockHeader":null,
    "latestBlock":null,
    "collection":null
}`;
const response = () => JSON.parse(DEFAULT_RESPONSE);

function getBlock(isSealed = null) {
  return pipe([makeGetBlock, ix => {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

function getAccount(addr) {
  return pipe([makeGetAccount, ix => {
    ix.account.addr = sansPrefix(addr);
    return Ok(ix);
  }]);
}

const latestBlockDeprecationNotice = () => {
  console.error(`
          %c@onflow/decode Deprecation Notice
          ========================

          Operating upon data of the latestBlock field of the response object is deprecated and will no longer be recognized in future releases of @onflow/decode.
          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field

          =======================
        `.replace(/\n\s+/g, "\n").trim(), "font-weight:bold;font-family:monospace;");
};

const decodeImplicit = async i => i;

const decodeVoid = async () => null;

const decodeType = async type => {
  return type.staticType;
};

const decodePath = async path => {
  return {
    domain: path.domain,
    identifier: path.identifier
  };
};

const decodeCapability = async cap => {
  return {
    path: cap.path,
    address: cap.address,
    borrowType: cap.borrowType
  };
};

const decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;

const decodeReference = async v => ({
  address: v.address,
  type: v.type
});

const decodeArray = async (array, decoders, stack) => await Promise.all(array.map(v => new Promise(async res => res(await recurseDecode(v, decoders, [...stack, v.type])))));

const decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {
  acc = await acc;
  acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);
  return acc;
}, Promise.resolve({}));

const decodeComposite = async (composite, decoders, stack) => {
  const decoded = await composite.fields.reduce(async (acc, v) => {
    acc = await acc;
    acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);
    return acc;
  }, Promise.resolve({}));
  const decoder = composite.id && decoderLookup(decoders, composite.id);
  return decoder ? await decoder(decoded) : decoded;
};

const defaultDecoders = {
  UInt: decodeImplicit,
  Int: decodeImplicit,
  UInt8: decodeImplicit,
  Int8: decodeImplicit,
  UInt16: decodeImplicit,
  Int16: decodeImplicit,
  UInt32: decodeImplicit,
  Int32: decodeImplicit,
  UInt64: decodeImplicit,
  Int64: decodeImplicit,
  UInt128: decodeImplicit,
  Int128: decodeImplicit,
  UInt256: decodeImplicit,
  Int256: decodeImplicit,
  Word8: decodeImplicit,
  Word16: decodeImplicit,
  Word32: decodeImplicit,
  Word64: decodeImplicit,
  UFix64: decodeImplicit,
  Fix64: decodeImplicit,
  String: decodeImplicit,
  Character: decodeImplicit,
  Bool: decodeImplicit,
  Address: decodeImplicit,
  Void: decodeVoid,
  Optional: decodeOptional,
  Reference: decodeReference,
  Array: decodeArray,
  Dictionary: decodeDictionary,
  Event: decodeComposite,
  Resource: decodeComposite,
  Struct: decodeComposite,
  Enum: decodeComposite,
  Type: decodeType,
  Path: decodePath,
  Capability: decodeCapability
};

const decoderLookup = (decoders, lookup) => {
  const found = Object.keys(decoders).find(decoder => {
    if (/^\/.*\/$/.test(decoder)) {
      const reg = new RegExp(decoder.substring(1, decoder.length - 1));
      return reg.test(lookup);
    }

    return decoder === lookup;
  });
  return lookup && found && decoders[found];
};

const recurseDecode = async (decodeInstructions, decoders, stack) => {
  let decoder = decoderLookup(decoders, decodeInstructions.type);
  if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(".")}`);
  return await decoder(decodeInstructions.value, decoders, stack);
};

const decode$1 = async (decodeInstructions, customDecoders = {}, stack = []) => {
  let decoders = _extends({}, defaultDecoders, customDecoders);

  return await recurseDecode(decodeInstructions, decoders, stack);
};
const decodeResponse = async (response, customDecoders = {}) => {
  let decoders = _extends({}, defaultDecoders, customDecoders);

  if (response.encodedData) {
    return await decode$1(response.encodedData, decoders);
  } else if (response.transactionStatus) {
    return _extends({}, response.transactionStatus, {
      events: await Promise.all(response.transactionStatus.events.map(async function decodeEvents(e) {
        return {
          type: e.type,
          transactionId: e.transactionId,
          transactionIndex: e.transactionIndex,
          eventIndex: e.eventIndex,
          data: await decode$1(e.payload, decoders)
        };
      }))
    });
  } else if (response.transaction) {
    return response.transaction;
  } else if (response.events) {
    return await Promise.all(response.events.map(async function decodeEvents(e) {
      return {
        blockId: e.blockId,
        blockHeight: e.blockHeight,
        blockTimestamp: e.blockTimestamp,
        type: e.type,
        transactionId: e.transactionId,
        transactionIndex: e.transactionIndex,
        eventIndex: e.eventIndex,
        data: await decode$1(e.payload, decoders)
      };
    }));
  } else if (response.account) {
    return response.account;
  } else if (response.block) {
    return response.block;
  } else if (response.blockHeader) {
    return response.blockHeader;
  } else if (response.latestBlock) {
    latestBlockDeprecationNotice();
    return response.latestBlock;
  } else if (response.transactionId) {
    return response.transactionId;
  } else if (response.collection) {
    return response.collection;
  }

  return null;
};

async function getRefId(opts) {
  const node = await config().get("accessNode.api");
  const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
  invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
  var ix;
  ix = await pipe(interaction(), [getBlock()]);
  ix = await sendFn(ix, {
    config,
    response,
    Buffer,
    ix: ixModule
  }, {
    node
  });
  ix = await decodeResponse(ix);
  return ix.id;
}

function resolveRefBlockId(opts) {
  return async ix => {
    if (!isTransaction(ix)) return Ok(ix);
    if (ix.message.refBlock) return Ok(ix);
    ix.message.refBlock = await getRefId();
    return Ok(ix);
  };
}

const isFn$2 = v => typeof v === "function";

const isString$1 = v => typeof v === "string";

async function resolveCadence(ix) {
  if (isTransaction(ix) || isScript(ix)) {
    var cadence = get(ix, "ix.cadence");
    invariant$1(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");
    if (isFn$2(cadence)) cadence = await cadence({});
    invariant$1(isString$1(cadence), "Cadence needs to be a string at this point.");
    ix.message.cadence = await config().where(/^0x/).then(d => Object.entries(d).reduce((cadence, [key, value]) => {
      const regex = new RegExp("(\\b" + key + "\\b)", 'g');
      return cadence.replace(regex, value);
    }, cadence));
  }

  return ix;
}

const isFn$1 = v => typeof v === "function";

function cast(arg) {
  // prettier-ignore
  invariant$1(typeof arg.xform != null, `No type specified for argument: ${arg.value}`);
  if (isFn$1(arg.xform)) return arg.xform(arg.value);
  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value); // prettier-ignore

  invariant$1(false, `Invalid Argument`, arg);
}

async function handleArgResolution(arg, depth = 3) {
  invariant$1(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg.tempId}`);

  if (isFn$1(arg.resolveArgument)) {
    const resolvedArg = await arg.resolveArgument();
    return handleArgResolution(resolvedArg, depth - 1);
  } else {
    return arg;
  }
}

async function resolveArguments(ix) {
  if (isTransaction(ix) || isScript(ix)) {
    for (let [id, arg] of Object.entries(ix.arguments)) {
      const res = await handleArgResolution(arg);
      ix.arguments[id].asArgument = cast(res);
    }
  }

  return ix;
}

const encodeTransactionPayload = tx => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
const encodeTransactionEnvelope = tx => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
const encodeTxIdFromVoucher = voucher => sha3_256(rlpEncode(prepareVoucher(voucher)));

const rightPaddedHexBuffer = (value, pad) => Buffer.from(value.padEnd(pad * 2, 0), "hex");

const leftPaddedHexBuffer = (value, pad) => Buffer.from(value.padStart(pad * 2, 0), "hex");

const TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");

const prependTransactionDomainTag = tx => TRANSACTION_DOMAIN_TAG + tx;

const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);

const blockBuffer = block => leftPaddedHexBuffer(block, 32);

const argumentToString = arg => Buffer.from(JSON.stringify(arg), "utf8");

const scriptBuffer = script => Buffer.from(script, "utf8");

const signatureBuffer = signature => Buffer.from(signature, "hex");

const rlpEncode = v => {
  return encode(v).toString("hex");
};

const sha3_256 = msg => {
  const sha = new SHA3(256);
  sha.update(Buffer.from(msg, "hex"));
  return sha.digest().toString("hex");
};

const preparePayload = tx => {
  validatePayload(tx);
  return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer(sansPrefix(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(sansPrefix(tx.payer)), tx.authorizers.map(authorizer => addressBuffer(sansPrefix(authorizer)))];
};

const prepareEnvelope = tx => {
  validateEnvelope(tx);
  return [preparePayload(tx), preparePayloadSignatures(tx)];
};

const preparePayloadSignatures = tx => {
  const signers = collectSigners(tx);
  return tx.payloadSigs.map(sig => {
    return {
      signerIndex: signers.get(sig.address),
      keyId: sig.keyId,
      sig: sig.sig
    };
  }).sort((a, b) => {
    if (a.signerIndex > b.signerIndex) return 1;
    if (a.signerIndex < b.signerIndex) return -1;
    if (a.keyId > b.keyId) return 1;
    if (a.keyId < b.keyId) return -1;
  }).map(sig => {
    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
  });
};

const collectSigners = tx => {
  const signers = new Map();
  let i = 0;

  const addSigner = addr => {
    if (!signers.has(addr)) {
      signers.set(addr, i);
      i++;
    }
  };

  addSigner(tx.proposalKey.address);
  addSigner(tx.payer);
  tx.authorizers.forEach(addSigner);
  return signers;
};

const prepareVoucher = voucher => {
  validateVoucher(voucher);
  const signers = collectSigners(voucher);

  const prepareSigs = sigs => {
    return sigs.map(({
      address,
      keyId,
      sig
    }) => {
      return {
        signerIndex: signers.get(address),
        keyId,
        sig
      };
    }).sort((a, b) => {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
    }).map(sig => {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };

  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(sansPrefix(voucher.payer)), voucher.authorizers.map(authorizer => addressBuffer(sansPrefix(authorizer)))], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
};

const validatePayload = tx => {
  payloadFields.forEach(field => checkField(tx, field));
  proposalKeyFields.forEach(field => checkField(tx.proposalKey, field, "proposalKey"));
};

const validateEnvelope = tx => {
  payloadSigsFields.forEach(field => checkField(tx, field));
  tx.payloadSigs.forEach((sig, index) => {
    payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
  });
};

const validateVoucher = voucher => {
  payloadFields.forEach(field => checkField(voucher, field));
  proposalKeyFields.forEach(field => checkField(voucher.proposalKey, field, "proposalKey"));
  payloadSigsFields.forEach(field => checkField(voucher, field));
  voucher.payloadSigs.forEach((sig, index) => {
    payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
  });
  envelopeSigsFields.forEach(field => checkField(voucher, field));
  voucher.envelopeSigs.forEach((sig, index) => {
    envelopeSigFields.forEach(field => checkField(sig, field, "envelopeSigs", index));
  });
};

const isNumber = v => typeof v === "number";

const isString = v => typeof v === "string";

const isObject = v => v !== null && typeof v === "object";

const isArray = v => isObject(v) && v instanceof Array;

const payloadFields = [{
  name: "cadence",
  check: isString
}, {
  name: "arguments",
  check: isArray
}, {
  name: "refBlock",
  check: isString,
  defaultVal: "0"
}, {
  name: "computeLimit",
  check: isNumber
}, {
  name: "proposalKey",
  check: isObject
}, {
  name: "payer",
  check: isString
}, {
  name: "authorizers",
  check: isArray
}];
const proposalKeyFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sequenceNum",
  check: isNumber
}];
const payloadSigsFields = [{
  name: "payloadSigs",
  check: isArray
}];
const payloadSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
const envelopeSigsFields = [{
  name: "envelopeSigs",
  check: isArray
}];
const envelopeSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];

const checkField = (obj, field, base, index) => {
  const {
    name,
    check,
    defaultVal
  } = field;
  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
  if (obj[name] == null) throw missingFieldError(name, base, index);
  if (!check(obj[name])) throw invalidFieldError(name, base, index);
};

const printFieldName = (field, base, index) => {
  if (!!base) return index == null ? `${base}.${field}` : `${base}.${index}.${field}`;
  return field;
};

const missingFieldError = (field, base, index) => new Error(`Missing field ${printFieldName(field, base, index)}`);

const invalidFieldError = (field, base, index) => new Error(`Invalid field ${printFieldName(field, base, index)}`);

function findInsideSigners(ix) {
  // Inside Signers Are: (authorizers + proposer) - payer
  let inside = new Set(ix.authorizations);
  inside.add(ix.proposer);

  if (Array.isArray(ix.payer)) {
    ix.payer.forEach(p => inside.delete(p));
  } else {
    inside.delete(ix.payer);
  }

  return Array.from(inside);
}
function findOutsideSigners(ix) {
  // Outside Signers Are: (payer)
  let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
  return Array.from(outside);
}
const createSignableVoucher = ix => {
  const buildAuthorizers = () => {
    const authorizations = ix.authorizations.map(cid => withPrefix(ix.accounts[cid].addr)).reduce((prev, current) => {
      return prev.find(item => item === current) ? prev : [...prev, current];
    }, []);
    return authorizations[0] ? authorizations : [];
  };

  const buildInsideSigners = () => findInsideSigners(ix).map(id => ({
    address: withPrefix(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));

  const buildOutsideSigners = () => findOutsideSigners(ix).map(id => ({
    address: withPrefix(ix.accounts[id].addr),
    keyId: ix.accounts[id].keyId,
    sig: ix.accounts[id].signature
  }));

  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
    proposalKey: {
      address: withPrefix(ix.accounts[ix.proposer].addr),
      keyId: ix.accounts[ix.proposer].keyId,
      sequenceNum: ix.accounts[ix.proposer].sequenceNum
    },
    payer: withPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
    authorizers: buildAuthorizers(),
    payloadSigs: buildInsideSigners(),
    envelopeSigs: buildOutsideSigners()
  };
};
const voucherToTxId = voucher => {
  return encodeTxIdFromVoucher(voucher);
};

const isFn = v => typeof v === "function";

function buildPreSignable(acct, ix) {
  try {
    return {
      f_type: "PreSignable",
      f_vsn: "1.0.1",
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildPreSignable", error);
    throw error;
  }
}

async function collectAccounts(ix, accounts, last, depth = 3) {
  invariant$1(depth, "Account Resolve Recursion Limit Exceeded", {
    ix,
    accounts
  });
  let authorizations = [];

  for (let ax of accounts) {
    var old = last || ax;
    if (isFn(ax.resolve)) ax = await ax.resolve(ax, buildPreSignable(ax, ix));

    if (Array.isArray(ax)) {
      await collectAccounts(ix, ax, old, depth - 1);
    } else {
      if (ax.addr != null && ax.keyId != null) {
        ax.tempId = `${ax.addr}-${ax.keyId}`;
      }

      ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;
      ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;
      ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;
      ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;

      if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {
        ix.proposer = ax.tempId;
      }

      if (ix.accounts[ax.tempId].role.payer) {
        if (Array.isArray(ix.payer)) {
          ix.payer = Array.from(new Set([...ix.payer, ax.tempId].map(d => d === old.tempId ? ax.tempId : d)));
        } else {
          ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(d => d === old.tempId ? ax.tempId : d)));
        }

        if (ix.payer.length > 1) {
          // remove payer dups based on addr and keyId
          const dupList = [];
          const payerAccts = [];
          ix.payer = ix.payer.reduce((g, tempId) => {
            const {
              addr,
              keyId
            } = ix.accounts[tempId];
            const key = `${addr}-${keyId}`;
            payerAccts.push(addr);
            if (dupList.includes(key)) return g;
            dupList.push(key);
            return [...g, tempId];
          }, []);
          const multiAccts = Array.from(new Set(payerAccts));

          if (multiAccts.length > 1) {
            throw new Error("Payer can not be different accounts");
          }
        }
      }

      if (ix.accounts[ax.tempId].role.authorizer) {
        if (last) {
          // do group replacement
          authorizations = Array.from(new Set([...authorizations, ax.tempId]));
        } else {
          // do 1-1 replacement
          ix.authorizations = ix.authorizations.map(d => d === old.tempId ? ax.tempId : d);
        }
      }
    }

    if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];
  }

  if (last) {
    // complete (flatmap) group replacement
    ix.authorizations = ix.authorizations.map(d => d === last.tempId ? authorizations : d).reduce((prev, curr) => Array.isArray(curr) ? [...prev, ...curr] : [...prev, curr], []);
  }
}

async function resolveAccounts(ix) {
  if (isTransaction(ix)) {
    if (!Array.isArray(ix.payer)) {
      console.warn(`
        %cFCL Warning
        ============================
        "ix.payer" must be an array. Support for ix.payer as a singular is deprecated,
        see changelog for more info.
        ============================
        `, "font-weight:bold;font-family:monospace;");
    }

    try {
      await collectAccounts(ix, Object.values(ix.accounts));
      await collectAccounts(ix, Object.values(ix.accounts));
    } catch (error) {
      console.error("=== SAD PANDA ===\n\n", error, "\n\n=== SAD PANDA ===");
      throw error;
    }
  }

  return ix;
}

async function resolveSignatures(ix) {
  if (isTransaction(ix)) {
    try {
      let insideSigners = findInsideSigners(ix);
      const insidePayload = encodeTransactionPayload(prepForEncoding(ix));
      await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));
      let outsideSigners = findOutsideSigners(ix);
      const outsidePayload = encodeTransactionEnvelope(_extends({}, prepForEncoding(ix), {
        payloadSigs: insideSigners.map(id => ({
          address: ix.accounts[id].addr,
          keyId: ix.accounts[id].keyId,
          sig: ix.accounts[id].signature
        }))
      }));
      await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));
    } catch (error) {
      console.error("Signatures", error, {
        ix
      });
      throw error;
    }
  }

  return ix;
}

function fetchSignature(ix, payload) {
  return async function innerFetchSignature(id) {
    const acct = ix.accounts[id];
    if (acct.signature != null) return;
    const {
      signature
    } = await acct.signingFunction(buildSignable(acct, payload, ix));
    ix.accounts[id].signature = signature;
  };
}

function buildSignable(acct, message, ix) {
  try {
    return {
      f_type: "Signable",
      f_vsn: "1.0.1",
      message,
      addr: sansPrefix(acct.addr),
      keyId: acct.keyId,
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildSignable", error);
    throw error;
  }
}

function prepForEncoding(ix) {
  const payerAddress = sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
    proposalKey: {
      address: sansPrefix(ix.accounts[ix.proposer].addr),
      keyId: ix.accounts[ix.proposer].keyId,
      sequenceNum: ix.accounts[ix.proposer].sequenceNum
    },
    payer: payerAddress,
    authorizers: ix.authorizations.map(cid => sansPrefix(ix.accounts[cid].addr)).reduce((prev, current) => {
      return prev.find(item => item === current) ? prev : [...prev, current];
    }, [])
  };
}

async function resolveValidators(ix) {
  const validators = get(ix, 'ix.validators', []);
  return pipe(ix, validators.map(cb => ix => cb(ix, {
    Ok,
    Bad
  })));
}

async function resolveFinalNormalization(ix) {
  for (let key of Object.keys(ix.accounts)) {
    ix.accounts[key].addr = sansPrefix(ix.accounts[key].addr);
  }

  return ix;
}

async function resolveVoucherIntercept(ix) {
  const fn = get(ix, "ix.voucher-intercept");

  if (isFn$3(fn)) {
    await fn(createSignableVoucher(ix));
  }

  return ix;
}

const noop = v => v;

const debug = (key, fn = noop) => async ix => {

  const accts = ix => ["\nAccounts:", {
    proposer: ix.proposer,
    authorizations: ix.authorizations,
    payer: ix.payer
  }, "\n\nDetails:", ix.accounts].filter(Boolean);

  const log = (...msg) => {
    console.log(`debug[${key}] ---\n`, ...msg, "\n\n\n---");
  };

  if (await config.get(`debug.${key}`)) await fn(ix, log, accts);
  return ix;
};

const resolve = pipe([resolveCadence, debug("cadence", (ix, log) => log(ix.message.cadence)), resolveArguments, debug("arguments", (ix, log) => log(ix.message.arguments, ix.message)), resolveAccounts, debug("accounts", (ix, log, accts) => log(...accts(ix))),
/* special */
execFetchRef,
/* special */
execFetchSequenceNumber, resolveSignatures, debug("signatures", (ix, log, accts) => log(...accts(ix))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", (ix, log) => log(ix))]);

async function execFetchRef(ix) {
  if (isTransaction(ix) && ix.message.refBlock == null) {
    const node = await config().get("accessNode.api");
    const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
    invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    ix.message.refBlock = (await sendFn(build([getBlock()]), {
      config,
      response,
      Buffer,
      ix: ixModule
    }, {
      node
    }).then(decodeResponse)).id;
  }

  return ix;
}

async function execFetchSequenceNumber(ix) {
  if (isTransaction(ix)) {
    var acct = Object.values(ix.accounts).find(a => a.role.proposer);
    invariant$1(acct, `Transactions require a proposer`);

    if (acct.sequenceNum == null) {
      const node = await config().get("accessNode.api");
      const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
      invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
      ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {
        config,
        response,
        Buffer,
        ix: ixModule
      }, {
        node
      }).then(decodeResponse).then(acct => acct.keys).then(keys => keys.find(key => key.index === acct.keyId)).then(key => key.sequenceNumber);
    }
  }

  return ix;
}

function invariant(...args) {
  if (args.length > 1) {
    const [predicate, message] = args;
    return invariant((ix, {
      Ok,
      Bad
    }) => {
      return predicate ? Ok(ix) : Bad(ix, message);
    });
  }

  const [fn] = args;
  return ix => fn(ix, {
    Ok,
    Bad
  });
}

const send = async (args = [], opts = {}) => {
  const sendFn = await config.first(["sdk.transport", "sdk.send"], opts.send || send$1);
  const resolveFn = await config.first(["sdk.resolve"], opts.resolve || resolve);
  opts.node = opts.node || (await config().get("accessNode.api"));
  if (Array.isArray(args)) args = pipe(interaction(), args);
  return sendFn(await resolveFn(args), {
    config,
    response,
    ix: ixModule,
    Buffer
  }, opts);
};

async function decode(response) {
  const decodersFromConfig = await config().where(/^decoder\./);
  const decoders = Object.entries(decodersFromConfig).map(([pattern, xform]) => {
    pattern = `/${pattern.replace(/^decoder\./, "")}$/`;
    return [pattern, xform];
  });
  return decodeResponse(response, Object.fromEntries(decoders));
}

const findPayloadSigners = voucher => {
  // Payload Signers Are: (authorizers + proposer) - payer
  let payload = new Set(voucher.authorizers);
  payload.add(voucher.proposalKey.address);
  payload.delete(voucher.payer);
  return Array.from(payload).map(withPrefix);
};

const findEnvelopeSigners = voucher => {
  // Envelope Signers Are: (payer)
  let envelope = new Set([voucher.payer]);
  return Array.from(envelope).map(withPrefix);
};

class UnableToDetermineMessageEncodingTypeForSignerAddress extends Error {
  constructor(signerAddress) {
    const msg = `
        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. 
        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.
      `.trim();
    super(msg);
    this.name = "Unable To Determine Message Encoding For Signer Addresss";
  }

}
const encodeMessageFromSignable = (signable, signerAddress) => {
  let payloadSigners = findPayloadSigners(signable.voucher);
  let envelopeSigners = findEnvelopeSigners(signable.voucher);
  const isPayloadSigner = payloadSigners.includes(withPrefix(signerAddress));
  const isEnvelopeSigner = envelopeSigners.includes(withPrefix(signerAddress));

  if (!isPayloadSigner && !isEnvelopeSigner) {
    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
  }

  const message = {
    cadence: signable.voucher.cadence,
    refBlock: signable.voucher.refBlock,
    computeLimit: signable.voucher.computeLimit,
    arguments: signable.voucher.arguments,
    proposalKey: _extends({}, signable.voucher.proposalKey, {
      address: sansPrefix(signable.voucher.proposalKey.address)
    }),
    payer: sansPrefix(signable.voucher.payer),
    authorizers: signable.voucher.authorizers.map(sansPrefix),
    payloadSigs: signable.voucher.payloadSigs.map(ps => _extends({}, ps, {
      address: sansPrefix(ps.address)
    }))
  };
  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
};

function validator(cb) {
  return update('ix.validators', validators => Array.isArray(validators) ? validators.push(cb) : [cb]);
}

function atBlockHeight(height) {
  return pipe([ix => {
    ix.block.height = height;
    return ix;
  }, validator(ix => {
    if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
    if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
    return ix;
  })]);
}

function atBlockId(id) {
  return pipe([ix => {
    ix.block.id = id;
    return Ok(ix);
  }, validator((ix, {
    Ok,
    Bad
  }) => {
    if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
    if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
    if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
    return Ok(ix);
  })]);
}

function account(address, {
  height,
  id
} = {}, opts) {
  invariant$1(!(id && height), `Method: account -- Cannot pass "id" and "height" simultaneously`); // Get account by ID

  if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse); // Get account by height

  if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);
  return send([getAccount(address)], opts).then(decodeResponse);
}

function block({
  sealed = false,
  id,
  height
} = {}, opts = {}) {
  invariant$1(!(sealed && id || sealed && height), `Method: block -- Cannot pass "sealed" with "id" or "height"`);
  invariant$1(!(id && height), `Method: block -- Cannot pass "id" and "height" simultaneously`); // Get block by ID

  if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse); // Get block by height

  if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse); // Get latest block

  return send([getBlock(sealed)], opts).then(decodeResponse);
}

function authorizations(ax = []) {
  return pipe(ax.map(authz => {
    return prepAccount(authz, {
      role: AUTHORIZER
    });
  }));
}
function authorization(addr, signingFunction, keyId, sequenceNum) {
  return {
    addr,
    signingFunction,
    keyId,
    sequenceNum
  };
}

function getEvents(eventType, start, end) {
  if (typeof start !== "undefined" || typeof end !== "undefined") {
    console.warn(`
      %cFCL/SDK Deprecation Notice
      ============================
  
      Passing a start and end into getEnvents has been deprecated and will not be supported in future versions of the Flow JS-SDK/FCL.
      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder
  
      ============================
    `, "font-weight:bold;font-family:monospace;");
  }

  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

function getEventsAtBlockHeightRange(eventType, start, end) {
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

function getEventsAtBlockIds(eventType, blockIds = []) {
  return pipe([makeGetEvents, ix => {
    ix.events.eventType = eventType;
    ix.events.blockIds = blockIds;
    return Ok(ix);
  }]);
}

function getBlockHeader(isSealed = null) {
  return pipe([makeGetBlockHeader, ix => {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

function getCollection(id = null) {
  return pipe([makeGetCollection, ix => {
    ix.collection.id = id;
    return ix;
  }]);
}

function getTransactionStatus(transactionId) {
  return pipe([makeGetTransactionStatus, ix => {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function getTransaction(transactionId) {
  return pipe([makeGetTransaction, ix => {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function limit(computeLimit) {
  return ix => {
    ix.message.computeLimit = computeLimit;
    return ix;
  };
}

function args(ax = []) {
  return pipe(ax.map(makeArgument));
}
function arg(value, xform) {
  return {
    value,
    xform
  };
}

async function proposer(authz) {
  return prepAccount(authz, {
    role: PROPOSER
  });
}

async function payer(authz) {
  return prepAccount(authz, {
    role: PAYER
  });
}

function ping() {
  return makePing;
}

function ref(refBlock) {
  return pipe([ix => {
    ix.message.refBlock = refBlock;
    return Ok(ix);
  }]);
}

function script(...args) {
  return pipe([makeScript, put("ix.cadence", template(...args))]);
}

const DEFAULT_COMPUTE_LIMIT = 10;
const DEFAULT_SCRIPT_ACCOUNTS = [];
const DEFUALT_REF = null;
function transaction(...args) {
  return pipe([makeTransaction, put("ix.cadence", template(...args)), ix => {
    ix.message.computeLimit = ix.message.computeLimit || DEFAULT_COMPUTE_LIMIT;
    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
    return Ok(ix);
  }]);
}

function voucherIntercept(fn) {
  return put("ix.voucher-intercept", fn);
}

const resolveProposerSequenceNumber = ({
  node
}) => async ix => {
  if (!isTransaction(ix)) return Ok(ix);
  if (ix.accounts[ix.proposer].sequenceNum) return Ok(ix);
  const sendFn = await config.first(["sdk.transport", "sdk.send"], send$1);
  invariant$1(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
  const response$1 = await sendFn(await build([getAccount(ix.accounts[ix.proposer].addr)]), {
    config,
    response: response,
    Buffer,
    ix: ixModule
  }, {
    node
  });
  const decoded = await decodeResponse(response$1);
  ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
  return Ok(ix);
};

function mockAccountResponse(ix, numberOfKeys = 5) {
  // prettier-ignore
  invariant$1(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix); // prettier-ignore

  invariant$1(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
  const address = ix.account.addr;
  return {
    account: {
      addr: address,
      keys: Array.from({
        length: numberOfKeys
      }, (_, i) => ({
        index: i,
        sequenceNumber: 42
      }))
    }
  };
}
function mockGetBlockResponse(ix) {
  return {
    tag: "GET_BLOCK",
    block: {
      id: "32"
    }
  };
}

const identity = v => v;

function mockSend(fallback = identity) {
  return async function execSend(ix) {
    ix = await ix;

    switch (true) {
      case isGetAccount(ix):
        return mockAccountResponse(ix);

      case isGetBlock(ix):
        return mockGetBlockResponse();

      default:
        return fallback(ix);
    }
  };
}

const _excluded = ["tempId"];
const idof = acct => `${acct.addr}-${acct.keyId}`;
function sig(opts) {
  return ["SIGNATURE", opts.addr, opts.keyId].join(".");
}
function authzFn(opts = {}) {
  return function (account) {
    const acct = _extends({}, account, opts, {
      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
    });

    return acct;

    function fallbackSigningFunction(signable) {
      return {
        addr: acct.addr,
        keyId: acct.keyId,
        signature: sig(acct)
      };
    }
  };
}
function authzResolve(opts = {}) {
  return function (account) {
    const {
      tempId
    } = opts,
          rest = _objectWithoutPropertiesLoose(opts, _excluded);

    return _extends({}, account, {
      tempId: tempId || "WITH_RESOLVE",
      resolve: authzFn(rest)
    });
  };
}
const ROLE = {
  proposer: false,
  authorizer: false,
  payer: false
};

function authzResolveMany(opts = {}) {
  return function (account) {
    const tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
    return _extends({}, account, {
      tempId,
      resolve: () => [opts.proposer && authzFn(opts.proposer)({
        role: _extends({}, ROLE, {
          proposer: true
        })
      }), ...opts.authorizations.map(authzFn).map(d => d({
        role: _extends({}, ROLE, {
          authorizer: true
        })
      })), opts.payer && authzFn(opts.payer)({
        role: _extends({}, ROLE, {
          payer: true
        })
      })].filter(Boolean)
    });
  };
}

const run = (fns = []) => build([ref("123"), ...fns]).then(resolve);

var index = {
  __proto__: null,
  mockSend: mockSend,
  authzFn: authzFn,
  authzResolve: authzResolve,
  authzResolveMany: authzResolveMany,
  sig: sig,
  idof: idof,
  run: run
};

const VERSION = "1.0.1" ;

const params = params => deprecate.error({
  name: "params",
  transitionsPath: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
});
const param = params => deprecate.warn({
  name: "param",
  transitionsPath: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
});

export { index as TestUtils, VERSION, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, createSignableVoucher, decode, destroy, encodeMessageFromSignable, encodeTransactionEnvelope, encodeTransactionPayload, encodeTxIdFromVoucher, get, getAccount, getBlock, getBlockHeader, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getTransaction, getTransactionStatus, interaction, invariant, isBad, isGetAccount, isGetBlock, isGetBlockHeader, isGetCollection, isGetEvents, isGetTransaction, isGetTransactionStatus, isOk, isPing, isScript, isTransaction, isUnknown, limit, param, params, payer, ping, pipe, proposer, put, ref, resolve, resolveAccounts, resolveArguments, resolveCadence, resolveFinalNormalization, resolveProposerSequenceNumber, resolveRefBlockId, resolveSignatures, resolveValidators, resolveVoucherIntercept, script, send, transaction, update, validator, voucherIntercept, voucherToTxId, why };
//# sourceMappingURL=sdk.modern.js.map
