import '@onflow/util-logger';
import { invariant as invariant$1 } from '@onflow/util-invariant';
import { config } from '@onflow/config';
export { config } from '@onflow/config';
import { Buffer, encode } from '@onflow/rlp';
import { send as send$1 } from '@onflow/transport-http';
import { sansPrefix, withPrefix } from '@onflow/util-address';
import { SHA3 } from 'sha3';
import { template } from '@onflow/util-template';
export { template as cadence, template as cdc } from '@onflow/util-template';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var buildWarningMessage = function buildWarningMessage(_ref) {
  var name = _ref.name,
      transitionsPath = _ref.transitionsPath;
  console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n    The " + name + " builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: " + transitionsPath + "\n    ============================\n  ", "font-weight:bold;font-family:monospace;");
};

var buildErrorMessage = function buildErrorMessage(_ref2) {
  var name = _ref2.name,
      transitionsPath = _ref2.transitionsPath;
  console.error("\n    %cFCL/SDK Deprecation Notice\n    ============================\n    The " + name + " builder has been removed from the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: " + transitionsPath + "\n    ============================\n  ", "font-weight:bold;font-family:monospace;");
};

var warn = function warn(deprecated) {
  return buildWarningMessage(deprecated);
};

var error = function error(deprecated) {
  buildErrorMessage(deprecated);
};

var deprecate = {
  warn: warn,
  error: error
};

function _catch$2(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var UNKNOWN
/*                       */
= "UNKNOWN";
var SCRIPT
/*                        */
= "SCRIPT";
var TRANSACTION
/*                   */
= "TRANSACTION";
var GET_TRANSACTION_STATUS
/*        */
= "GET_TRANSACTION_STATUS";
var GET_ACCOUNT
/*                   */
= "GET_ACCOUNT";
var GET_EVENTS
/*                    */
= "GET_EVENTS";
var PING
/*                          */
= "PING";
var GET_TRANSACTION
/*               */
= "GET_TRANSACTION";
var GET_BLOCK
/*                     */
= "GET_BLOCK";
var GET_BLOCK_HEADER
/*              */
= "GET_BLOCK_HEADER";
var GET_COLLECTION
/*                */
= "GET_COLLECTION";
var BAD
/* */
= "BAD";
var OK
/*  */
= "OK";
var ACCOUNT
/*  */
= "ACCOUNT";
var PARAM
/*    */
= "PARAM";
var ARGUMENT
/* */
= "ARGUMENT";
var AUTHORIZER
/* */
= "authorizer";
var PAYER
/*      */
= "payer";
var PROPOSER
/*   */
= "proposer";
var ACCT = "{\n  \"kind\":\"" + ACCOUNT + "\",\n  \"tempId\":null,\n  \"addr\":null,\n  \"keyId\":null,\n  \"sequenceNum\":null,\n  \"signature\":null,\n  \"signingFunction\":null,\n  \"resolve\":null,\n  \"role\": {\n    \"proposer\":false,\n    \"authorizer\":false,\n    \"payer\":false,\n    \"param\":false\n  }\n}";
var ARG = "{\n  \"kind\":\"" + ARGUMENT + "\",\n  \"tempId\":null,\n  \"value\":null,\n  \"asArgument\":null,\n  \"xform\":null,\n  \"resolve\": null,\n  \"resolveArgument\": null\n}";
var IX = "{\n  \"tag\":\"" + UNKNOWN + "\",\n  \"assigns\":{},\n  \"status\":\"" + OK + "\",\n  \"reason\":null,\n  \"accounts\":{},\n  \"params\":{},\n  \"arguments\":{},\n  \"message\": {\n    \"cadence\":null,\n    \"refBlock\":null,\n    \"computeLimit\":null,\n    \"proposer\":null,\n    \"payer\":null,\n    \"authorizations\":[],\n    \"params\":[],\n    \"arguments\":[]\n  },\n  \"proposer\":null,\n  \"authorizations\":[],\n  \"payer\":[],\n  \"events\": {\n    \"eventType\":null,\n    \"start\":null,\n    \"end\":null,\n    \"blockIds\":[]\n  },\n  \"transaction\": {\n    \"id\":null\n  },\n  \"block\": {\n    \"id\":null,\n    \"height\":null,\n    \"isSealed\":null\n  },\n  \"account\": {\n    \"addr\":null\n  },\n  \"collection\": {\n    \"id\":null\n  }\n}";
var KEYS = new Set(Object.keys(JSON.parse(IX)));
var interaction = function interaction() {
  return JSON.parse(IX);
};
var CHARS = "abcdefghijklmnopqrstuvwxyz0123456789".split("");

var randChar = function randChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
};

var uuid = function uuid() {
  return Array.from({
    length: 10
  }, randChar).join("");
};
var isNumber$1 = function isNumber(d) {
  return typeof d === "number";
};
var isArray$1 = function isArray(d) {
  return Array.isArray(d);
};
var isObj = function isObj(d) {
  return d !== null && typeof d === "object";
};
var isNull = function isNull(d) {
  return d == null;
};
var isFn$3 = function isFn(d) {
  return typeof d === "function";
};
var isInteraction = function isInteraction(ix) {
  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;

  for (var _iterator = _createForOfIteratorHelperLoose(KEYS), _step; !(_step = _iterator()).done;) {
    var key = _step.value;
    if (!ix.hasOwnProperty(key)) return false;
  }

  return true;
};
var Ok = function Ok(ix) {
  ix.status = OK;
  return ix;
};
var Bad = function Bad(ix, reason) {
  ix.status = BAD;
  ix.reason = reason;
  return ix;
};

var makeIx = function makeIx(wat) {
  return function (ix) {
    ix.tag = wat;
    return Ok(ix);
  };
};

var prepAccount = function prepAccount(acct, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (ix) {
    var _extends2;

    invariant$1(typeof acct === "function" || typeof acct === "object", "prepAccount must be passed an authorization function or an account object");
    invariant$1(opts.role != null, "Account must have a role");
    var ACCOUNT = JSON.parse(ACCT);
    var role = opts.role;
    var tempId = uuid();
    if (acct.authorization && isFn$3(acct.authorization)) acct = {
      resolve: acct.authorization
    };
    if (!acct.authorization && isFn$3(acct)) acct = {
      resolve: acct
    };
    ix.accounts[tempId] = _extends({}, ACCOUNT, {
      tempId: tempId
    }, acct, {
      role: _extends({}, ACCOUNT.role, typeof acct.role === "object" ? acct.role : {}, (_extends2 = {}, _extends2[role] = true, _extends2))
    });

    if (role === AUTHORIZER) {
      ix.authorizations.push(tempId);
    } else if (role === PAYER) {
      ix.payer.push(tempId);
    } else {
      ix[role] = tempId;
    }

    return ix;
  };
};
var makeArgument = function makeArgument(arg) {
  return function (ix) {
    var tempId = uuid();
    ix.message.arguments.push(tempId);
    ix.arguments[tempId] = JSON.parse(ARG);
    ix.arguments[tempId].tempId = tempId;
    ix.arguments[tempId].value = arg.value;
    ix.arguments[tempId].asArgument = arg.asArgument;
    ix.arguments[tempId].xform = arg.xform;
    ix.arguments[tempId].resolve = arg.resolve;
    ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
    return Ok(ix);
  };
};
var makeUnknown
/*                 */
= makeIx(UNKNOWN);
var makeScript
/*                  */
= makeIx(SCRIPT);
var makeTransaction
/*             */
= makeIx(TRANSACTION);
var makeGetTransactionStatus
/*    */
= makeIx(GET_TRANSACTION_STATUS);
var makeGetTransaction
/*          */
= makeIx(GET_TRANSACTION);
var makeGetAccount
/*              */
= makeIx(GET_ACCOUNT);
var makeGetEvents
/*               */
= makeIx(GET_EVENTS);
var makePing
/*                    */
= makeIx(PING);
var makeGetBlock
/*                */
= makeIx(GET_BLOCK);
var makeGetBlockHeader
/*          */
= makeIx(GET_BLOCK_HEADER);
var makeGetCollection
/*           */
= makeIx(GET_COLLECTION);

var is = function is(wat) {
  return function (ix) {
    return ix.tag === wat;
  };
};

var isUnknown
/*                 */
= is(UNKNOWN);
var isScript
/*                  */
= is(SCRIPT);
var isTransaction
/*             */
= is(TRANSACTION);
var isGetTransactionStatus
/*    */
= is(GET_TRANSACTION_STATUS);
var isGetTransaction
/*          */
= is(GET_TRANSACTION);
var isGetAccount
/*              */
= is(GET_ACCOUNT);
var isGetEvents
/*               */
= is(GET_EVENTS);
var isPing
/*                    */
= is(PING);
var isGetBlock
/*                */
= is(GET_BLOCK);
var isGetBlockHeader
/*          */
= is(GET_BLOCK_HEADER);
var isGetCollection
/*           */
= is(GET_COLLECTION);
var isOk
/*  */
= function isOk
/*  */
(ix) {
  return ix.status === OK;
};
var isBad
/* */
= function isBad
/* */
(ix) {
  return ix.status === BAD;
};
var why
/*   */
= function why
/*   */
(ix) {
  return ix.reason;
};
var isAccount
/*  */
= function isAccount
/*  */
(account) {
  return account.kind === ACCOUNT;
};
var isParam
/*    */
= function isParam
/*    */
(param) {
  return param.kind === PARAM;
};
var isArgument
/* */
= function isArgument
/* */
(argument) {
  return argument.kind === ARGUMENT;
};

var hardMode = function hardMode(ix) {
  for (var _i = 0, _Object$keys = Object.keys(ix); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!KEYS.has(key)) throw new Error("\"" + key + "\" is an invalid root level Interaction property.");
  }

  return ix;
};

var recPipe = function recPipe(ix, fns) {
  if (fns === void 0) {
    fns = [];
  }

  try {
    return Promise.resolve(_catch$2(function () {
      return Promise.resolve(ix).then(function (_ix) {
        ix = hardMode(_ix);
        if (isBad(ix)) throw new Error("Interaction Error: " + ix.reason);
        if (!fns.length) return ix;

        var _fns = fns,
            hd = _fns[0],
            rest = _fns.slice(1);

        return Promise.resolve(hd).then(function (cur) {
          if (isFn$3(cur)) return recPipe(cur(ix), rest);
          if (isNull(cur) || !cur) return recPipe(ix, rest);
          if (isInteraction(cur)) return recPipe(cur, rest);
          throw new Error("Invalid Interaction Composition");
        });
      });
    }, function (e) {
      throw e;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var pipe = function pipe() {
  var _slice$call = [].slice.call(arguments),
      arg1 = _slice$call[0],
      arg2 = _slice$call[1];

  if (isArray$1(arg1) && arg2 == null) return function (d) {
    return pipe(d, arg1);
  };
  return recPipe(arg1, arg2);
};

var identity$1 = function identity(v) {
  return v;
};

var get = function get(ix, key, fallback) {
  return ix.assigns[key] == null ? fallback : ix.assigns[key];
};
var put = function put(key, value) {
  return function (ix) {
    ix.assigns[key] = value;
    return Ok(ix);
  };
};
var update = function update(key, fn) {
  if (fn === void 0) {
    fn = identity$1;
  }

  return function (ix) {
    ix.assigns[key] = fn(ix.assigns[key], ix);
    return Ok(ix);
  };
};
var destroy = function destroy(key) {
  return function (ix) {
    delete ix.assigns[key];
    return Ok(ix);
  };
};

var ixModule = {
  __proto__: null,
  UNKNOWN: UNKNOWN,
  SCRIPT: SCRIPT,
  TRANSACTION: TRANSACTION,
  GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,
  GET_ACCOUNT: GET_ACCOUNT,
  GET_EVENTS: GET_EVENTS,
  PING: PING,
  GET_TRANSACTION: GET_TRANSACTION,
  GET_BLOCK: GET_BLOCK,
  GET_BLOCK_HEADER: GET_BLOCK_HEADER,
  GET_COLLECTION: GET_COLLECTION,
  BAD: BAD,
  OK: OK,
  ACCOUNT: ACCOUNT,
  PARAM: PARAM,
  ARGUMENT: ARGUMENT,
  AUTHORIZER: AUTHORIZER,
  PAYER: PAYER,
  PROPOSER: PROPOSER,
  interaction: interaction,
  uuid: uuid,
  isNumber: isNumber$1,
  isArray: isArray$1,
  isObj: isObj,
  isNull: isNull,
  isFn: isFn$3,
  isInteraction: isInteraction,
  Ok: Ok,
  Bad: Bad,
  prepAccount: prepAccount,
  makeArgument: makeArgument,
  makeUnknown: makeUnknown,
  makeScript: makeScript,
  makeTransaction: makeTransaction,
  makeGetTransactionStatus: makeGetTransactionStatus,
  makeGetTransaction: makeGetTransaction,
  makeGetAccount: makeGetAccount,
  makeGetEvents: makeGetEvents,
  makePing: makePing,
  makeGetBlock: makeGetBlock,
  makeGetBlockHeader: makeGetBlockHeader,
  makeGetCollection: makeGetCollection,
  isUnknown: isUnknown,
  isScript: isScript,
  isTransaction: isTransaction,
  isGetTransactionStatus: isGetTransactionStatus,
  isGetTransaction: isGetTransaction,
  isGetAccount: isGetAccount,
  isGetEvents: isGetEvents,
  isPing: isPing,
  isGetBlock: isGetBlock,
  isGetBlockHeader: isGetBlockHeader,
  isGetCollection: isGetCollection,
  isOk: isOk,
  isBad: isBad,
  why: why,
  isAccount: isAccount,
  isParam: isParam,
  isArgument: isArgument,
  pipe: pipe,
  get: get,
  put: put,
  update: update,
  destroy: destroy
};

function build(fns) {
  if (fns === void 0) {
    fns = [];
  }

  return pipe(interaction(), fns);
}

var DEFAULT_RESPONSE = "{\n    \"tag\":null,\n    \"transaction\":null,\n    \"transactionStatus\":null,\n    \"transactionId\":null,\n    \"encodedData\":null,\n    \"events\":null,\n    \"account\":null,\n    \"block\":null,\n    \"blockHeader\":null,\n    \"latestBlock\":null,\n    \"collection\":null\n}";
var response = function response() {
  return JSON.parse(DEFAULT_RESPONSE);
};

function getBlock(isSealed) {
  if (isSealed === void 0) {
    isSealed = null;
  }

  return pipe([makeGetBlock, function (ix) {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

function getAccount(addr) {
  return pipe([makeGetAccount, function (ix) {
    ix.account.addr = sansPrefix(addr);
    return Ok(ix);
  }]);
}

var latestBlockDeprecationNotice = function latestBlockDeprecationNotice() {
  console.error("\n          %c@onflow/decode Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the response object is deprecated and will no longer be recognized in future releases of @onflow/decode.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g, "\n").trim(), "font-weight:bold;font-family:monospace;");
};

var decodeImplicit = function decodeImplicit(i) {
  return Promise.resolve(i);
};

var decodeVoid = function decodeVoid() {
  return Promise.resolve(null);
};

var decodeType = function decodeType(type) {
  try {
    return Promise.resolve(type.staticType);
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodePath = function decodePath(path) {
  try {
    return Promise.resolve({
      domain: path.domain,
      identifier: path.identifier
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeCapability = function decodeCapability(cap) {
  try {
    return Promise.resolve({
      path: cap.path,
      address: cap.address,
      borrowType: cap.borrowType
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeOptional = function decodeOptional(optional, decoders, stack) {
  return Promise.resolve(optional ? recurseDecode(optional, decoders, stack) : null);
};

var decodeReference = function decodeReference(v) {
  try {
    return Promise.resolve({
      address: v.address,
      type: v.type
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeArray = function decodeArray(array, decoders, stack) {
  try {
    return Promise.resolve(Promise.all(array.map(function (v) {
      return new Promise(function (res) {
        try {
          return Promise.resolve(recurseDecode(v, decoders, [].concat(stack, [v.type]))).then(res);
        } catch (e) {
          return Promise.reject(e);
        }
      });
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeDictionary = function decodeDictionary(dictionary, decoders, stack) {
  try {
    return Promise.resolve(dictionary.reduce(function (acc, v) {
      return Promise.resolve(acc).then(function (_acc) {
        acc = _acc;
        return Promise.resolve(recurseDecode(v.key, decoders, [].concat(stack, [v.key]))).then(function (_recurseDecode3) {
          return Promise.resolve(recurseDecode(v.value, decoders, [].concat(stack, [v.key]))).then(function (_recurseDecode4) {
            acc[_recurseDecode3] = _recurseDecode4;
            return acc;
          });
        });
      });
    }, Promise.resolve({})));
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeComposite = function decodeComposite(composite, decoders, stack) {
  try {
    return Promise.resolve(composite.fields.reduce(function (acc, v) {
      return Promise.resolve(acc).then(function (_acc2) {
        acc = _acc2;
        return Promise.resolve(recurseDecode(v.value, decoders, [].concat(stack, [v.name]))).then(function (_recurseDecode5) {
          acc[v.name] = _recurseDecode5;
          return acc;
        });
      });
    }, Promise.resolve({}))).then(function (decoded) {
      var decoder = composite.id && decoderLookup(decoders, composite.id);
      return decoder ? Promise.resolve(decoder(decoded)) : decoded;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var defaultDecoders = {
  UInt: decodeImplicit,
  Int: decodeImplicit,
  UInt8: decodeImplicit,
  Int8: decodeImplicit,
  UInt16: decodeImplicit,
  Int16: decodeImplicit,
  UInt32: decodeImplicit,
  Int32: decodeImplicit,
  UInt64: decodeImplicit,
  Int64: decodeImplicit,
  UInt128: decodeImplicit,
  Int128: decodeImplicit,
  UInt256: decodeImplicit,
  Int256: decodeImplicit,
  Word8: decodeImplicit,
  Word16: decodeImplicit,
  Word32: decodeImplicit,
  Word64: decodeImplicit,
  UFix64: decodeImplicit,
  Fix64: decodeImplicit,
  String: decodeImplicit,
  Character: decodeImplicit,
  Bool: decodeImplicit,
  Address: decodeImplicit,
  Void: decodeVoid,
  Optional: decodeOptional,
  Reference: decodeReference,
  Array: decodeArray,
  Dictionary: decodeDictionary,
  Event: decodeComposite,
  Resource: decodeComposite,
  Struct: decodeComposite,
  Enum: decodeComposite,
  Type: decodeType,
  Path: decodePath,
  Capability: decodeCapability
};

var decoderLookup = function decoderLookup(decoders, lookup) {
  var found = Object.keys(decoders).find(function (decoder) {
    if (/^\/.*\/$/.test(decoder)) {
      var reg = new RegExp(decoder.substring(1, decoder.length - 1));
      return reg.test(lookup);
    }

    return decoder === lookup;
  });
  return lookup && found && decoders[found];
};

var recurseDecode = function recurseDecode(decodeInstructions, decoders, stack) {
  try {
    var decoder = decoderLookup(decoders, decodeInstructions.type);
    if (!decoder) throw new Error("Undefined Decoder Error: " + decodeInstructions.type + "@" + stack.join("."));
    return Promise.resolve(decoder(decodeInstructions.value, decoders, stack));
  } catch (e) {
    return Promise.reject(e);
  }
};

var decode$1 = function decode(decodeInstructions, customDecoders, stack) {
  if (customDecoders === void 0) {
    customDecoders = {};
  }

  if (stack === void 0) {
    stack = [];
  }

  var decoders = _extends({}, defaultDecoders, customDecoders);

  return Promise.resolve(recurseDecode(decodeInstructions, decoders, stack));
};
var decodeResponse = function decodeResponse(response, customDecoders) {
  if (customDecoders === void 0) {
    customDecoders = {};
  }

  try {
    var _exit2;

    var decoders = _extends({}, defaultDecoders, customDecoders);

    var _temp2 = function () {
      if (response.encodedData) {
        return Promise.resolve(decode$1(response.encodedData, decoders)).then(function (_await$decode) {
          _exit2 = 1;
          return _await$decode;
        });
      } else return function () {
        if (response.transactionStatus) {
          return Promise.resolve(Promise.all(response.transactionStatus.events.map(function decodeEvents(e) {
            try {
              var _e$eventIndex2 = e.eventIndex,
                  _e$transactionIndex2 = e.transactionIndex,
                  _e$transactionId2 = e.transactionId,
                  _e$type2 = e.type;
              return Promise.resolve(decode$1(e.payload, decoders)).then(function (_decode) {
                return {
                  type: _e$type2,
                  transactionId: _e$transactionId2,
                  transactionIndex: _e$transactionIndex2,
                  eventIndex: _e$eventIndex2,
                  data: _decode
                };
              });
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function (_Promise$all2) {
            var _response$transaction = _extends({}, response.transactionStatus, {
              events: _Promise$all2
            });

            _exit2 = 1;
            return _response$transaction;
          });
        } else return function () {
          if (response.transaction) {
            var _response$transaction4 = response.transaction;
            _exit2 = 1;
            return _response$transaction4;
          } else return function () {
            if (response.events) {
              return Promise.resolve(Promise.all(response.events.map(function decodeEvents(e) {
                try {
                  var _e$eventIndex4 = e.eventIndex,
                      _e$transactionIndex4 = e.transactionIndex,
                      _e$transactionId4 = e.transactionId,
                      _e$type4 = e.type,
                      _e$blockTimestamp2 = e.blockTimestamp,
                      _e$blockHeight2 = e.blockHeight,
                      _e$blockId2 = e.blockId;
                  return Promise.resolve(decode$1(e.payload, decoders)).then(function (_decode2) {
                    return {
                      blockId: _e$blockId2,
                      blockHeight: _e$blockHeight2,
                      blockTimestamp: _e$blockTimestamp2,
                      type: _e$type4,
                      transactionId: _e$transactionId4,
                      transactionIndex: _e$transactionIndex4,
                      eventIndex: _e$eventIndex4,
                      data: _decode2
                    };
                  });
                } catch (e) {
                  return Promise.reject(e);
                }
              }))).then(function (_await$Promise$all) {
                _exit2 = 1;
                return _await$Promise$all;
              });
            } else if (response.account) {
              var _response$account2 = response.account;
              _exit2 = 1;
              return _response$account2;
            } else if (response.block) {
              var _response$block2 = response.block;
              _exit2 = 1;
              return _response$block2;
            } else if (response.blockHeader) {
              var _response$blockHeader2 = response.blockHeader;
              _exit2 = 1;
              return _response$blockHeader2;
            } else if (response.latestBlock) {
              latestBlockDeprecationNotice();
              var _response$latestBlock2 = response.latestBlock;
              _exit2 = 1;
              return _response$latestBlock2;
            } else if (response.transactionId) {
              var _response$transaction5 = response.transactionId;
              _exit2 = 1;
              return _response$transaction5;
            } else if (response.collection) {
              var _response$collection2 = response.collection;
              _exit2 = 1;
              return _response$collection2;
            }
          }();
        }();
      }();
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function (_result) {
      return _exit2 ? _result : null;
    }) : _exit2 ? _temp2 : null);
  } catch (e) {
    return Promise.reject(e);
  }
};

var getRefId = function getRefId(opts) {
  try {
    return Promise.resolve(config().get("accessNode.api")).then(function (node) {
      return Promise.resolve(config.first(["sdk.transport", "sdk.send"], send$1)).then(function (sendFn) {
        invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: " + "https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");
        var ix;
        return Promise.resolve(pipe(interaction(), [getBlock()])).then(function (_pipe) {
          ix = _pipe;
          return Promise.resolve(sendFn(ix, {
            config: config,
            response: response,
            Buffer: Buffer,
            ix: ixModule
          }, {
            node: node
          })).then(function (_sendFn) {
            ix = _sendFn;
            return Promise.resolve(decodeResponse(ix)).then(function (_decodeResponse) {
              ix = _decodeResponse;
              return ix.id;
            });
          });
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function resolveRefBlockId(opts) {
  return function (ix) {
    try {
      if (!isTransaction(ix)) return Promise.resolve(Ok(ix));
      if (ix.message.refBlock) return Promise.resolve(Ok(ix));
      return Promise.resolve(getRefId(opts)).then(function (_getRefId) {
        ix.message.refBlock = _getRefId;
        return Ok(ix);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

var resolveCadence = function resolveCadence(ix) {
  try {
    var _temp4 = function () {
      if (isTransaction(ix) || isScript(ix)) {
        var _temp5 = function _temp5() {
          invariant$1(isString$1(cadence), "Cadence needs to be a string at this point.");
          return Promise.resolve(config().where(/^0x/).then(function (d) {
            return Object.entries(d).reduce(function (cadence, _ref) {
              var key = _ref[0],
                  value = _ref[1];
              var regex = new RegExp("(\\b" + key + "\\b)", 'g');
              return cadence.replace(regex, value);
            }, cadence);
          })).then(function (_config$where$then) {
            ix.message.cadence = _config$where$then;
          });
        };

        var cadence = get(ix, "ix.cadence");
        invariant$1(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");

        var _temp6 = function () {
          if (isFn$2(cadence)) return Promise.resolve(cadence({})).then(function (_cadence) {
            cadence = _cadence;
          });
        }();

        return _temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6);
      }
    }();

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function () {
      return ix;
    }) : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var isFn$2 = function isFn(v) {
  return typeof v === "function";
};

var isString$1 = function isString(v) {
  return typeof v === "string";
};

const _iteratorSymbol$1 = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

function _settle$1(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact$1) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle$1.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle$1.bind(null, pact, state), _settle$1.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var _Pact$1 = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle$1(result, 1, callback(this.v));
        } catch (e) {
          _settle$1(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle$1(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle$1(result, 1, onRejected(value));
        } else {
          _settle$1(result, 2, value);
        }
      } catch (e) {
        _settle$1(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact$1(thenable) {
  return thenable instanceof _Pact$1 && thenable.s & 1;
}

function _forTo$1(array, body, check) {
  var i = -1,
      pact,
      reject;

  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);

        if (result && result.then) {
          if (_isSettledPact$1(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle$1.bind(null, pact = new _Pact$1(), 2)));
            return;
          }
        }
      }

      if (pact) {
        _settle$1(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle$1(pact || (pact = new _Pact$1()), 2, e);
    }
  }

  _cycle();

  return pact;
}

function _forOf$1(target, body, check) {
  if (typeof target[_iteratorSymbol$1] === "function") {
    var _cycle = function _cycle(result) {
      try {
        while (!(step = iterator.next()).done && (!check || !check())) {
          result = body(step.value);

          if (result && result.then) {
            if (_isSettledPact$1(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle$1.bind(null, pact = new _Pact$1(), 2)));
              return;
            }
          }
        }

        if (pact) {
          _settle$1(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle$1(pact || (pact = new _Pact$1()), 2, e);
      }
    };

    var iterator = target[_iteratorSymbol$1](),
        step,
        pact,
        reject;

    _cycle();

    if (iterator["return"]) {
      var _fixup = function _fixup(value) {
        try {
          if (!step.done) {
            iterator["return"]();
          }
        } catch (e) {}

        return value;
      };

      if (pact && pact.then) {
        return pact.then(_fixup, function (e) {
          throw _fixup(e);
        });
      }

      _fixup();
    }

    return pact;
  } // No support for Symbol.iterator


  // No support for Symbol.iterator
  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  } // Handle live collections properly


  // Handle live collections properly
  var values = [];

  for (var i = 0; i < target.length; i++) {
    values.push(target[i]);
  }

  return _forTo$1(values, function (i) {
    return body(values[i]);
  }, check);
}

var resolveArguments = function resolveArguments(ix) {
  try {
    var _temp3 = function () {
      if (isTransaction(ix) || isScript(ix)) {
        var _temp4 = _forOf$1(Object.entries(ix.arguments), function (_ref) {
          var id = _ref[0],
              arg = _ref[1];
          return Promise.resolve(handleArgResolution(arg)).then(function (res) {
            ix.arguments[id].asArgument = cast(res);
          });
        });

        if (_temp4 && _temp4.then) return _temp4.then(function () {});
      }
    }();

    return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(function () {
      return ix;
    }) : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var handleArgResolution = function handleArgResolution(arg, depth) {
  if (depth === void 0) {
    depth = 3;
  }

  try {
    invariant$1(depth > 0, "Argument Resolve Recursion Limit Exceeded for Arg: " + arg.tempId);

    if (isFn$1(arg.resolveArgument)) {
      return Promise.resolve(arg.resolveArgument()).then(function (resolvedArg) {
        return handleArgResolution(resolvedArg, depth - 1);
      });
    } else {
      return Promise.resolve(arg);
    }
  } catch (e) {
    return Promise.reject(e);
  }
};

var isFn$1 = function isFn(v) {
  return typeof v === "function";
};

function cast(arg) {
  // prettier-ignore
  invariant$1(typeof arg.xform != null, "No type specified for argument: " + arg.value);
  if (isFn$1(arg.xform)) return arg.xform(arg.value);
  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value); // prettier-ignore

  invariant$1(false, "Invalid Argument", arg);
}

var encodeTransactionPayload = function encodeTransactionPayload(tx) {
  return prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
};
var encodeTransactionEnvelope = function encodeTransactionEnvelope(tx) {
  return prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
};
var encodeTxIdFromVoucher = function encodeTxIdFromVoucher(voucher) {
  return sha3_256(rlpEncode(prepareVoucher(voucher)));
};

var rightPaddedHexBuffer = function rightPaddedHexBuffer(value, pad) {
  return Buffer.from(value.padEnd(pad * 2, 0), "hex");
};

var leftPaddedHexBuffer = function leftPaddedHexBuffer(value, pad) {
  return Buffer.from(value.padStart(pad * 2, 0), "hex");
};

var TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");

var prependTransactionDomainTag = function prependTransactionDomainTag(tx) {
  return TRANSACTION_DOMAIN_TAG + tx;
};

var addressBuffer = function addressBuffer(addr) {
  return leftPaddedHexBuffer(addr, 8);
};

var blockBuffer = function blockBuffer(block) {
  return leftPaddedHexBuffer(block, 32);
};

var argumentToString = function argumentToString(arg) {
  return Buffer.from(JSON.stringify(arg), "utf8");
};

var scriptBuffer = function scriptBuffer(script) {
  return Buffer.from(script, "utf8");
};

var signatureBuffer = function signatureBuffer(signature) {
  return Buffer.from(signature, "hex");
};

var rlpEncode = function rlpEncode(v) {
  return encode(v).toString("hex");
};

var sha3_256 = function sha3_256(msg) {
  var sha = new SHA3(256);
  sha.update(Buffer.from(msg, "hex"));
  return sha.digest().toString("hex");
};

var preparePayload = function preparePayload(tx) {
  validatePayload(tx);
  return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer(sansPrefix(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(sansPrefix(tx.payer)), tx.authorizers.map(function (authorizer) {
    return addressBuffer(sansPrefix(authorizer));
  })];
};

var prepareEnvelope = function prepareEnvelope(tx) {
  validateEnvelope(tx);
  return [preparePayload(tx), preparePayloadSignatures(tx)];
};

var preparePayloadSignatures = function preparePayloadSignatures(tx) {
  var signers = collectSigners(tx);
  return tx.payloadSigs.map(function (sig) {
    return {
      signerIndex: signers.get(sig.address),
      keyId: sig.keyId,
      sig: sig.sig
    };
  }).sort(function (a, b) {
    if (a.signerIndex > b.signerIndex) return 1;
    if (a.signerIndex < b.signerIndex) return -1;
    if (a.keyId > b.keyId) return 1;
    if (a.keyId < b.keyId) return -1;
  }).map(function (sig) {
    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
  });
};

var collectSigners = function collectSigners(tx) {
  var signers = new Map();
  var i = 0;

  var addSigner = function addSigner(addr) {
    if (!signers.has(addr)) {
      signers.set(addr, i);
      i++;
    }
  };

  addSigner(tx.proposalKey.address);
  addSigner(tx.payer);
  tx.authorizers.forEach(addSigner);
  return signers;
};

var prepareVoucher = function prepareVoucher(voucher) {
  validateVoucher(voucher);
  var signers = collectSigners(voucher);

  var prepareSigs = function prepareSigs(sigs) {
    return sigs.map(function (_ref) {
      var address = _ref.address,
          keyId = _ref.keyId,
          sig = _ref.sig;
      return {
        signerIndex: signers.get(address),
        keyId: keyId,
        sig: sig
      };
    }).sort(function (a, b) {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
    }).map(function (sig) {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };

  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(sansPrefix(voucher.payer)), voucher.authorizers.map(function (authorizer) {
    return addressBuffer(sansPrefix(authorizer));
  })], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
};

var validatePayload = function validatePayload(tx) {
  payloadFields.forEach(function (field) {
    return checkField(tx, field);
  });
  proposalKeyFields.forEach(function (field) {
    return checkField(tx.proposalKey, field, "proposalKey");
  });
};

var validateEnvelope = function validateEnvelope(tx) {
  payloadSigsFields.forEach(function (field) {
    return checkField(tx, field);
  });
  tx.payloadSigs.forEach(function (sig, index) {
    payloadSigFields.forEach(function (field) {
      return checkField(sig, field, "payloadSigs", index);
    });
  });
};

var validateVoucher = function validateVoucher(voucher) {
  payloadFields.forEach(function (field) {
    return checkField(voucher, field);
  });
  proposalKeyFields.forEach(function (field) {
    return checkField(voucher.proposalKey, field, "proposalKey");
  });
  payloadSigsFields.forEach(function (field) {
    return checkField(voucher, field);
  });
  voucher.payloadSigs.forEach(function (sig, index) {
    payloadSigFields.forEach(function (field) {
      return checkField(sig, field, "payloadSigs", index);
    });
  });
  envelopeSigsFields.forEach(function (field) {
    return checkField(voucher, field);
  });
  voucher.envelopeSigs.forEach(function (sig, index) {
    envelopeSigFields.forEach(function (field) {
      return checkField(sig, field, "envelopeSigs", index);
    });
  });
};

var isNumber = function isNumber(v) {
  return typeof v === "number";
};

var isString = function isString(v) {
  return typeof v === "string";
};

var isObject = function isObject(v) {
  return v !== null && typeof v === "object";
};

var isArray = function isArray(v) {
  return isObject(v) && v instanceof Array;
};

var payloadFields = [{
  name: "cadence",
  check: isString
}, {
  name: "arguments",
  check: isArray
}, {
  name: "refBlock",
  check: isString,
  defaultVal: "0"
}, {
  name: "computeLimit",
  check: isNumber
}, {
  name: "proposalKey",
  check: isObject
}, {
  name: "payer",
  check: isString
}, {
  name: "authorizers",
  check: isArray
}];
var proposalKeyFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sequenceNum",
  check: isNumber
}];
var payloadSigsFields = [{
  name: "payloadSigs",
  check: isArray
}];
var payloadSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
var envelopeSigsFields = [{
  name: "envelopeSigs",
  check: isArray
}];
var envelopeSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];

var checkField = function checkField(obj, field, base, index) {
  var name = field.name,
      check = field.check,
      defaultVal = field.defaultVal;
  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
  if (obj[name] == null) throw missingFieldError(name, base, index);
  if (!check(obj[name])) throw invalidFieldError(name, base, index);
};

var printFieldName = function printFieldName(field, base, index) {
  if (!!base) return index == null ? base + "." + field : base + "." + index + "." + field;
  return field;
};

var missingFieldError = function missingFieldError(field, base, index) {
  return new Error("Missing field " + printFieldName(field, base, index));
};

var invalidFieldError = function invalidFieldError(field, base, index) {
  return new Error("Invalid field " + printFieldName(field, base, index));
};

function findInsideSigners(ix) {
  // Inside Signers Are: (authorizers + proposer) - payer
  var inside = new Set(ix.authorizations);
  inside.add(ix.proposer);

  if (Array.isArray(ix.payer)) {
    ix.payer.forEach(function (p) {
      return inside["delete"](p);
    });
  } else {
    inside["delete"](ix.payer);
  }

  return Array.from(inside);
}
function findOutsideSigners(ix) {
  // Outside Signers Are: (payer)
  var outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
  return Array.from(outside);
}
var createSignableVoucher = function createSignableVoucher(ix) {
  var buildAuthorizers = function buildAuthorizers() {
    var authorizations = ix.authorizations.map(function (cid) {
      return withPrefix(ix.accounts[cid].addr);
    }).reduce(function (prev, current) {
      return prev.find(function (item) {
        return item === current;
      }) ? prev : [].concat(prev, [current]);
    }, []);
    return authorizations[0] ? authorizations : [];
  };

  var buildInsideSigners = function buildInsideSigners() {
    return findInsideSigners(ix).map(function (id) {
      return {
        address: withPrefix(ix.accounts[id].addr),
        keyId: ix.accounts[id].keyId,
        sig: ix.accounts[id].signature
      };
    });
  };

  var buildOutsideSigners = function buildOutsideSigners() {
    return findOutsideSigners(ix).map(function (id) {
      return {
        address: withPrefix(ix.accounts[id].addr),
        keyId: ix.accounts[id].keyId,
        sig: ix.accounts[id].signature
      };
    });
  };

  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(function (id) {
      return ix.arguments[id].asArgument;
    }),
    proposalKey: {
      address: withPrefix(ix.accounts[ix.proposer].addr),
      keyId: ix.accounts[ix.proposer].keyId,
      sequenceNum: ix.accounts[ix.proposer].sequenceNum
    },
    payer: withPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
    authorizers: buildAuthorizers(),
    payloadSigs: buildInsideSigners(),
    envelopeSigs: buildOutsideSigners()
  };
};
var voucherToTxId = function voucherToTxId(voucher) {
  return encodeTxIdFromVoucher(voucher);
};

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}

function _forTo(array, body, check) {
  var i = -1,
      pact,
      reject;

  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }

      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }

  _cycle();

  return pact;
}

function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    var _cycle = function _cycle(result) {
      try {
        while (!(step = iterator.next()).done && (!check || !check())) {
          result = body(step.value);

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }

        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    };

    var iterator = target[_iteratorSymbol](),
        step,
        pact,
        reject;

    _cycle();

    if (iterator["return"]) {
      var _fixup = function _fixup(value) {
        try {
          if (!step.done) {
            iterator["return"]();
          }
        } catch (e) {}

        return value;
      };

      if (pact && pact.then) {
        return pact.then(_fixup, function (e) {
          throw _fixup(e);
        });
      }

      _fixup();
    }

    return pact;
  } // No support for Symbol.iterator


  // No support for Symbol.iterator
  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  } // Handle live collections properly


  // Handle live collections properly
  var values = [];

  for (var i = 0; i < target.length; i++) {
    values.push(target[i]);
  }

  return _forTo(values, function (i) {
    return body(values[i]);
  }, check);
}

var resolveAccounts = function resolveAccounts(ix) {
  try {
    var _exit2;

    var _temp2 = function () {
      if (isTransaction(ix)) {
        if (!Array.isArray(ix.payer)) {
          console.warn("\n        %cFCL Warning\n        ============================\n        \"ix.payer\" must be an array. Support for ix.payer as a singular is deprecated,\n        see changelog for more info.\n        ============================\n        ", "font-weight:bold;font-family:monospace;");
        }

        return _catch$1(function () {
          return Promise.resolve(collectAccounts(ix, Object.values(ix.accounts))).then(function () {
            return Promise.resolve(collectAccounts(ix, Object.values(ix.accounts))).then(function () {});
          });
        }, function (error) {
          console.error("=== SAD PANDA ===\n\n", error, "\n\n=== SAD PANDA ===");
          throw error;
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function (_result2) {
      return _exit2 ? _result2 : ix;
    }) : _exit2 ? _temp2 : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var collectAccounts = function collectAccounts(ix, accounts, last, depth) {
  if (depth === void 0) {
    depth = 3;
  }

  try {
    var _temp9 = function _temp9(_result4) {
      if (_exit5) return _result4;

      if (last) {
        // complete (flatmap) group replacement
        ix.authorizations = ix.authorizations.map(function (d) {
          return d === last.tempId ? authorizations : d;
        }).reduce(function (prev, curr) {
          return Array.isArray(curr) ? [].concat(prev, curr) : [].concat(prev, [curr]);
        }, []);
      }
    };

    var _exit5;

    invariant$1(depth, "Account Resolve Recursion Limit Exceeded", {
      ix: ix,
      accounts: accounts
    });
    var authorizations = [];

    var _temp10 = _forOf(accounts, function (ax) {
      function _temp6() {
        var _exit4;

        function _temp4(_result3) {
          if (_exit4) ;
          if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];
        }

        var _temp3 = function () {
          if (Array.isArray(ax)) {
            return Promise.resolve(collectAccounts(ix, ax, old, depth - 1)).then(function () {});
          } else {
            if (ax.addr != null && ax.keyId != null) {
              ax.tempId = ax.addr + "-" + ax.keyId;
            }

            ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;
            ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;
            ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;
            ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;

            if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {
              ix.proposer = ax.tempId;
            }

            if (ix.accounts[ax.tempId].role.payer) {
              if (Array.isArray(ix.payer)) {
                ix.payer = Array.from(new Set([].concat(ix.payer, [ax.tempId]).map(function (d) {
                  return d === old.tempId ? ax.tempId : d;
                })));
              } else {
                ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(function (d) {
                  return d === old.tempId ? ax.tempId : d;
                })));
              }

              if (ix.payer.length > 1) {
                // remove payer dups based on addr and keyId
                var dupList = [];
                var payerAccts = [];
                ix.payer = ix.payer.reduce(function (g, tempId) {
                  var _ix$accounts$tempId = ix.accounts[tempId],
                      addr = _ix$accounts$tempId.addr,
                      keyId = _ix$accounts$tempId.keyId;
                  var key = addr + "-" + keyId;
                  payerAccts.push(addr);
                  if (dupList.includes(key)) return g;
                  dupList.push(key);
                  return [].concat(g, [tempId]);
                }, []);
                var multiAccts = Array.from(new Set(payerAccts));

                if (multiAccts.length > 1) {
                  throw new Error("Payer can not be different accounts");
                }
              }
            }

            if (ix.accounts[ax.tempId].role.authorizer) {
              if (last) {
                // do group replacement
                authorizations = Array.from(new Set([].concat(authorizations, [ax.tempId])));
              } else {
                // do 1-1 replacement
                ix.authorizations = ix.authorizations.map(function (d) {
                  return d === old.tempId ? ax.tempId : d;
                });
              }
            }
          }
        }();

        return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
      }

      var old = last || ax;

      var _temp5 = function () {
        if (isFn(ax.resolve)) return Promise.resolve(ax.resolve(ax, buildPreSignable(ax, ix))).then(function (_ax$resolve) {
          ax = _ax$resolve;
        });
      }();

      return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
    }, function () {
      return _exit5;
    });

    return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));
  } catch (e) {
    return Promise.reject(e);
  }
};

var isFn = function isFn(v) {
  return typeof v === "function";
};

function buildPreSignable(acct, ix) {
  try {
    return {
      f_type: "PreSignable",
      f_vsn: "1.0.1",
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(function (d) {
        return ix.arguments[d].asArgument;
      }),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildPreSignable", error);
    throw error;
  }
}

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var resolveSignatures = function resolveSignatures(ix) {
  try {
    var _exit2;

    var _temp2 = function () {
      if (isTransaction(ix)) {
        return _catch(function () {
          var insideSigners = findInsideSigners(ix);
          var insidePayload = encodeTransactionPayload(prepForEncoding(ix));
          return Promise.resolve(Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)))).then(function () {
            var outsideSigners = findOutsideSigners(ix);
            var outsidePayload = encodeTransactionEnvelope(_extends({}, prepForEncoding(ix), {
              payloadSigs: insideSigners.map(function (id) {
                return {
                  address: ix.accounts[id].addr,
                  keyId: ix.accounts[id].keyId,
                  sig: ix.accounts[id].signature
                };
              })
            }));
            return Promise.resolve(Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)))).then(function () {});
          });
        }, function (error) {
          console.error("Signatures", error, {
            ix: ix
          });
          throw error;
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function (_result2) {
      return _exit2 ? _result2 : ix;
    }) : _exit2 ? _temp2 : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

function fetchSignature(ix, payload) {
  return function innerFetchSignature(id) {
    try {
      var acct = ix.accounts[id];
      if (acct.signature != null) return Promise.resolve();
      return Promise.resolve(acct.signingFunction(buildSignable(acct, payload, ix))).then(function (_ref) {
        var signature = _ref.signature;
        ix.accounts[id].signature = signature;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function buildSignable(acct, message, ix) {
  try {
    return {
      f_type: "Signable",
      f_vsn: "1.0.1",
      message: message,
      addr: sansPrefix(acct.addr),
      keyId: acct.keyId,
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(function (d) {
        return ix.arguments[d].asArgument;
      }),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildSignable", error);
    throw error;
  }
}

function prepForEncoding(ix) {
  var payerAddress = sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(function (id) {
      return ix.arguments[id].asArgument;
    }),
    proposalKey: {
      address: sansPrefix(ix.accounts[ix.proposer].addr),
      keyId: ix.accounts[ix.proposer].keyId,
      sequenceNum: ix.accounts[ix.proposer].sequenceNum
    },
    payer: payerAddress,
    authorizers: ix.authorizations.map(function (cid) {
      return sansPrefix(ix.accounts[cid].addr);
    }).reduce(function (prev, current) {
      return prev.find(function (item) {
        return item === current;
      }) ? prev : [].concat(prev, [current]);
    }, [])
  };
}

var resolveValidators = function resolveValidators(ix) {
  try {
    var validators = get(ix, 'ix.validators', []);
    return Promise.resolve(pipe(ix, validators.map(function (cb) {
      return function (ix) {
        return cb(ix, {
          Ok: Ok,
          Bad: Bad
        });
      };
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

var resolveFinalNormalization = function resolveFinalNormalization(ix) {
  try {
    for (var _i = 0, _Object$keys = Object.keys(ix.accounts); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      ix.accounts[key].addr = sansPrefix(ix.accounts[key].addr);
    }

    return Promise.resolve(ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var resolveVoucherIntercept = function resolveVoucherIntercept(ix) {
  try {
    var fn = get(ix, "ix.voucher-intercept");

    var _temp2 = function () {
      if (isFn$3(fn)) {
        return Promise.resolve(fn(createSignableVoucher(ix))).then(function () {});
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
      return ix;
    }) : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var execFetchSequenceNumber = function execFetchSequenceNumber(ix) {
  try {
    var _temp6 = function () {
      if (isTransaction(ix)) {
        var acct = Object.values(ix.accounts).find(function (a) {
          return a.role.proposer;
        });
        invariant$1(acct, "Transactions require a proposer");

        var _temp7 = function () {
          if (acct.sequenceNum == null) {
            return Promise.resolve(config().get("accessNode.api")).then(function (node) {
              return Promise.resolve(config.first(["sdk.transport", "sdk.send"], send$1)).then(function (sendFn) {
                invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: " + "https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");
                return Promise.resolve(build([getAccount(acct.addr)])).then(function (_build) {
                  return Promise.resolve(sendFn(_build, {
                    config: config,
                    response: response,
                    Buffer: Buffer,
                    ix: ixModule
                  }, {
                    node: node
                  }).then(decodeResponse).then(function (acct) {
                    return acct.keys;
                  }).then(function (keys) {
                    return keys.find(function (key) {
                      return key.index === acct.keyId;
                    });
                  }).then(function (key) {
                    return key.sequenceNumber;
                  })).then(function (_sendFn$then$then$the) {
                    ix.accounts[acct.tempId].sequenceNum = _sendFn$then$then$the;
                  });
                });
              });
            });
          }
        }();

        if (_temp7 && _temp7.then) return _temp7.then(function () {});
      }
    }();

    return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {
      return ix;
    }) : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var execFetchRef = function execFetchRef(ix) {
  try {
    var _temp3 = function () {
      if (isTransaction(ix) && ix.message.refBlock == null) {
        return Promise.resolve(config().get("accessNode.api")).then(function (node) {
          return Promise.resolve(config.first(["sdk.transport", "sdk.send"], send$1)).then(function (sendFn) {
            invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: " + "https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");
            return Promise.resolve(sendFn(build([getBlock()]), {
              config: config,
              response: response,
              Buffer: Buffer,
              ix: ixModule
            }, {
              node: node
            }).then(decodeResponse)).then(function (_sendFn$then) {
              ix.message.refBlock = _sendFn$then.id;
            });
          });
        });
      }
    }();

    return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(function () {
      return ix;
    }) : ix);
  } catch (e) {
    return Promise.reject(e);
  }
};

var noop = function noop(v) {
  return v;
};

var debug = function debug(key, fn) {
  if (fn === void 0) {
    fn = noop;
  }

  return function (ix) {
    try {
      var take = function take(obj, keys) {
        if (keys === void 0) {
          keys = [];
        }

        if (typeof keys === "string") keys = keys.split(" ");
        keys.reduce(function (acc, key) {
          var _extends2;

          return _extends({}, acc, (_extends2 = {}, _extends2[key] = obj[key], _extends2));
        }, {});
      };

      var accts = function accts(ix) {
        return ["\nAccounts:", {
          proposer: ix.proposer,
          authorizations: ix.authorizations,
          payer: ix.payer
        }, "\n\nDetails:", ix.accounts].filter(Boolean);
      };

      var log = function log() {
        var _console;

        (_console = console).log.apply(_console, ["debug[" + key + "] ---\n"].concat([].slice.call(arguments), ["\n\n\n---"]));
      };

      return Promise.resolve(config.get("debug." + key)).then(function (_config$get) {
        var _temp = function () {
          if (_config$get) return Promise.resolve(fn(ix, log, accts)).then(function () {});
        }();

        return _temp && _temp.then ? _temp.then(function () {
          return ix;
        }) : ix;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
};

var resolve = pipe([resolveCadence, debug("cadence", function (ix, log) {
  return log(ix.message.cadence);
}), resolveArguments, debug("arguments", function (ix, log) {
  return log(ix.message.arguments, ix.message);
}), resolveAccounts, debug("accounts", function (ix, log, accts) {
  return log.apply(void 0, accts(ix));
}),
/* special */
execFetchRef,
/* special */
execFetchSequenceNumber, resolveSignatures, debug("signatures", function (ix, log, accts) {
  return log.apply(void 0, accts(ix));
}), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", function (ix, log) {
  return log(ix);
})]);

function invariant() {
  var args = [].slice.call(arguments);

  if (args.length > 1) {
    var _args = args,
        predicate = _args[0],
        message = _args[1];
    return invariant(function (ix, _ref) {
      var Ok = _ref.Ok,
          Bad = _ref.Bad;
      return predicate ? Ok(ix) : Bad(ix, message);
    });
  }

  var _args2 = args,
      fn = _args2[0];
  return function (ix) {
    return fn(ix, {
      Ok: Ok,
      Bad: Bad
    });
  };
}

var send = function send(args, opts) {
  if (args === void 0) {
    args = [];
  }

  if (opts === void 0) {
    opts = {};
  }

  try {
    return Promise.resolve(config.first(["sdk.transport", "sdk.send"], opts.send || send$1)).then(function (sendFn) {
      invariant(sendFn, "Required value for sdk.transport is not defined in config. See: " + "https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");
      return Promise.resolve(config.first(["sdk.resolve"], opts.resolve || resolve)).then(function (resolveFn) {
        function _temp(_config$get) {
          opts.node = _config$get;
          if (Array.isArray(args)) args = pipe(interaction(), args);
          return Promise.resolve(resolveFn(args)).then(function (_resolveFn) {
            return sendFn(_resolveFn, {
              config: config,
              response: response,
              ix: ixModule,
              Buffer: Buffer
            }, opts);
          });
        }

        var _opts$node = opts.node;
        return _opts$node ? _temp(_opts$node) : Promise.resolve(config().get("accessNode.api")).then(_temp);
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var decode = function decode(response) {
  try {
    return Promise.resolve(config().where(/^decoder\./)).then(function (decodersFromConfig) {
      var decoders = Object.entries(decodersFromConfig).map(function (_ref) {
        var pattern = _ref[0],
            xform = _ref[1];
        pattern = "/" + pattern.replace(/^decoder\./, "") + "$/";
        return [pattern, xform];
      });
      return decodeResponse(response, Object.fromEntries(decoders));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var findPayloadSigners = function findPayloadSigners(voucher) {
  // Payload Signers Are: (authorizers + proposer) - payer
  var payload = new Set(voucher.authorizers);
  payload.add(voucher.proposalKey.address);
  payload["delete"](voucher.payer);
  return Array.from(payload).map(withPrefix);
};

var findEnvelopeSigners = function findEnvelopeSigners(voucher) {
  // Envelope Signers Are: (payer)
  var envelope = new Set([voucher.payer]);
  return Array.from(envelope).map(withPrefix);
};

var UnableToDetermineMessageEncodingTypeForSignerAddress = /*#__PURE__*/function (_Error) {
  _inheritsLoose(UnableToDetermineMessageEncodingTypeForSignerAddress, _Error);

  function UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress) {
    var _this;

    var msg = ("\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: " + signerAddress + ". \n        Please ensure the address: " + signerAddress + " is intended to sign the given transaction as specified by the transaction signable.\n      ").trim();
    _this = _Error.call(this, msg) || this;
    _this.name = "Unable To Determine Message Encoding For Signer Addresss";
    return _this;
  }

  return UnableToDetermineMessageEncodingTypeForSignerAddress;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var encodeMessageFromSignable = function encodeMessageFromSignable(signable, signerAddress) {
  var payloadSigners = findPayloadSigners(signable.voucher);
  var envelopeSigners = findEnvelopeSigners(signable.voucher);
  var isPayloadSigner = payloadSigners.includes(withPrefix(signerAddress));
  var isEnvelopeSigner = envelopeSigners.includes(withPrefix(signerAddress));

  if (!isPayloadSigner && !isEnvelopeSigner) {
    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
  }

  var message = {
    cadence: signable.voucher.cadence,
    refBlock: signable.voucher.refBlock,
    computeLimit: signable.voucher.computeLimit,
    arguments: signable.voucher.arguments,
    proposalKey: _extends({}, signable.voucher.proposalKey, {
      address: sansPrefix(signable.voucher.proposalKey.address)
    }),
    payer: sansPrefix(signable.voucher.payer),
    authorizers: signable.voucher.authorizers.map(sansPrefix),
    payloadSigs: signable.voucher.payloadSigs.map(function (ps) {
      return _extends({}, ps, {
        address: sansPrefix(ps.address)
      });
    })
  };
  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
};

function validator(cb) {
  return update('ix.validators', function (validators) {
    return Array.isArray(validators) ? validators.push(cb) : [cb];
  });
}

function atBlockHeight(height) {
  return pipe([function (ix) {
    ix.block.height = height;
    return ix;
  }, validator(function (ix) {
    if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
    if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
    return ix;
  })]);
}

function atBlockId(id) {
  return pipe([function (ix) {
    ix.block.id = id;
    return Ok(ix);
  }, validator(function (ix, _ref) {
    var Ok = _ref.Ok,
        Bad = _ref.Bad;
    if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
    if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
    if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
    return Ok(ix);
  })]);
}

function account(address, _temp, opts) {
  var _ref = _temp === void 0 ? {} : _temp,
      height = _ref.height,
      id = _ref.id;

  invariant$1(!(id && height), "Method: account -- Cannot pass \"id\" and \"height\" simultaneously"); // Get account by ID

  if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse); // Get account by height

  if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);
  return send([getAccount(address)], opts).then(decodeResponse);
}

function block(_temp, opts) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$sealed = _ref.sealed,
      sealed = _ref$sealed === void 0 ? false : _ref$sealed,
      id = _ref.id,
      height = _ref.height;

  if (opts === void 0) {
    opts = {};
  }

  invariant$1(!(sealed && id || sealed && height), "Method: block -- Cannot pass \"sealed\" with \"id\" or \"height\"");
  invariant$1(!(id && height), "Method: block -- Cannot pass \"id\" and \"height\" simultaneously"); // Get block by ID

  if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse); // Get block by height

  if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse); // Get latest block

  return send([getBlock(sealed)], opts).then(decodeResponse);
}

function authorizations(ax) {
  if (ax === void 0) {
    ax = [];
  }

  return pipe(ax.map(function (authz) {
    return prepAccount(authz, {
      role: AUTHORIZER
    });
  }));
}
function authorization(addr, signingFunction, keyId, sequenceNum) {
  return {
    addr: addr,
    signingFunction: signingFunction,
    keyId: keyId,
    sequenceNum: sequenceNum
  };
}

function getEvents(eventType, start, end) {
  if (typeof start !== "undefined" || typeof end !== "undefined") {
    console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing a start and end into getEnvents has been deprecated and will not be supported in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\n  \n      ============================\n    ", "font-weight:bold;font-family:monospace;");
  }

  return pipe([makeGetEvents, function (ix) {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

function getEventsAtBlockHeightRange(eventType, start, end) {
  return pipe([makeGetEvents, function (ix) {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

function getEventsAtBlockIds(eventType, blockIds) {
  if (blockIds === void 0) {
    blockIds = [];
  }

  return pipe([makeGetEvents, function (ix) {
    ix.events.eventType = eventType;
    ix.events.blockIds = blockIds;
    return Ok(ix);
  }]);
}

function getBlockHeader(isSealed) {
  if (isSealed === void 0) {
    isSealed = null;
  }

  return pipe([makeGetBlockHeader, function (ix) {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

function getCollection(id) {
  if (id === void 0) {
    id = null;
  }

  return pipe([makeGetCollection, function (ix) {
    ix.collection.id = id;
    return ix;
  }]);
}

function getTransactionStatus(transactionId) {
  return pipe([makeGetTransactionStatus, function (ix) {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function getTransaction(transactionId) {
  return pipe([makeGetTransaction, function (ix) {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function limit(computeLimit) {
  return function (ix) {
    ix.message.computeLimit = computeLimit;
    return ix;
  };
}

function args(ax) {
  if (ax === void 0) {
    ax = [];
  }

  return pipe(ax.map(makeArgument));
}
function arg(value, xform) {
  return {
    value: value,
    xform: xform
  };
}

var proposer = function proposer(authz) {
  try {
    return Promise.resolve(prepAccount(authz, {
      role: PROPOSER
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var payer = function payer(authz) {
  try {
    return Promise.resolve(prepAccount(authz, {
      role: PAYER
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

function ping() {
  return makePing;
}

function ref(refBlock) {
  return pipe([function (ix) {
    ix.message.refBlock = refBlock;
    return Ok(ix);
  }]);
}

function script() {
  return pipe([makeScript, put("ix.cadence", template.apply(void 0, [].slice.call(arguments)))]);
}

var DEFAULT_COMPUTE_LIMIT = 10;
var DEFAULT_SCRIPT_ACCOUNTS = [];
var DEFUALT_REF = null;
function transaction() {
  return pipe([makeTransaction, put("ix.cadence", template.apply(void 0, [].slice.call(arguments))), function (ix) {
    ix.message.computeLimit = ix.message.computeLimit || DEFAULT_COMPUTE_LIMIT;
    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
    return Ok(ix);
  }]);
}

function voucherIntercept(fn) {
  return put("ix.voucher-intercept", fn);
}

var resolveProposerSequenceNumber = function resolveProposerSequenceNumber(_ref) {
  var node = _ref.node;
  return function (ix) {
    try {
      if (!isTransaction(ix)) return Promise.resolve(Ok(ix));
      if (ix.accounts[ix.proposer].sequenceNum) return Promise.resolve(Ok(ix));
      return Promise.resolve(config.first(["sdk.transport", "sdk.send"], send$1)).then(function (sendFn) {
        invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: " + "https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");
        return Promise.resolve(build([getAccount(ix.accounts[ix.proposer].addr)])).then(function (_build) {
          return Promise.resolve(sendFn(_build, {
            config: config,
            response: response,
            Buffer: Buffer,
            ix: ixModule
          }, {
            node: node
          })).then(function (response) {
            return Promise.resolve(decodeResponse(response)).then(function (decoded) {
              ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
              return Ok(ix);
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
};

function mockAccountResponse(ix, numberOfKeys) {
  if (numberOfKeys === void 0) {
    numberOfKeys = 5;
  }

  // prettier-ignore
  invariant$1(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix); // prettier-ignore

  invariant$1(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
  var address = ix.account.addr;
  return {
    account: {
      addr: address,
      keys: Array.from({
        length: numberOfKeys
      }, function (_, i) {
        return {
          index: i,
          sequenceNumber: 42
        };
      })
    }
  };
}
function mockGetBlockResponse(ix) {
  return {
    tag: "GET_BLOCK",
    block: {
      id: "32"
    }
  };
}

var identity = function identity(v) {
  return v;
};

function mockSend(fallback) {
  if (fallback === void 0) {
    fallback = identity;
  }

  return function execSend(ix) {
    return Promise.resolve(ix).then(function (_ix) {
      ix = _ix;

      switch (true) {
        case isGetAccount(ix):
          return mockAccountResponse(ix);

        case isGetBlock(ix):
          return mockGetBlockResponse();

        default:
          return fallback(ix);
      }
    });
  };
}

var _excluded = ["tempId"];
var idof = function idof(acct) {
  return acct.addr + "-" + acct.keyId;
};
function sig(opts) {
  return ["SIGNATURE", opts.addr, opts.keyId].join(".");
}
function authzFn(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (account) {
    var acct = _extends({}, account, opts, {
      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
    });

    return acct;

    function fallbackSigningFunction(signable) {
      return {
        addr: acct.addr,
        keyId: acct.keyId,
        signature: sig(acct)
      };
    }
  };
}
function authzResolve(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (account) {
    var _opts = opts,
        tempId = _opts.tempId,
        rest = _objectWithoutPropertiesLoose(_opts, _excluded);

    return _extends({}, account, {
      tempId: tempId || "WITH_RESOLVE",
      resolve: authzFn(rest)
    });
  };
}
var ROLE = {
  proposer: false,
  authorizer: false,
  payer: false
};

function authzResolveMany(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return function (account) {
    var tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
    return _extends({}, account, {
      tempId: tempId,
      resolve: function resolve() {
        return [opts.proposer && authzFn(opts.proposer)({
          role: _extends({}, ROLE, {
            proposer: true
          })
        })].concat(opts.authorizations.map(authzFn).map(function (d) {
          return d({
            role: _extends({}, ROLE, {
              authorizer: true
            })
          });
        }), [opts.payer && authzFn(opts.payer)({
          role: _extends({}, ROLE, {
            payer: true
          })
        })]).filter(Boolean);
      }
    });
  };
}

var run = function run(fns) {
  if (fns === void 0) {
    fns = [];
  }

  return build([ref("123")].concat(fns)).then(resolve);
};

var index = {
  __proto__: null,
  mockSend: mockSend,
  authzFn: authzFn,
  authzResolve: authzResolve,
  authzResolveMany: authzResolveMany,
  sig: sig,
  idof: idof,
  run: run
};

var VERSION = "1.0.1" ;

var params = function params(_params) {
  return deprecate.error({
    name: "params",
    transitionsPath: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
  });
};
var param = function param(params) {
  return deprecate.warn({
    name: "param",
    transitionsPath: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
  });
};

export { index as TestUtils, VERSION, account, arg, args, atBlockHeight, atBlockId, authorization, authorizations, block, build, createSignableVoucher, decode, destroy, encodeMessageFromSignable, encodeTransactionEnvelope, encodeTransactionPayload, encodeTxIdFromVoucher, get, getAccount, getBlock, getBlockHeader, getCollection, getEvents, getEventsAtBlockHeightRange, getEventsAtBlockIds, getTransaction, getTransactionStatus, interaction, invariant, isBad, isGetAccount, isGetBlock, isGetBlockHeader, isGetCollection, isGetEvents, isGetTransaction, isGetTransactionStatus, isOk, isPing, isScript, isTransaction, isUnknown, limit, param, params, payer, ping, pipe, proposer, put, ref, resolve, resolveAccounts, resolveArguments, resolveCadence, resolveFinalNormalization, resolveProposerSequenceNumber, resolveRefBlockId, resolveSignatures, resolveValidators, resolveVoucherIntercept, script, send, transaction, update, validator, voucherIntercept, voucherToTxId, why };
//# sourceMappingURL=sdk.module.js.map
