function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var queueMicrotask = _interopDefault(require('queue-microtask'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var mailbox = function mailbox() {
  var queue = [];
  var next;
  return {
    deliver: function deliver(msg) {
      try {
        queue.push(msg);

        if (next) {
          next(queue.shift());
          next = undefined;
        }

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    },
    receive: function receive() {
      return new Promise(function innerReceive(resolve) {
        var msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _finallyRethrows(body, finalizer) {
  try {
    var result = body();
  } catch (e) {
    return finalizer(true, e);
  }

  if (result && result.then) {
    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
  }

  return finalizer(false, result);
}

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}

var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}();

function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}

function _for(test, update, body) {
  var stage;

  for (;;) {
    var shouldContinue = test();

    if (_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }

    if (!shouldContinue) {
      return result;
    }

    if (shouldContinue.then) {
      stage = 0;
      break;
    }

    var result = body();

    if (result && result.then) {
      if (_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }

    if (update) {
      var updateValue = update();

      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }

  var pact = new _Pact();

  var reject = _settle.bind(null, pact, 2);

  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;

  function _resumeAfterBody(value) {
    result = value;

    do {
      if (update) {
        updateValue = update();

        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }

      shouldContinue = test();

      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
        _settle(pact, 1, result);

        return;
      }

      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }

      result = body();

      if (_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);

    result.then(_resumeAfterBody).then(void 0, reject);
  }

  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();

      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      _settle(pact, 1, result);
    }
  }

  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      _settle(pact, 1, result);
    }
  }
}

var INIT = "INIT";
var SUBSCRIBE = "SUBSCRIBE";
var UNSUBSCRIBE = "UNSUBSCRIBE";
var UPDATED = "UPDATED";
var SNAPSHOT = "SNAPSHOT";
var EXIT = "EXIT";
var TERMINATE = "TERMINATE";
var root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window;
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var pid = 0;
var DEFAULT_TIMEOUT = 5000;

var _send = function send(addr, tag, data, opts) {
  if (opts === void 0) {
    opts = {};
  }

  return new Promise(function (reply, reject) {
    var expectReply = opts.expectReply || false;
    var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

    if (expectReply && timeout) {
      setTimeout(function () {
        return reject(new Error("Timeout: " + timeout + "ms passed without a response."));
      }, timeout);
    }

    var payload = {
      to: addr,
      from: opts.from,
      tag: tag,
      data: data,
      timeout: timeout,
      reply: reply,
      reject: reject
    };

    try {
      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
      if (!expectReply) reply(true);
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
    }
  });
};
var kill = function kill(addr) {
  delete root.FCL_REGISTRY[addr];
};

var fromHandlers = function fromHandlers(handlers) {
  if (handlers === void 0) {
    handlers = {};
  }

  return function (ctx) {
    try {
      var _temp12 = function _temp12() {
        var _loopInterrupt;

        var _temp6 = _for(function () {
          return !_loopInterrupt && 1;
        }, void 0, function () {
          return Promise.resolve(ctx.receive()).then(function (letter) {
            var _temp5 = _finallyRethrows(function () {
              return _catch(function () {
                function _temp4() {
                  return Promise.resolve(handlers[letter.tag](ctx, letter, letter.data || {})).then(function () {});
                }

                var _temp3 = function () {
                  if (letter.tag === EXIT) {
                    var _temp10 = function _temp10() {
                      _loopInterrupt = 1;
                    };

                    var _temp11 = function () {
                      if (typeof handlers[TERMINATE] === "function") {
                        return Promise.resolve(handlers[TERMINATE](ctx, letter, letter.data || {})).then(function () {});
                      }
                    }();

                    return _temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11);
                  }
                }();

                return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
              }, function (error) {
                console.error(ctx.self() + " Error", letter, error);
              });
            }, function (_wasThrown, _result) {
              return;
              if (_wasThrown) throw _result;
              return _result;
            });

            if (_temp5 && _temp5.then) return _temp5.then(function () {});
          });
        });

        var _temp7 = function () {
          if (_temp6 && _temp6.then) return _temp6.then(function () {});
        }();

        if (_temp7 && _temp7.then) return _temp7.then(function () {});
      };

      var _temp13 = function () {
        if (typeof handlers[INIT] === "function") return Promise.resolve(handlers[INIT](ctx)).then(function () {});
      }();

      return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp12) : _temp12(_temp13));
    } catch (e) {
      return Promise.reject(e);
    }
  };
};

var spawn = function spawn(fn, addr) {
  if (addr === void 0) {
    addr = null;
  }

  if (addr == null) addr = ++pid;
  if (root.FCL_REGISTRY[addr] != null) return addr;
  root.FCL_REGISTRY[addr] = {
    addr: addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {}
  };
  var ctx = {
    self: function self() {
      return addr;
    },
    receive: function receive() {
      return root.FCL_REGISTRY[addr].mailbox.receive();
    },
    send: function send(to, tag, data, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.from = addr;
      return _send(to, tag, data, opts);
    },
    sendSelf: function sendSelf(tag, data, opts) {
      if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
    },
    broadcast: function broadcast(tag, data, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.from = addr;

      for (var _iterator = _createForOfIteratorHelperLoose(root.FCL_REGISTRY[addr].subs), _step; !(_step = _iterator()).done;) {
        var to = _step.value;

        _send(to, tag, data, opts);
      }
    },
    subscribe: function subscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
    },
    unsubscribe: function unsubscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
    },
    subscriberCount: function subscriberCount() {
      return root.FCL_REGISTRY[addr].subs.size;
    },
    hasSubs: function hasSubs() {
      return !!root.FCL_REGISTRY[addr].subs.size;
    },
    put: function put(key, value) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: function get(key, fallback) {
      var value = root.FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    "delete": function _delete(key) {
      delete root.FCL_REGISTRY[addr].kvs[key];
    },
    update: function update(key, fn) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
    },
    keys: function keys() {
      return Object.keys(root.FCL_REGISTRY[addr].kvs);
    },
    all: function all() {
      return root.FCL_REGISTRY[addr].kvs;
    },
    where: function where(pattern) {
      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
        var _extends2;

        return pattern.test(key) ? _extends({}, acc, (_extends2 = {}, _extends2[key] = root.FCL_REGISTRY[addr].kvs[key], _extends2)) : acc;
      }, {});
    },
    merge: function merge(data) {
      if (data === void 0) {
        data = {};
      }

      Object.keys(data).forEach(function (key) {
        return root.FCL_REGISTRY[addr].kvs[key] = data[key];
      });
    }
  };
  if (typeof fn === "object") fn = fromHandlers(fn);
  queueMicrotask(function () {
    try {
      return Promise.resolve(fn(ctx)).then(function () {
        kill(addr);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return addr;
}; // Returns an unsubscribe function
// A SUBSCRIBE handler will need to be created to handle the subscription event
//
//  [SUBSCRIBE]: (ctx, letter) => {
//    ctx.subscribe(letter.from)
//    ctx.send(letter.from, UPDATED, ctx.all())
//  }
//

function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  var EXIT = "@EXIT";
  var self = spawn(function (ctx) {
    try {
      var _exit2;

      ctx.send(address, SUBSCRIBE);
      return Promise.resolve(_for(function () {
        return !_exit2 && 1;
      }, void 0, function () {
        return Promise.resolve(ctx.receive()).then(function (letter) {
          if (letter.tag === EXIT) {
            ctx.send(address, UNSUBSCRIBE);
            _exit2 = 1;
            return;
          }

          callback(letter.data);
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return function () {
    return _send(self, EXIT);
  };
} // Returns a promise that returns a result
// A SNAPSHOT handler will need to be created to handle the snapshot event
//
//  [SNAPSHOT]: (ctx, letter) => {
//    letter.reply(ctx.all())
//  }
//

function snapshoter(address, spawnFn) {
  spawnFn(address);
  return _send(address, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}

exports.EXIT = EXIT;
exports.INIT = INIT;
exports.SNAPSHOT = SNAPSHOT;
exports.SUBSCRIBE = SUBSCRIBE;
exports.TERMINATE = TERMINATE;
exports.UNSUBSCRIBE = UNSUBSCRIBE;
exports.UPDATED = UPDATED;
exports.kill = kill;
exports.send = _send;
exports.snapshoter = snapshoter;
exports.spawn = spawn;
exports.subscriber = subscriber;
//# sourceMappingURL=actor.js.map
