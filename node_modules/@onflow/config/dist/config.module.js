import { SUBSCRIBE, UNSUBSCRIBE, spawn, send, subscriber } from '@onflow/util-actor';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var _HANDLERS;

var first = function first(wants, fallback) {
  if (wants === void 0) {
    wants = [];
  }

  try {
    if (!wants.length) return Promise.resolve(fallback);

    var _wants = wants,
        head = _wants[0],
        rest = _wants.slice(1);

    return Promise.resolve(get(head)).then(function (ret) {
      return ret == null ? first(rest, fallback) : ret;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var NAME = "config";
var PUT = "PUT_CONFIG";
var GET = "GET_CONFIG";
var GET_ALL = "GET_ALL_CONFIG";
var UPDATE = "UPDATE_CONFIG";
var DELETE = "DELETE_CONFIG";
var CLEAR = "CLEAR_CONFIG";
var WHERE = "WHERE_CONFIG";
var UPDATED = "CONFIG/UPDATED";

var identity = function identity(v) {
  return v;
};

var HANDLERS = (_HANDLERS = {}, _HANDLERS[PUT] = function (ctx, _letter, _ref) {
  var key = _ref.key,
      value = _ref.value;
  if (key == null) throw new Error("Missing 'key' for config/put.");
  ctx.put(key, value);
  ctx.broadcast(UPDATED, _extends({}, ctx.all()));
}, _HANDLERS[GET] = function (ctx, letter, _ref2) {
  var key = _ref2.key,
      fallback = _ref2.fallback;
  if (key == null) throw new Error("Missing 'key' for config/get");
  letter.reply(ctx.get(key, fallback));
}, _HANDLERS[GET_ALL] = function (ctx, letter) {
  letter.reply(_extends({}, ctx.all()));
}, _HANDLERS[UPDATE] = function (ctx, letter, _ref3) {
  var key = _ref3.key,
      fn = _ref3.fn;
  if (key == null) throw new Error("Missing 'key' for config/update");
  ctx.update(key, fn || identity);
  ctx.broadcast(UPDATED, _extends({}, ctx.all()));
}, _HANDLERS[DELETE] = function (ctx, letter, _ref4) {
  var key = _ref4.key;
  if (key == null) throw new Error("Missing 'key' for config/delete");
  ctx["delete"](key);
  ctx.broadcast(UPDATED, _extends({}, ctx.all()));
}, _HANDLERS[CLEAR] = function (ctx, letter) {
  var keys = Object.keys(ctx.all());

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    ctx["delete"](key);
  }

  ctx.broadcast(UPDATED, _extends({}, ctx.all()));
}, _HANDLERS[WHERE] = function (ctx, letter, _ref5) {
  var pattern = _ref5.pattern;
  if (pattern == null) throw new Error("Missing 'pattern' for config/where");
  letter.reply(ctx.where(pattern));
}, _HANDLERS[SUBSCRIBE] = function (ctx, letter) {
  ctx.subscribe(letter.from);
  ctx.send(letter.from, UPDATED, _extends({}, ctx.all()));
}, _HANDLERS[UNSUBSCRIBE] = function (ctx, letter) {
  ctx.unsubscribe(letter.from);
}, _HANDLERS);
spawn(HANDLERS, NAME);

function put(key, value) {
  send(NAME, PUT, {
    key: key,
    value: value
  });
  return config();
}

function get(key, fallback) {
  return send(NAME, GET, {
    key: key,
    fallback: fallback
  }, {
    expectReply: true,
    timeout: 10
  });
}

function all() {
  return send(NAME, GET_ALL, null, {
    expectReply: true,
    timeout: 10
  });
}

function update(key, fn) {
  if (fn === void 0) {
    fn = identity;
  }

  send(NAME, UPDATE, {
    key: key,
    fn: fn
  });
  return config();
}

function _delete(key) {
  send(NAME, DELETE, {
    key: key
  });
  return config();
}

function where(pattern) {
  return send(NAME, WHERE, {
    pattern: pattern
  }, {
    expectReply: true,
    timeout: 10
  });
}

function subscribe(callback) {
  return subscriber(NAME, function () {
    return spawn(HANDLERS, NAME);
  }, callback);
}

function clearConfig() {
  return send(NAME, CLEAR);
}

function config(values) {
  if (values != null && typeof values === "object") {
    Object.keys(values).map(function (d) {
      return put(d, values[d]);
    });
  }

  return {
    put: put,
    get: get,
    all: all,
    first: first,
    update: update,
    "delete": _delete,
    where: where,
    subscribe: subscribe,
    overload: overload
  };
}

config.put = put;
config.get = get;
config.all = all;
config.first = first;
config.update = update;
config["delete"] = _delete;
config.where = where;
config.subscribe = subscribe;
config.overload = overload;

var noop = function noop(v) {
  return v;
};

function overload(opts, callback) {
  if (opts === void 0) {
    opts = {};
  }

  if (callback === void 0) {
    callback = noop;
  }

  return new Promise(function (resolve, reject) {
    try {
      return Promise.resolve(all()).then(function (oldConfig) {
        var _temp = _catch(function () {
          config(opts);
          var _callback = callback;
          return Promise.resolve(all()).then(function (_all) {
            return Promise.resolve(_callback(_all)).then(function (result) {
              return Promise.resolve(clearConfig()).then(function () {
                return Promise.resolve(config(oldConfig)).then(function () {
                  resolve(result);
                });
              });
            });
          });
        }, function (error) {
          return Promise.resolve(clearConfig()).then(function () {
            return Promise.resolve(config(oldConfig)).then(function () {
              reject(error);
            });
          });
        });

        if (_temp && _temp.then) return _temp.then(function () {});
      });
    } catch (e) {
      return Promise.reject(e);
    }
  });
}

export { clearConfig, config };
//# sourceMappingURL=config.module.js.map
