(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.utilLogger = {}));
}(this, (function (exports) {
  var promise;
  var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask : function (cb) {
    return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
      return setTimeout(function () {
        throw err;
      }, 0);
    });
  };

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var mailbox = function mailbox() {
    var queue = [];
    var next;
    return {
      deliver: function deliver(msg) {
        try {
          queue.push(msg);

          if (next) {
            next(queue.shift());
            next = undefined;
          }

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      },
      receive: function receive() {
        return new Promise(function innerReceive(resolve) {
          var msg = queue.shift();
          if (msg) return resolve(msg);
          next = resolve;
        });
      }
    };
  };

  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, result);
  }

  function _settle(pact, state, value) {
    if (!pact.s) {
      if (value instanceof _Pact) {
        if (value.s) {
          if (state & 1) {
            state = value.s;
          }

          value = value.v;
        } else {
          value.o = _settle.bind(null, pact, state);
          return;
        }
      }

      if (value && value.then) {
        value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
        return;
      }

      pact.s = state;
      pact.v = value;
      var observer = pact.o;

      if (observer) {
        observer(pact);
      }
    }
  }

  var _Pact = /*#__PURE__*/function () {
    function _Pact() {}

    _Pact.prototype.then = function (onFulfilled, onRejected) {
      var result = new _Pact();
      var state = this.s;

      if (state) {
        var callback = state & 1 ? onFulfilled : onRejected;

        if (callback) {
          try {
            _settle(result, 1, callback(this.v));
          } catch (e) {
            _settle(result, 2, e);
          }

          return result;
        } else {
          return this;
        }
      }

      this.o = function (_this) {
        try {
          var value = _this.v;

          if (_this.s & 1) {
            _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
          } else if (onRejected) {
            _settle(result, 1, onRejected(value));
          } else {
            _settle(result, 2, value);
          }
        } catch (e) {
          _settle(result, 2, e);
        }
      };

      return result;
    };

    return _Pact;
  }();

  function _isSettledPact(thenable) {
    return thenable instanceof _Pact && thenable.s & 1;
  }

  function _for(test, update, body) {
    var stage;

    for (;;) {
      var shouldContinue = test();

      if (_isSettledPact(shouldContinue)) {
        shouldContinue = shouldContinue.v;
      }

      if (!shouldContinue) {
        return result;
      }

      if (shouldContinue.then) {
        stage = 0;
        break;
      }

      var result = body();

      if (result && result.then) {
        if (_isSettledPact(result)) {
          result = result.s;
        } else {
          stage = 1;
          break;
        }
      }

      if (update) {
        var updateValue = update();

        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
          stage = 2;
          break;
        }
      }
    }

    var pact = new _Pact();

    var reject = _settle.bind(null, pact, 2);

    (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
    return pact;

    function _resumeAfterBody(value) {
      result = value;

      do {
        if (update) {
          updateValue = update();

          if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {
            updateValue.then(_resumeAfterUpdate).then(void 0, reject);
            return;
          }
        }

        shouldContinue = test();

        if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {
          _settle(pact, 1, result);

          return;
        }

        if (shouldContinue.then) {
          shouldContinue.then(_resumeAfterTest).then(void 0, reject);
          return;
        }

        result = body();

        if (_isSettledPact(result)) {
          result = result.v;
        }
      } while (!result || !result.then);

      result.then(_resumeAfterBody).then(void 0, reject);
    }

    function _resumeAfterTest(shouldContinue) {
      if (shouldContinue) {
        result = body();

        if (result && result.then) {
          result.then(_resumeAfterBody).then(void 0, reject);
        } else {
          _resumeAfterBody(result);
        }
      } else {
        _settle(pact, 1, result);
      }
    }

    function _resumeAfterUpdate() {
      if (shouldContinue = test()) {
        if (shouldContinue.then) {
          shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        } else {
          _resumeAfterTest(shouldContinue);
        }
      } else {
        _settle(pact, 1, result);
      }
    }
  }

  var INIT = "INIT";
  var SUBSCRIBE = "SUBSCRIBE";
  var UNSUBSCRIBE = "UNSUBSCRIBE";
  var EXIT = "EXIT";
  var TERMINATE = "TERMINATE";
  var root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window;
  root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
  var pid = 0;
  var DEFAULT_TIMEOUT = 5000;

  var _send = function send(addr, tag, data, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return new Promise(function (reply, reject) {
      var expectReply = opts.expectReply || false;
      var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

      if (expectReply && timeout) {
        setTimeout(function () {
          return reject(new Error("Timeout: " + timeout + "ms passed without a response."));
        }, timeout);
      }

      var payload = {
        to: addr,
        from: opts.from,
        tag: tag,
        data: data,
        timeout: timeout,
        reply: reply,
        reject: reject
      };

      try {
        root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
        if (!expectReply) reply(true);
      } catch (error) {
        console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
      }
    });
  };

  var kill = function kill(addr) {
    delete root.FCL_REGISTRY[addr];
  };

  var fromHandlers = function fromHandlers(handlers) {
    if (handlers === void 0) {
      handlers = {};
    }

    return function (ctx) {
      try {
        var _temp12 = function _temp12() {
          var _loopInterrupt;

          var _temp6 = _for(function () {
            return !_loopInterrupt && 1;
          }, void 0, function () {
            return Promise.resolve(ctx.receive()).then(function (letter) {
              var _temp5 = _finallyRethrows(function () {
                return _catch(function () {
                  function _temp4() {
                    return Promise.resolve(handlers[letter.tag](ctx, letter, letter.data || {})).then(function () {});
                  }

                  var _temp3 = function () {
                    if (letter.tag === EXIT) {
                      var _temp10 = function _temp10() {
                        _loopInterrupt = 1;
                      };

                      var _temp11 = function () {
                        if (typeof handlers[TERMINATE] === "function") {
                          return Promise.resolve(handlers[TERMINATE](ctx, letter, letter.data || {})).then(function () {});
                        }
                      }();

                      return _temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11);
                    }
                  }();

                  return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);
                }, function (error) {
                  console.error(ctx.self() + " Error", letter, error);
                });
              }, function (_wasThrown, _result) {
                return;
                if (_wasThrown) throw _result;
                return _result;
              });

              if (_temp5 && _temp5.then) return _temp5.then(function () {});
            });
          });

          var _temp7 = function () {
            if (_temp6 && _temp6.then) return _temp6.then(function () {});
          }();

          if (_temp7 && _temp7.then) return _temp7.then(function () {});
        };

        var _temp13 = function () {
          if (typeof handlers[INIT] === "function") return Promise.resolve(handlers[INIT](ctx)).then(function () {});
        }();

        return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp12) : _temp12(_temp13));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  };

  var spawn = function spawn(fn, addr) {
    if (addr === void 0) {
      addr = null;
    }

    if (addr == null) addr = ++pid;
    if (root.FCL_REGISTRY[addr] != null) return addr;
    root.FCL_REGISTRY[addr] = {
      addr: addr,
      mailbox: mailbox(),
      subs: new Set(),
      kvs: {}
    };
    var ctx = {
      self: function self() {
        return addr;
      },
      receive: function receive() {
        return root.FCL_REGISTRY[addr].mailbox.receive();
      },
      send: function send(to, tag, data, opts) {
        if (opts === void 0) {
          opts = {};
        }

        opts.from = addr;
        return _send(to, tag, data, opts);
      },
      sendSelf: function sendSelf(tag, data, opts) {
        if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
      },
      broadcast: function broadcast(tag, data, opts) {
        if (opts === void 0) {
          opts = {};
        }

        opts.from = addr;

        for (var _iterator = _createForOfIteratorHelperLoose(root.FCL_REGISTRY[addr].subs), _step; !(_step = _iterator()).done;) {
          var to = _step.value;

          _send(to, tag, data, opts);
        }
      },
      subscribe: function subscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
      },
      unsubscribe: function unsubscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
      },
      subscriberCount: function subscriberCount() {
        return root.FCL_REGISTRY[addr].subs.size;
      },
      hasSubs: function hasSubs() {
        return !!root.FCL_REGISTRY[addr].subs.size;
      },
      put: function put(key, value) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
      },
      get: function get(key, fallback) {
        var value = root.FCL_REGISTRY[addr].kvs[key];
        return value == null ? fallback : value;
      },
      "delete": function _delete(key) {
        delete root.FCL_REGISTRY[addr].kvs[key];
      },
      update: function update(key, fn) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
      },
      keys: function keys() {
        return Object.keys(root.FCL_REGISTRY[addr].kvs);
      },
      all: function all() {
        return root.FCL_REGISTRY[addr].kvs;
      },
      where: function where(pattern) {
        return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
          var _extends2;

          return pattern.test(key) ? _extends({}, acc, (_extends2 = {}, _extends2[key] = root.FCL_REGISTRY[addr].kvs[key], _extends2)) : acc;
        }, {});
      },
      merge: function merge(data) {
        if (data === void 0) {
          data = {};
        }

        Object.keys(data).forEach(function (key) {
          return root.FCL_REGISTRY[addr].kvs[key] = data[key];
        });
      }
    };
    if (typeof fn === "object") fn = fromHandlers(fn);
    queueMicrotask_1(function () {
      try {
        return Promise.resolve(fn(ctx)).then(function () {
          kill(addr);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    });
    return addr;
  };

  function subscriber(address, spawnFn, callback) {
    spawnFn(address);
    var EXIT = "@EXIT";
    var self = spawn(function (ctx) {
      try {
        var _exit2;

        ctx.send(address, SUBSCRIBE);
        return Promise.resolve(_for(function () {
          return !_exit2 && 1;
        }, void 0, function () {
          return Promise.resolve(ctx.receive()).then(function (letter) {
            if (letter.tag === EXIT) {
              ctx.send(address, UNSUBSCRIBE);
              _exit2 = 1;
              return;
            }

            callback(letter.data);
          });
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    });
    return function () {
      return _send(self, EXIT);
    };
  }

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  var _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

  var _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";

  function _catch$1(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  }

  var _HANDLERS;

  var first = function first(wants, fallback) {
    if (wants === void 0) {
      wants = [];
    }

    try {
      if (!wants.length) return Promise.resolve(fallback);

      var _wants = wants,
          head = _wants[0],
          rest = _wants.slice(1);

      return Promise.resolve(get(head)).then(function (ret) {
        return ret == null ? first(rest, fallback) : ret;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var NAME = "config";
  var PUT = "PUT_CONFIG";
  var GET = "GET_CONFIG";
  var GET_ALL = "GET_ALL_CONFIG";
  var UPDATE = "UPDATE_CONFIG";
  var DELETE = "DELETE_CONFIG";
  var CLEAR = "CLEAR_CONFIG";
  var WHERE = "WHERE_CONFIG";
  var UPDATED = "CONFIG/UPDATED";

  var identity = function identity(v) {
    return v;
  };

  var HANDLERS = (_HANDLERS = {}, _HANDLERS[PUT] = function (ctx, _letter, _ref) {
    var key = _ref.key,
        value = _ref.value;
    if (key == null) throw new Error("Missing 'key' for config/put.");
    ctx.put(key, value);
    ctx.broadcast(UPDATED, _extends$1({}, ctx.all()));
  }, _HANDLERS[GET] = function (ctx, letter, _ref2) {
    var key = _ref2.key,
        fallback = _ref2.fallback;
    if (key == null) throw new Error("Missing 'key' for config/get");
    letter.reply(ctx.get(key, fallback));
  }, _HANDLERS[GET_ALL] = function (ctx, letter) {
    letter.reply(_extends$1({}, ctx.all()));
  }, _HANDLERS[UPDATE] = function (ctx, letter, _ref3) {
    var key = _ref3.key,
        fn = _ref3.fn;
    if (key == null) throw new Error("Missing 'key' for config/update");
    ctx.update(key, fn || identity);
    ctx.broadcast(UPDATED, _extends$1({}, ctx.all()));
  }, _HANDLERS[DELETE] = function (ctx, letter, _ref4) {
    var key = _ref4.key;
    if (key == null) throw new Error("Missing 'key' for config/delete");
    ctx["delete"](key);
    ctx.broadcast(UPDATED, _extends$1({}, ctx.all()));
  }, _HANDLERS[CLEAR] = function (ctx, letter) {
    var keys = Object.keys(ctx.all());

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      ctx["delete"](key);
    }

    ctx.broadcast(UPDATED, _extends$1({}, ctx.all()));
  }, _HANDLERS[WHERE] = function (ctx, letter, _ref5) {
    var pattern = _ref5.pattern;
    if (pattern == null) throw new Error("Missing 'pattern' for config/where");
    letter.reply(ctx.where(pattern));
  }, _HANDLERS[SUBSCRIBE] = function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED, _extends$1({}, ctx.all()));
  }, _HANDLERS[UNSUBSCRIBE] = function (ctx, letter) {
    ctx.unsubscribe(letter.from);
  }, _HANDLERS);
  spawn(HANDLERS, NAME);

  function put(key, value) {
    _send(NAME, PUT, {
      key: key,
      value: value
    });
    return config();
  }

  function get(key, fallback) {
    return _send(NAME, GET, {
      key: key,
      fallback: fallback
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function all() {
    return _send(NAME, GET_ALL, null, {
      expectReply: true,
      timeout: 10
    });
  }

  function update(key, fn) {
    if (fn === void 0) {
      fn = identity;
    }

    _send(NAME, UPDATE, {
      key: key,
      fn: fn
    });
    return config();
  }

  function _delete(key) {
    _send(NAME, DELETE, {
      key: key
    });
    return config();
  }

  function where(pattern) {
    return _send(NAME, WHERE, {
      pattern: pattern
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function subscribe(callback) {
    return subscriber(NAME, function () {
      return spawn(HANDLERS, NAME);
    }, callback);
  }

  function clearConfig() {
    return _send(NAME, CLEAR);
  }

  function config(values) {
    if (values != null && typeof values === "object") {
      Object.keys(values).map(function (d) {
        return put(d, values[d]);
      });
    }

    return {
      put: put,
      get: get,
      all: all,
      first: first,
      update: update,
      "delete": _delete,
      where: where,
      subscribe: subscribe,
      overload: overload
    };
  }

  config.put = put;
  config.get = get;
  config.all = all;
  config.first = first;
  config.update = update;
  config["delete"] = _delete;
  config.where = where;
  config.subscribe = subscribe;
  config.overload = overload;

  var noop = function noop(v) {
    return v;
  };

  function overload(opts, callback) {
    if (opts === void 0) {
      opts = {};
    }

    if (callback === void 0) {
      callback = noop;
    }

    return new Promise(function (resolve, reject) {
      try {
        return Promise.resolve(all()).then(function (oldConfig) {
          var _temp = _catch$1(function () {
            config(opts);
            var _callback = callback;
            return Promise.resolve(all()).then(function (_all) {
              return Promise.resolve(_callback(_all)).then(function (result) {
                return Promise.resolve(clearConfig()).then(function () {
                  return Promise.resolve(config(oldConfig)).then(function () {
                    resolve(result);
                  });
                });
              });
            });
          }, function (error) {
            return Promise.resolve(clearConfig()).then(function () {
              return Promise.resolve(config(oldConfig)).then(function () {
                reject(error);
              });
            });
          });

          if (_temp && _temp.then) return _temp.then(function () {});
        });
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }

  var LEVELS = Object.freeze({
    "debug": 5,
    "info": 4,
    "log": 3,
    "warn": 2,
    "error": 1
  });

  var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
    var title = _ref.title,
        message = _ref.message;
    return ["\n    %c" + title + "\n    ============================\n    " + message + "\n    ============================\n    ", "font-weight:bold;font-family:monospace;"];
  };

  var log = function log(_ref2) {
    var title = _ref2.title,
        message = _ref2.message,
        level = _ref2.level,
        _ref2$always = _ref2.always,
        always = _ref2$always === void 0 ? false : _ref2$always;

    try {
      return Promise.resolve(config.get("logger.level", 0)).then(function (configLoggerLevel) {
        var _console, _console2, _console3, _console4, _console5;

        if (!always && configLoggerLevel < level) return;
        var loggerMessageArgs = buildLoggerMessageArgs({
          title: title,
          message: message
        });

        switch (level) {
          case LEVELS.debug:
            (_console = console).debug.apply(_console, loggerMessageArgs);

            break;

          case LEVELS.info:
            (_console2 = console).info.apply(_console2, loggerMessageArgs);

            break;

          case LEVELS.warn:
            (_console3 = console).warn.apply(_console3, loggerMessageArgs);

            break;

          case LEVELS.error:
            (_console4 = console).error.apply(_console4, loggerMessageArgs);

            break;

          default:
            (_console5 = console).log.apply(_console5, loggerMessageArgs);

        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  exports.LEVELS = LEVELS;
  exports.log = log;

})));
//# sourceMappingURL=util-logger.umd.js.map
